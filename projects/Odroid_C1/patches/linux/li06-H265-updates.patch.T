From 99b281f06463e3b84ebef1f537d2a2639c208273 Mon Sep 17 00:00:00 2001
From: Anand Moon <linux.amoon@gmail.com>
Date: Sat, 19 Dec 2015 18:51:54 +0530
Subject: [PATCH] Updates for H265

From: Andrea Torlaschi <runnerway@gmail.com>

This patch is picked from [1].

[1] https://github.com/runnerway/linux/commit/498f38d051bce31f31190158d9afb62c5850c2ab

Change-Id: I874ba568943ace33a05fdcabe06abefd0e72ca62
---
 drivers/amlogic/amports/amvdec.c                 |   21 +
 drivers/amlogic/amports/amvdec.h                 |    2 +
 drivers/amlogic/amports/m8/ucode/h265/vh265_mc.c | 1487 +---
 drivers/amlogic/amports/vh265.c                  | 8989 ++++++++++++----------
 4 files changed, 5377 insertions(+), 5122 deletions(-)
 mode change 100644 => 100755 drivers/amlogic/amports/m8/ucode/h265/vh265_mc.c

diff --git a/drivers/amlogic/amports/amvdec.c b/drivers/amlogic/amports/amvdec.c
index fa3ee72..137db95 100644
--- a/drivers/amlogic/amports/amvdec.c
+++ b/drivers/amlogic/amports/amvdec.c
@@ -773,6 +773,27 @@ int amvdec_resume(struct platform_device *dev)
     
     return 0;
 }
+
+int amhevc_suspend(struct platform_device *dev, pm_message_t event)
+{
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
+    if (HAS_HEVC_VDEC) {
+        amhevc_pg_enable(false);
+    }
+#endif
+    return 0;
+}
+
+int amhevc_resume(struct platform_device *dev)
+{
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
+    if (HAS_HEVC_VDEC) {
+        amhevc_pg_enable(true);
+    }
+#endif
+
+    return 0;
+}
 #endif
 
 #ifdef CONFIG_WAKELOCK
diff --git a/drivers/amlogic/amports/amvdec.h b/drivers/amlogic/amports/amvdec.h
index 5092b83..fcf2d04 100644
--- a/drivers/amlogic/amports/amvdec.h
+++ b/drivers/amlogic/amports/amvdec.h
@@ -70,6 +70,8 @@ extern int amvdev_resume(void);
 #ifdef CONFIG_PM
 extern int amvdec_suspend(struct platform_device *dev, pm_message_t event);
 extern int amvdec_resume(struct platform_device *dec);
+extern int amhevc_suspend(struct platform_device *dev, pm_message_t event);
+extern int amhevc_resume(struct platform_device *dec);
 #endif
 
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
diff --git a/drivers/amlogic/amports/m8/ucode/h265/vh265_mc.c b/drivers/amlogic/amports/m8/ucode/h265/vh265_mc.c
old mode 100644
new mode 100755
index 43c98e8..845b698
--- a/drivers/amlogic/amports/m8/ucode/h265/vh265_mc.c
+++ b/drivers/amlogic/amports/m8/ucode/h265/vh265_mc.c
@@ -20,1069 +20,430 @@
  */
 
 #include <linux/types.h>
-//project_dos revision 3000
+
 //#undef SEND_PARAM_WITH_REG
+const u32 h265_ucode_v = 0xd216c3a6; /* use ucode commit id */
 const u32 vh265_mc[] __attribute__((aligned(8))) = {
-0x06810001,0x06800000,0x0d000001,0x07400040,0x0c000900,0x00000000,
-0x06bffe40,0x07c00000,0x06030400,0x00400000,0x0800c0ff,0x0c030500,
-0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
-0x00000000,0x00000000,0x00000000,0x0c7ffd80,0x00000000,0x00000000,
-0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
-0x00000000,0x00000000,0x0c7a3dc0,0x00000000,0x0c79eac0,0x06412108,
-0x0c780900,0x00000000,0x0cc00000,0x00400000,0x0800c000,0x08002515,
-0x08002608,0x06bfbb80,0x06ffbfc0,0x06070500,0x06070600,0x06070700,
-0x06803fc0,0x07c00140,0x07c007c0,0x07c015c0,0x0640d000,0x07c03500,
-0x0640d200,0x07c03480,0x0640c108,0x06035108,0x06800408,0x06035208,
-0x06a04008,0x06035008,0x06435008,0x0580f208,0x0bef8048,0x00000000,
-0x06435308,0x0900c208,0x0a6f8008,0x00000000,0x0cc00000,0x00000000,
-0x06bfff88,0x06030408,0x00400000,0x0640c008,0x0a6181c8,0x00000000,
-0x0c02d380,0x00000000,0x0c79dac0,0x0800c0ff,0x0aa0c048,0x0c781cc0,
-0x00000000,0x06410c08,0x08010e90,0x09326208,0x0aa0c808,0x0c79d880,
-0x0800c0fe,0x078034c8,0x09808008,0x07c034c8,0x06410c08,0x08010e90,
-0x09384288,0x09223248,0x07c00189,0x09201248,0x07c001c9,0x08010e90,
-0x07800148,0x0a805288,0x07c0010a,0x0aa0ffc8,0x0c025540,0x05407308,
-0x0780010a,0x07c0014a,0x06410c08,0x08010e88,0x09305248,0x07c00209,
-0x06410c08,0x08010e90,0x09210248,0x07c00249,0x06410c08,0x08010e90,
-0x09210248,0x07c00289,0x06410c08,0x08010e84,0x08010e90,0x08010e90,
-0x08010e8c,0x06410c08,0x08010e88,0x09308248,0x07c002c9,0x0780018b,
-0x0aa3800b,0x00000000,0x06410c0a,0x08010e90,0x0aa2800b,0x093e124a,
-0x0aa08009,0x0c780000,0x093c124a,0x0aa08009,0x0c780000,0x0540228a,
-0x0c7ffe00,0x044012cb,0x06410c08,0x08010e81,0x093e1248,0x0780018b,
-0x0a60c009,0x0680000a,0x0780018a,0x0ac0a2ca,0x00000000,0x0c01c900,
-0x06800309,0x0c01c880,0x06800409,0x0c01c800,0x06800509,0x0c7ffe00,
-0x0400128a,0x08010e86,0x06806008,0x06010e08,0x06410f08,0x0befc0c8,
-0x09118208,0x0aa08008,0x0c780000,0x06410c08,0x08010e81,0x093e1248,
-0x0aa38009,0x08010e90,0x08010e90,0x08010e90,0x08010e90,0x06410c08,
-0x08010e81,0x093e1248,0x0aa0c009,0x0c01c200,0x06800049,0x0c01c180,
-0x06800049,0x0aa04008,0x08010e81,0x07800148,0x0aa0ffc8,0x0c024000,
-0x05407308,0x06800067,0x0c02ecc0,0x00000000,0x0c79bdc0,0x0800c0ff,
-0x0aa0c088,0x0c78b9c0,0x00000000,0x06410c08,0x08010e90,0x09326208,
-0x0aa0c848,0x0c79bb80,0x0800c0fe,0x078034c8,0x09808048,0x07c034c8,
-0x06410c08,0x08010e88,0x09384288,0x07c0060a,0x09323248,0x07c00649,
-0x09301248,0x07c00689,0x07800148,0x0a808288,0x07c0010a,0x0c023880,
-0x05407308,0x0780010a,0x07c0014a,0x0c024400,0x0540730a,0x06410c08,
-0x08010e88,0x09305248,0x07c006c9,0x06410c08,0x08010e90,0x09210248,
-0x07c00709,0x06410c08,0x08010e90,0x09210248,0x07c00749,0x06410c08,
-0x08010e84,0x08010e90,0x08010e90,0x08010e8c,0x06410c08,0x08010e88,
-0x09308248,0x07c00789,0x0780064b,0x0aa3800b,0x00000000,0x06410c0a,
-0x08010e90,0x0aa2800b,0x093e124a,0x0aa08009,0x0c780000,0x093c124a,
-0x0aa08009,0x0c780000,0x0540228a,0x0c7ffe00,0x044012cb,0x0c01ae00,
-0x06800049,0x078007c9,0x0a805209,0x07c00108,0x0aa0ffc9,0x0c0232c0,
-0x05407309,0x07800108,0x07c007c8,0x0c01ab80,0x06800809,0x0c01ab00,
-0x06800849,0x0c01aa80,0x06800889,0x07800848,0x07800889,0x09610209,
-0x06012308,0x06410c08,0x08010e81,0x093e1248,0x0aa24009,0x0c01a800,
-0x06800049,0x0c01a780,0x06800049,0x0c01a700,0x06800049,0x0c01a680,
-0x06800049,0x0c01a600,0x068008c9,0x0c01a580,0x06800909,0x0c01a500,
-0x06800949,0x06410c08,0x08010e81,0x093e1248,0x0780064b,0x0a60c009,
-0x0680000a,0x0780064a,0x0ac0a2ca,0x00000000,0x0c01a240,0x06800989,
-0x0c01a1c0,0x06800a89,0x0c01a140,0x06800b89,0x0c7ffe00,0x0400128a,
-0x0c01a040,0x06800c89,0x07800c89,0x07c00d09,0x0c019f40,0x06800cc9,
-0x07800c89,0x07800cc8,0x02009209,0x07c00d49,0x07800d48,0x0a6300c8,
-0x07800849,0x0403f249,0x05806249,0x07c00e09,0x07800889,0x0403f249,
-0x05806249,0x07c00e49,0x08040640,0x0c780900,0x06822be0,0x0a630088,
-0x07800849,0x0401f249,0x05805249,0x07c00e09,0x07800889,0x0401f249,
-0x05805249,0x07c00e49,0x08040620,0x0c780600,0x06823160,0x0a630048,
-0x07800849,0x0400f249,0x05804249,0x07c00e09,0x07800889,0x0400f249,
-0x05804249,0x07c00e49,0x08040610,0x0c780300,0x068239a0,0x07800849,
-0x04007249,0x05803249,0x07c00e09,0x07800889,0x04007249,0x05803249,
-0x07c00e49,0x08040608,0x068244e0,0x07800e08,0x07800e49,0x0e000248,
-0x00000000,0x00000000,0x06800009,0x0f000200,0x04401208,0x0aa10008,
-0x05801208,0x0c7fff80,0x04001249,0x07c01449,0x07800849,0x0780088a,
-0x0960f24a,0x06040209,0x07800e09,0x07800e4a,0x0960c24a,0x06040309,
-0x08040400,0x0c018c80,0x06800049,0x07800049,0x07c00d89,0x0c018b80,
-0x06800089,0x07800049,0x07800088,0x02009209,0x07c00dc9,0x0c018a00,
-0x06800ec9,0x0c018980,0x06800f09,0x06410c08,0x08010e81,0x093e1248,
-0x0aa38009,0x07c00f49,0x06410c08,0x08010e81,0x093e1248,0x0aa0c009,
-0x0c001b40,0x00000000,0x078007c8,0x0aa0c008,0x068f000c,0x069f000c,
-0x0c022580,0x00000000,0x06410c08,0x08010e83,0x093e1248,0x07c00f89,
-0x093c1248,0x07c00fc9,0x093a1248,0x0aa58009,0x06800009,0x06410c08,
-0x08010e88,0x09384248,0x04001249,0x07c01049,0x09304248,0x04001249,
-0x07c01089,0x0c018080,0x068010c9,0x0c018000,0x06801109,0x078010c9,
-0x02008248,0x07c01108,0x06410c08,0x08010e81,0x093e1248,0x07c01149,
-0x06800049,0x07c01009,0x0c017d40,0x06801189,0x0680000e,0x0780118f,
-0x044013cf,0x0aa1000f,0x058013cf,0x0c7fff80,0x0400138e,0x07c011ce,
-0x0780118f,0x0680000e,0x0b4143ce,0x00000000,0x0480f20e,0x05404208,
-0x0680800d,0x0200d20d,0x0c002a00,0x00000000,0x0480f20e,0x0aa1c3c8,
-0x00000000,0x0400120e,0x0b4043c8,0x00000000,0x0c780100,0x00000000,
-0x0c004a80,0x00000000,0x0c7ffb80,0x0400138e,0x06410c08,0x08010e81,
-0x093e1248,0x07c01209,0x0aa28009,0x0c017400,0x06801249,0x0aa1c008,
-0x06410c08,0x08010e89,0x09308248,0x092e1248,0x0c7ffec0,0x04401208,
-0x06410c08,0x08010e83,0x093e1248,0x07c01289,0x093c1248,0x07c012c9,
-0x093a1248,0x06800008,0x07c014c8,0x07c01508,0x07c01548,0x07c01588,
-0x0aa0c009,0x0c004c40,0x00000000,0x08010e81,0x078007c8,0x0aa0ffc8,
-0x0c01f380,0x05407308,0x068000a7,0x0c029a00,0x00000000,0x0c796b00,
-0x0800c0ff,0x068c8408,0x06c41508,0x06070508,0x06070608,0x06070708,
-0x0680000b,0x0680000a,0x06410c08,0x08010e81,0x093e1248,0x0aa08009,
-0x0c780f00,0x0c016880,0x06800049,0x0aa140cb,0x0400e3ca,0x0ba0c0ca,
-0x0680038f,0x068003cf,0x0a60c00b,0x0c780180,0x0647050d,0x0a60c04b,
-0x0c7800c0,0x0647060d,0x0647070d,0x0aa38008,0x0400038f,0x0aa300cb,
-0x0680000e,0x0240f20a,0x0aa2410f,0x0920438d,0x0aa1c0cf,0x0918438d,
-0x0aa1408f,0x0910438d,0x0aa0c04f,0x0908438d,0x0900438d,0x0a61c0cb,
-0x0a60c00a,0x0c7800c0,0x0970434e,0x0978434e,0x0c780ec0,0x0607070d,
-0x0aa1c00a,0x0aa2004a,0x0aa2408a,0x0aa280ca,0x0aa2c10a,0x0c7802c0,
-0x0968434e,0x0c780240,0x0940434e,0x0c7801c0,0x0948434e,0x0c780140,
-0x0950434e,0x0c7800c0,0x0958434e,0x0960434e,0x0aa1000b,0x0aa1404b,
-0x0c7809c0,0x0607070d,0x0c780940,0x0607050d,0x0c7808c0,0x0607060d,
-0x0ba2c08b,0x0680020c,0x0c015b00,0x06800049,0x04008308,0x0aa0c08b,
-0x0680f808,0x0680f988,0x02008288,0x06070208,0x0607040c,0x0aa1c00b,
-0x0680e008,0x0aa1404b,0x06800008,0x0aa0c08b,0x06806008,0x0680c008,
-0x0680040e,0x0aa1000b,0x0540424a,0x0680100e,0x0540624a,0x02008248,
-0x06070208,0x0680004d,0x0c015500,0x06800049,0x0200c20c,0x048ff30c,
-0x0607040c,0x0b8fb38d,0x0400134d,0x0ba0c0cb,0x06800149,0x06800049,
-0x0b40324a,0x0c7fe6c0,0x0400128a,0x0b60c0cb,0x0c7fe5c0,0x040012cb,
-0x0cc00000,0x00000000,0x0aa1400e,0x06800009,0x06410c08,0x08010e81,
-0x093e1248,0x0a608009,0x0c781540,0x07801189,0x0a40624e,0x0440144e,
-0x0c014c40,0x06800049,0x0c002500,0x02411211,0x0480f451,0x05404451,
-0x06808008,0x02011211,0x06800010,0x06800012,0x06410c08,0x08010e81,
-0x093e1288,0x0c014900,0x06800049,0x0aa1000a,0x040014c8,0x06800009,
-0x024134c9,0x0b60c412,0x06a0000b,0x0700044b,0x04001451,0x04001492,
-0x0200c2d3,0x091e12cb,0x0900e30c,0x06410c08,0x08010e81,0x093e1288,
-0x095c130a,0x0a62000a,0x06410c08,0x08010e81,0x093e1288,0x0a61000a,
-0x0a62400b,0x0c7ffb80,0x00000000,0x0740034c,0x0400134d,0x04001410,
-0x0a60c00b,0x0c7ffa00,0x00000000,0x0b60c410,0x06a00008,0x07400348,
-0x0ae08050,0x0c780780,0x0440134d,0x07000351,0x0900e451,0x091a1491,
-0x06900013,0x0aa0c012,0x02012453,0x02412453,0x0680004c,0x0b41240c,
-0x0241130d,0x07000451,0x0900e451,0x091a12d1,0x06900013,0x0aa0c00b,
-0x0200b453,0x0240b453,0x0b4072d2,0x0241130d,0x0400048b,0x0700044b,
-0x07000353,0x0740034b,0x07400453,0x0c7ffc00,0x0400130c,0x0c7ff8c0,
-0x04401410,0x0cc00000,0x00000000,0x0c013800,0x06800049,0x0c013780,
-0x06800089,0x06800010,0x0680000a,0x0680000b,0x0780004c,0x0b41130b,
-0x0c0135c0,0x068000c9,0x0240a20a,0x0440128a,0x06410c08,0x08010e81,
-0x093e1248,0x0900e20a,0x095c1209,0x07400348,0x0400134d,0x04001410,
-0x0bacc410,0x040012cb,0x0cc00000,0x00000000,0x0680000a,0x0680000b,
-0x0780008c,0x0b41130b,0x0c0130c0,0x068000c9,0x0200a20a,0x0400128a,
-0x06410c08,0x08010e81,0x093e1248,0x0900e20a,0x095c1209,0x07400348,
-0x0400134d,0x04001410,0x0bacc410,0x040012cb,0x0cc00000,0x00000000,
-0x06a00008,0x07400348,0x0cc00000,0x00000000,0x0580424e,0x07c01489,
-0x05409249,0x0640c208,0x02008248,0x06035108,0x06808008,0x06035208,
-0x06a08008,0x06035008,0x06435008,0x0580f208,0x0bef8048,0x00000000,
-0x06435308,0x0900c208,0x0a6f8008,0x00000000,0x0cc00000,0x00000000,
-0x05804251,0x07801488,0x0a80e209,0x07c01489,0x05409249,0x0640c208,
-0x02008248,0x06035108,0x06808008,0x06035208,0x06b08008,0x06035008,
-0x06435008,0x0580f208,0x0bef8048,0x00000000,0x0cc00000,0x00000000,
-0x06410c08,0x08010e81,0x093e1248,0x0aa1c009,0x00000000,0x06410c08,
-0x08010e88,0x09301248,0x07c01309,0x0aa03fc9,0x06410c08,0x08010e81,
-0x093e1248,0x0aa08009,0x0c780000,0x06410c08,0x08010e81,0x093e1248,
-0x0aa24009,0x06410c08,0x08010e85,0x09361248,0x0aa14009,0x00000000,
-0x08010e88,0x00000000,0x08010e90,0x06410c08,0x08010e81,0x093e1248,
-0x0aa14009,0x0c011a80,0x06800089,0x0c011a00,0x06800089,0x06410c08,
-0x08010e84,0x093e1248,0x093c1248,0x093a1248,0x09381248,0x0aa24009,
-0x0c0117c0,0x06801349,0x0c011740,0x06801389,0x0c0116c0,0x068013c9,
-0x0c011640,0x06801409,0x06410c08,0x08010e81,0x093e1248,0x0aa7c009,
-0x06410c08,0x08010e90,0x09210248,0x07c014c9,0x06410c08,0x08010e90,
-0x09210248,0x07c01509,0x06410c08,0x08010e90,0x09210248,0x07c01549,
-0x06410c08,0x08010e90,0x09210248,0x07c01589,0x06410c08,0x08010e81,
-0x093e1248,0x0aa10009,0x0c010fc0,0x06800049,0x04001208,0x06410c08,
-0x08010e81,0x093e1248,0x0aa10009,0x0680004a,0x0c000100,0x0780064b,
-0x0cc00000,0x00000000,0x0a60c00a,0x0c7807c0,0x00000000,0x06410c08,
-0x08010e82,0x093c2248,0x0aaec009,0x06410c08,0x08010e81,0x093e1308,
-0x0aa2400c,0x06410c08,0x08010e88,0x09308248,0x06410c08,0x08010e8b,
-0x09365248,0x09341248,0x092a5248,0x06410c08,0x08010e88,0x09384248,
-0x09304248,0x0aa1000c,0x06410c08,0x08010e84,0x09384248,0x06410c08,
-0x08010e8f,0x09365248,0x092c5248,0x09225248,0x0cc00000,0x00000000,
-0x0aa0c0c8,0x0c783240,0x00000000,0x06410c08,0x08010e90,0x09326208,
-0x0aa0c888,0x0c790180,0x0800c0fe,0x078034c8,0x09808088,0x07c034c8,
-0x0c010140,0x06800049,0x078015c9,0x0a805209,0x07c00108,0x0aa0ffc9,
-0x0c0196c0,0x05407309,0x07800108,0x07c015c8,0x0c00fec0,0x06801609,
-0x078007ca,0x0a806288,0x07c00108,0x0780010a,0x07c007ca,0x0c018ec0,
-0x0540730a,0x0780060a,0x07800148,0x0a804288,0x07c0014a,0x0c018800,
-0x0540730a,0x06410c08,0x08010e87,0x093e1248,0x07c01649,0x093c1248,
-0x07c01689,0x09363248,0x07c016c9,0x09341248,0x07c01709,0x09321248,
-0x07c01749,0x0c00f800,0x06801789,0x04001208,0x07c01788,0x0c00f700,
-0x068017c9,0x04001208,0x07c017c8,0x0c00f7c0,0x06801809,0x0401a208,
-0x07c01808,0x06410c08,0x08010e83,0x093e1248,0x07c01849,0x093c1248,
-0x07c01889,0x093a1248,0x07c018c9,0x0aa10009,0x06800008,0x0c00f280,
-0x06801909,0x07c01908,0x0c00f380,0x06801949,0x0c00f300,0x06801989,
-0x06410c08,0x08010e86,0x093e1248,0x07c019c9,0x093c1248,0x07c01a09,
-0x093a1248,0x07c01a49,0x09381248,0x07c01a89,0x09361248,0x07c01ac9,
-0x09341248,0x07c01e09,0x0aa0c009,0x0c014440,0x00000000,0x06800048,
-0x07c01dc8,0x07801ac8,0x0a608008,0x0c780a80,0x0c00eb40,0x06801b49,
-0x07800e08,0x07c01bc8,0x0c00ea40,0x06801b89,0x07800e48,0x07c01cc8,
-0x06410c08,0x08010e81,0x093e1248,0x07c01b09,0x0aa14009,0x0c014780,
-0x00000000,0x0c780580,0x00000000,0x07801b4b,0x0ae0010b,0x0680000a,
-0x0b4072ca,0x0c00e600,0x0406f24a,0x04001208,0x07400248,0x0c7ffec0,
-0x0400128a,0x07801b8b,0x0ae0010b,0x0680000a,0x0b4072ca,0x0c00e380,
-0x0407324a,0x04001208,0x07400248,0x0c7ffec0,0x0400128a,0x06410c08,
-0x08010e81,0x093e1248,0x07c01dc9,0x06410c08,0x08010e82,0x093e1248,
-0x07c01e49,0x093c1248,0x0a618009,0x07c01e89,0x07c01ec9,0x07c01f09,
-0x0c780340,0x07c01f49,0x06410c08,0x08010e82,0x093e1248,0x07c01e89,
-0x093c1248,0x0a618009,0x07c01ec9,0x0c00de40,0x06801f09,0x0c00ddc0,
-0x06801f49,0x06410c08,0x08010e81,0x093e1248,0x0a628009,0x07800f48,
-0x0aa28008,0x07801608,0x0aa0c008,0x068f000c,0x069f000c,0x0c018cc0,
-0x00000000,0x0c7800c0,0x0c076cc0,0x00000000,0x06410c08,0x08010e81,
-0x093e1248,0x07c01f89,0x0c00d6c0,0x06801fc9,0x04002208,0x07c01fc8,
-0x06410c08,0x08010e81,0x093e1248,0x07c02009,0x08010e81,0x0c019300,
-0x00000000,0x078015c8,0x0aa0ffc8,0x0c016a80,0x05407308,0x068000e7,
-0x0c020040,0x078015e8,0x0c78d140,0x0800c0ff,0x0aa0c108,0x0c7876c0,
-0x00000000,0x069fff89,0x0640d408,0x09010208,0x0a8fe248,0x00000000,
-0x06410c08,0x08010e90,0x09326208,0x0b210548,0x07c02048,0x0c78cd80,
-0x0800c0fe,0x06410c08,0x08010e81,0x093e1248,0x07c02089,0x07802048,
-0x0ba1c408,0x06800009,0x0ae14548,0x06800009,0x06410c08,0x08010e81,
-0x093e1248,0x07c020c9,0x0c00cac0,0x06800049,0x078015c9,0x0a815248,
-0x07c00108,0x0a633fc9,0x00000000,0x0c015580,0x0680000c,0x0c015a40,
-0x0680000c,0x0c017bc0,0x00000000,0x0680000c,0x07c00e8c,0x0c01fac0,
-0x00000000,0x07800108,0x07c015c8,0x0c017100,0x05407308,0x068004e7,
-0x0c01f2c0,0x00000000,0x07801608,0x078007c9,0x0a809248,0x07c00108,
-0x07800109,0x07c007c9,0x0c015500,0x05407309,0x068004a7,0x0c01f000,
-0x00000000,0x0780060a,0x07800148,0x0a807288,0x07c0014a,0x0c014d80,
-0x0540730a,0x06800467,0x0c01edc0,0x00000000,0x07802088,0x06800009,
-0x0aa10008,0x07c02149,0x0c780440,0x07c02109,0x07801648,0x0aa14008,
-0x06800009,0x06410c08,0x08010e81,0x093e1248,0x07c02149,0x07801449,
-0x06410c08,0x0680080a,0x0240a24a,0x098091c9,0x06010e09,0x03808288,
-0x07c02108,0x07802148,0x0aa0c008,0x0c784d00,0x00000000,0x0c01bb80,
-0x00000000,0x078016c8,0x0aa0c008,0x098081c8,0x06010e08,0x0c00b800,
-0x06802189,0x07801688,0x0aa14008,0x06800049,0x06410c08,0x08010e81,
-0x093e1248,0x07c021c9,0x07802049,0x0aa084c9,0x0a610509,0x06800008,
-0x0c7818c0,0x07c02208,0x06410c08,0x07800949,0x04004249,0x0680080a,
-0x0240a24a,0x098091c9,0x06010e09,0x03808288,0x07c02208,0x06410c08,
-0x08010e81,0x093e1248,0x0a614009,0x0680400d,0x0c076200,0x0780118e,
-0x0c780600,0x078011c9,0x06410c08,0x068007ca,0x0240a24a,0x098091c9,
-0x06010e09,0x03808288,0x05801208,0x07c02248,0x0c078700,0x04000448,
-0x0480f211,0x05404208,0x06808009,0x02009209,0x0680400d,0x06800008,
-0x0700024a,0x0740034a,0x0400134d,0x04001208,0x0baf0408,0x04001249,
-0x07801208,0x0a608008,0x0c780b80,0x0780124a,0x0aa1400a,0x0680000b,
-0x0c00a8c0,0x06800049,0x040002c8,0x0c00a800,0x06800049,0x0200c20b,
-0x0a60800c,0x0c7808c0,0x0ac0f2cc,0x07801248,0x0ba60048,0x07801248,
-0x0b21c088,0x06802049,0x0b214108,0x06802089,0x0b20c208,0x068020c9,
-0x06802109,0x06410c08,0x06010e09,0x0c780340,0x00000000,0x06410c08,
-0x07800949,0x04004249,0x0680080a,0x0240a24a,0x098091c9,0x06010e09,
-0x03808288,0x06410c08,0x08010e81,0x093e1248,0x06410c08,0x08010e81,
-0x093e1248,0x0aa0c009,0x0c009f40,0x06800049,0x0c7ff780,0x0440130c,
-0x0c019940,0x00000000,0x07801288,0x0aa14008,0x06800009,0x06410c08,
-0x08010e81,0x093e1248,0x07c02289,0x07800fc8,0x0a610008,0x07c022c8,
-0x0c780200,0x07c02308,0x06410c08,0x08010e82,0x093e1248,0x07c022c9,
-0x093c1248,0x07c02309,0x0780218b,0x0a60c08b,0x0c781700,0x00000000,
-0x0641170a,0x06410c08,0x08010e81,0x093e1248,0x0a628009,0x07801789,
-0x09546289,0x07c02349,0x0a60c00b,0x06800009,0x078017c9,0x09606289,
-0x0c7803c0,0x07c02389,0x0c0094c0,0x06802349,0x07802349,0x04001249,
-0x09546289,0x07c02349,0x0aa1c04b,0x0c009300,0x06802389,0x07802389,
-0x04001249,0x09606289,0x07c02389,0x0601170a,0x06800009,0x07c02ac9,
-0x07801f89,0x0aa14009,0x07802a89,0x0b20c049,0x0c019540,0x00000000,
-0x0a61400b,0x06800009,0x06410c08,0x08010e81,0x093e1248,0x0641170a,
-0x096c1289,0x0601170a,0x07c023c9,0x07801749,0x0aa14009,0x06800009,
-0x06410c08,0x08010e81,0x093e1248,0x07c02409,0x06411008,0x09581209,
-0x06011008,0x07802289,0x0aa48009,0x0a61400b,0x06800049,0x06410c08,
-0x08010e81,0x093e1248,0x07c02449,0x0aa1808b,0x0aa0c009,0x06802389,
-0x06802349,0x07000249,0x0ae10049,0x06800009,0x0c780100,0x07c02489,
-0x0c008640,0x06802489,0x0aa0c04b,0x07801a09,0x07801a49,0x06047b09,
-0x08047c00,0x0aa10009,0x08047d00,0x0c006dc0,0x00000000,0x0c008380,
-0x068024c9,0x06800149,0x02409209,0x06411708,0x096e3209,0x06011708,
-0x0c008380,0x06802509,0x07801808,0x07902509,0x02008248,0x07c02548,
-0x07802189,0x09446248,0x07802308,0x09501248,0x078022c8,0x09521248,
-0x07800d08,0x09542248,0x07800d48,0x09582248,0x07800d88,0x095c2248,
-0x07800dc8,0x09602248,0x07801948,0x09647248,0x07801988,0x09727248,
-0x06011109,0x06411009,0x09809389,0x06011009,0x078019c8,0x0aa3c008,
-0x0c007c00,0x06802589,0x0c007b80,0x068025c9,0x06411109,0x07801948,
-0x0780258a,0x02008288,0x09647248,0x07801988,0x078025ca,0x02008288,
-0x09727248,0x06011109,0x07801e88,0x0aa14008,0x06800009,0x06410c08,
-0x08010e81,0x093e1248,0x07c02609,0x0a620009,0x07801ec9,0x07c02649,
-0x07801f09,0x07c02689,0x07801f49,0x0c7802c0,0x07c026c9,0x06410c08,
-0x08010e81,0x093e1248,0x0a618009,0x07c02649,0x0c007380,0x06802689,
-0x0c007300,0x068026c9,0x07801e48,0x0aa34008,0x06800009,0x078022c8,
-0x0a61c008,0x07802308,0x0a614008,0x07802648,0x0aa0c008,0x0c780140,
-0x06800009,0x06410c08,0x08010e81,0x093e1248,0x07c02709,0x07801ac8,
-0x0a610008,0x07801e08,0x0a608008,0x0c780440,0x0c006bc0,0x06802749,
-0x0780274b,0x0aa3400b,0x0c006ac0,0x06800049,0x04001308,0x0680080a,
-0x0240a30a,0x0980c1cc,0x06410c08,0x06010e0c,0x03808288,0x07c00048,
-0x0aef004b,0x044012cb,0x07802008,0x0aa20008,0x0c006740,0x06800049,
-0x0aa14008,0x00000000,0x08010e88,0x0c7fff40,0x04401208,0x0c0137c0,
-0x00000000,0x0640ce09,0x0a238089,0x06420408,0x0a2fc048,0x00000000,
-0x09c08748,0x06020408,0x06460108,0x0a216008,0x00000000,0x06460408,
-0x0a2fc048,0x00000000,0x06460408,0x06060408,0x069fffc9,0x0640d408,
-0x09010208,0x0a8fe248,0x00000000,0x0640d208,0x0a240208,0x078034c8,
-0x0be30208,0x07802109,0x0a60c009,0x07802189,0x0aa20089,0x0640d209,
-0x0928c209,0x04001208,0x0968c248,0x0600d209,0x0c785bc0,0x0800c0ff,
-0x098080c8,0x07c034c8,0x0800c008,0x08007401,0x0c785a40,0x00000000,
-0x0aa0c148,0x0c784300,0x00000000,0x08010e81,0x06812008,0x06010e08,
-0x00000000,0x08010e00,0x07802148,0x0a60c008,0x06800008,0x07c02788,
-0x07802088,0x0aa58008,0x06800008,0x07c029c8,0x07c02a08,0x07c00e88,
-0x07c027c8,0x07c02808,0x07c02848,0x07c02888,0x07801ac9,0x0aa0c009,
-0x07800e08,0x07801bc8,0x07c028c8,0x07c02948,0x0aa0c009,0x07800e48,
-0x07801cc8,0x07c02908,0x07c02988,0x0c780280,0x068001df,0x07802108,
-0x07800e89,0x0a806248,0x06800827,0x0c017bc0,0x07802128,0x0c784f80,
-0x0800c0ff,0x07802148,0x0a61c008,0x00000000,0x068001df,0x078029c9,
-0x07802a08,0x09508248,0x07c02b49,0x078029c9,0x0a614049,0x07801e09,
-0x0aa0c009,0x00000000,0x0981f15f,0x078029c9,0x07802a08,0x0958c248,
-0x0978425f,0x06011609,0x0c000400,0x00000000,0x07800e88,0x09808788,
-0x098087c8,0x06012408,0x07800e88,0x0640d409,0x09010249,0x0aa0c009,
-0x0a8fd209,0x00000000,0x06a00008,0x06011408,0x0c785fc0,0x00000000,
-0x078028c9,0x07c02b09,0x07802a09,0x0780288a,0x0a40b289,0x0680000c,
-0x078029cb,0x0780284a,0x0a40728b,0x0680000c,0x0a614009,0x0680008c,
-0x0a60c00a,0x0680008c,0x068000cc,0x07802148,0x09441308,0x06460109,
-0x094a324c,0x06060109,0x06420109,0x0944324c,0x07802188,0x09402248,
-0x07800d48,0x04003208,0x09604248,0x07800d08,0x04003208,0x09684248,
-0x06020109,0x07800848,0x07800889,0x09610209,0x06020508,0x07802848,
-0x07802889,0x09610209,0x06020708,0x06060708,0x07802948,0x07802989,
-0x09610209,0x06020808,0x06060808,0x07800e08,0x04401208,0x07800e49,
-0x04401249,0x09610209,0x06020608,0x06800048,0x0541f208,0x06020408,
-0x06450a08,0x09005208,0x0a6f8008,0x06800008,0x07801ac9,0x0a60c009,
-0x06f00008,0x06d00008,0x06050a08,0x06450108,0x078008c9,0x09602209,
-0x07800909,0x09642209,0x06050108,0x07802848,0x07802889,0x0960a209,
-0x07801ac9,0x097e1209,0x06050608,0x0780294a,0x07802989,0x0960a289,
-0x0605070a,0x09c087c8,0x078029ca,0x07802a09,0x0960a289,0x0a403288,
-0x00000000,0x098087c8,0x06050808,0x07802a09,0x0780288a,0x0a404289,
-0x078029c9,0x0780284a,0x0a802289,0x0c780740,0x0640c908,0x0e000248,
-0x0640ca0a,0x00000000,0x0f000240,0x0200a24a,0x0606110a,0x0606150a,
-0x0606140a,0x04020208,0x07802a09,0x0e000248,0x0640cc0a,0x0640cb0c,
-0x0f000340,0x078027c8,0x0e000308,0x0200b34a,0x0402028b,0x00000000,
-0x0f000240,0x0200a24a,0x0606120a,0x0606160a,0x02409309,0x0200b24b,
-0x0606130b,0x0606170b,0x06460408,0x06060408,0x06800048,0x0541f208,
-0x06060408,0x07801ac8,0x06040508,0x07802948,0x07802989,0x09610209,
-0x06040308,0x07802848,0x07802889,0x09610209,0x06040408,0x07802148,
-0x0a638008,0x06804808,0x06043008,0x06443108,0x0900a248,0x0a6f0009,
-0x091e5248,0x0a6e8009,0x00000000,0x06440008,0x09808008,0x06040008,
-0x09c08008,0x06040008,0x08040701,0x07802148,0x0aa4c008,0x078029c8,
-0x0a614008,0x07801e09,0x0aa0c009,0x0c007b80,0x00000000,0x06411009,
-0x091c1249,0x0a6f8009,0x00000000,0x06411009,0x098093c9,0x06011009,
-0x06411009,0x091e1249,0x0a6f8009,0x0cc00000,0x00000000,0x06411009,
-0x091c1249,0x0a6f8009,0x00000000,0x07800e09,0x0ae0c049,0x0c007400,
-0x00000000,0x06411009,0x098093c9,0x06011009,0x08011c00,0x08011e00,
-0x06411009,0x091e1249,0x0a6f8009,0x0cc00000,0x00000000,0x0a60fc08,
-0x00000000,0x08010e90,0x0c7815c0,0x0800c0ff,0x0780080b,0x0c001600,
-0x06800049,0x06047e08,0x0aa1000b,0x0c0016c0,0x06800049,0x06047f08,
-0x08048000,0x0c0002c0,0x0780234a,0x06047c0c,0x0780218a,0x0a61400a,
-0x08048020,0x0c000140,0x0780238a,0x06047d0c,0x0cc00000,0x00000000,
-0x0400034a,0x06410c0e,0x0980d1cd,0x06010e0d,0x0680000c,0x0400034a,
-0x0aa1c00d,0x093e13ce,0x0580130c,0x097e130f,0x0540138e,0x0c7ffec0,
-0x0440134d,0x0680040d,0x0240d28d,0x0380c34c,0x0aa4000b,0x0400034a,
-0x06410c0e,0x0980d1cd,0x06010e0d,0x0400034a,0x0aa1c00d,0x093e13ce,
-0x0580130c,0x097e130f,0x0540138e,0x0c7ffec0,0x0440134d,0x0680040d,
-0x0240d28d,0x0380c34c,0x0400034c,0x0ae0c00a,0x0cc00000,0x00000000,
-0x0680000e,0x0680000f,0x0900140d,0x0aa1c010,0x0c000900,0x06800049,
-0x09408388,0x0c000840,0x06800049,0x094083c8,0x0920140d,0x0aa34010,
-0x0c000700,0x06800049,0x09508388,0x0c000640,0x06800049,0x0950a3c8,
-0x0c000580,0x06800049,0x09608388,0x0c0004c0,0x06800049,0x0964a3c8,
-0x0604810e,0x0604810f,0x0580134d,0x0c7ff880,0x0440128a,0x00800000,
-0x07800008,0x0c7e1a40,0x06030408,0x06806008,0x06010e08,0x06410f08,
-0x0befc0c8,0x09118208,0x0cc00000,0x07400248,0x0680e008,0x06010e08,
-0x06410f08,0x0befc0c8,0x09118208,0x0cc00000,0x07400248,0x06410509,
-0x06bfff89,0x06030409,0x00400000,0x0be0c108,0x0c7ffa40,0x00000000,
-0x08012104,0x07800e09,0x0ae0c049,0x06411c22,0x04000862,0x0a26891f,
-0x06011c21,0x0a21481f,0x0c005240,0x00000000,0x0a25411f,0x09c1f15f,
-0x07801e09,0x0aa48009,0x08011e00,0x0be42022,0x06a907c9,0x06012b09,
-0x00000000,0x00000000,0x06412b09,0x0c005180,0x00000000,0x06411009,
-0x098093c9,0x06011009,0x06411009,0x091e1249,0x0a6f8009,0x0c780840,
-0x00000000,0x0a27e022,0x06a907c9,0x06012b09,0x00000000,0x00000000,
-0x06412b09,0x0c010140,0x00000000,0x06411609,0x093e1249,0x0aa4c009,
-0x06800008,0x07c02788,0x06411109,0x07802548,0x09446248,0x06011109,
-0x06411009,0x09809389,0x06011009,0x06411e08,0x0be22008,0x068001df,
-0x0c07a600,0x0978479f,0x06420409,0x09c09749,0x0c780100,0x06020409,
-0x0c7feac0,0x0800c0ff,0x0601161e,0x07800e88,0x09808788,0x098087c8,
-0x06012408,0x07800e88,0x0640d409,0x09010249,0x0aa0c009,0x0a8fd209,
-0x00000000,0x06a00008,0x06011408,0x07801ac8,0x0aa0c008,0x0c00f8c0,
-0x00000000,0x09c1f09f,0x07800e88,0x04001208,0x07c00e88,0x07802788,
-0x04001208,0x07c02788,0x0a21409f,0x07802949,0x0b803248,0x00000000,
-0x09c1f05f,0x078029c8,0x0a618048,0x04001208,0x07801e09,0x0aa0c009,
-0x00000000,0x0981f15f,0x078028c9,0x0b815248,0x07c029c8,0x07802848,
-0x07c029c8,0x0981f09f,0x07800e88,0x07800e09,0x02008248,0x07802949,
-0x02408248,0x07c00e88,0x07802a08,0x04001208,0x07802909,0x0b807248,
-0x07c02a08,0x07801ac8,0x0aa0c008,0x0c7806c0,0x00000000,0x0981f0df,
-0x07802a08,0x04001208,0x07802909,0x0b80f248,0x078029c8,0x04001208,
-0x078028c9,0x0b80b248,0x07800e09,0x0b807248,0x07802a08,0x04001208,
-0x07800e49,0x0b803248,0x0c7800c0,0x09c1f11f,0x0981f11f,0x0981f0df,
-0x078029de,0x07802a08,0x0958c788,0x0978479f,0x0cb80020,0x00000000,
-0x06800048,0x07c02148,0x078027c8,0x07801b4c,0x0b41a308,0x06801bc9,
-0x02009209,0x0700024a,0x0780284b,0x0200b28b,0x07c0284b,0x07c029cb,
-0x0780288b,0x07c02a0b,0x04001208,0x0b808308,0x07c027c8,0x07800e09,
-0x07c028c9,0x0780284a,0x02409289,0x0c780ac0,0x07c02949,0x04001249,
-0x0700024a,0x07c0294a,0x078028cb,0x0200b28b,0x0c780900,0x07c028cb,
-0x07802808,0x07801b8c,0x0b802308,0x0c7ff600,0x06800008,0x07c027c8,
-0x07c029c8,0x07c02848,0x07801bc9,0x07c02949,0x07c028c9,0x07802808,
-0x06801cc9,0x02009209,0x0700024a,0x0780288b,0x0200b28b,0x07c0288b,
-0x07c02a0b,0x04001208,0x0b808308,0x07c02808,0x07800e49,0x07c02909,
-0x0780288a,0x02409289,0x0c780200,0x07c02989,0x04001249,0x0700024a,
-0x07c0298a,0x0780290b,0x0200b28b,0x07c0290b,0x07802888,0x07800e09,
-0x0e000248,0x00000000,0x00000000,0x07802849,0x0f000200,0x02008248,
-0x07c00e88,0x0c7fe780,0x04c177df,0x078029c9,0x0780284a,0x0400228a,
-0x0b407289,0x04402209,0x0440128a,0x078028c8,0x0b403289,0x04401208,
-0x04401208,0x0680c009,0x02009209,0x07400262,0x0a21009f,0x06800021,
-0x0c7fbf40,0x00000000,0x078029c8,0x0680c009,0x02009209,0x0c7fbe00,
-0x07000261,0x078029c9,0x0780284a,0x0400228a,0x0b407289,0x04402209,
-0x0440128a,0x078028c8,0x0b403289,0x04401208,0x04401208,0x0680c009,
-0x05801288,0x02009289,0x0700024a,0x0a20c048,0x0c7800c0,0x094082a2,
-0x095102a2,0x0740024a,0x0a21009f,0x06800021,0x0c7fb840,0x00000000,
-0x078029c8,0x0680c009,0x05801288,0x02009289,0x0700024a,0x0a20c048,
-0x0911084a,0x0900884a,0x0c7fb5c0,0x00000000,0x078029c9,0x0780284a,
-0x0400228a,0x0b407289,0x04402209,0x0440128a,0x078028c8,0x0b403289,
-0x04401208,0x04401208,0x0680c009,0x05802288,0x02009289,0x0700024a,
-0x09002208,0x0a60c008,0x0c780240,0x095842a2,0x0a60c048,0x0c780180,
-0x095042a2,0x0a60c088,0x0c7800c0,0x094842a2,0x094042a2,0x0740024a,
-0x0a21009f,0x06800021,0x0c7fae40,0x00000000,0x078029c8,0x0680c009,
-0x05802288,0x02009289,0x0700024a,0x09002208,0x0aa1c008,0x0918484a,
-0x0aa14048,0x0910484a,0x0aa0c088,0x0908484a,0x0900484a,0x0c7faa80,
-0x00000000,0x0c780080,0x06800021,0x0c7fa980,0x00000000,0x06412106,
-0x090c1186,0x0a6f8006,0x0c7dc300,0x00000000,0x06804009,0x06012d09,
-0x06800f8a,0x08012e00,0x00000000,0x0d07ff8a,0x00000000,0x0cc00000,
-0x00000000,0x06804009,0x06012c09,0x06809009,0x06012d09,0x06800f8a,
-0x06412e09,0x0d07ffca,0x06012e09,0x0cc00000,0x00000000,0x06809009,
-0x06012c09,0x06804009,0x06012d09,0x06800f8a,0x06412e09,0x0d07ffca,
-0x06012e09,0x06411109,0x07802548,0x09446248,0x06011109,0x0cc00000,
-0x00000000,0x07800e08,0x07801b49,0x0a608009,0x0c780880,0x0aa18049,
-0x0aa20089,0x0aa640c9,0x0a608109,0x0c7806c0,0x0c780000,0x05801288,
-0x0c780680,0x07c01bca,0x05802288,0x0540124a,0x02009289,0x0b0fe209,
-0x0400128a,0x0440224a,0x07c01bc9,0x05401289,0x0400128a,0x0540124a,
-0x02009289,0x05401208,0x0b003209,0x07801bc9,0x0440128a,0x0240a24a,
-0x0c780200,0x07c01c0a,0x0c000b40,0x06801bcc,0x0c780100,0x00000000,
-0x0c000dc0,0x06801bcc,0x07800e48,0x07801b89,0x0a608009,0x0c780880,
-0x0aa18049,0x0aa20089,0x0aa640c9,0x0a608109,0x0c7806c0,0x0c780000,
-0x05801288,0x0c780680,0x07c01cca,0x05802288,0x0540124a,0x02009289,
-0x0b0fe209,0x0400128a,0x0440224a,0x07c01cc9,0x05401289,0x0400128a,
-0x0540124a,0x02009289,0x05401208,0x0b003209,0x07801cc9,0x0440128a,
-0x0240a24a,0x0c780200,0x07c01d0a,0x0c000200,0x06801ccc,0x0cc00000,
-0x00000000,0x0c000480,0x06801ccc,0x0cc00000,0x00000000,0x05802348,
-0x0740030d,0x05801248,0x0240a349,0x0400130c,0x0740030a,0x054012c8,
-0x0200b20b,0x058022cb,0x0240a24b,0x0400130c,0x0740030a,0x0cc00000,
-0x00000000,0x05803288,0x0540224a,0x02009289,0x0b0fe209,0x0400128a,
-0x0440224a,0x07400309,0x054012c8,0x04000349,0x0540224a,0x02009289,
-0x0b0fe2c9,0x0400128a,0x0440224a,0x0240a349,0x0400130c,0x0740030a,
-0x054012c8,0x0200b20b,0x04000349,0x0540224a,0x02009289,0x0b0fe2c9,
-0x0400128a,0x0440224a,0x0240a349,0x0400130c,0x0740030a,0x054022c8,
-0x04000349,0x0540224a,0x02009289,0x0b0fe2c9,0x0400128a,0x0440224a,
-0x0240a349,0x0400130c,0x0740030a,0x0cc00000,0x00000000,0x0640c308,
-0x02008308,0x06035108,0x06800808,0x06035208,0x06800149,0x0680c00a,
-0x0700024b,0x0740028b,0x0b6105c9,0x04001249,0x0c7fff00,0x0400128a,
-0x06a0c008,0x06035008,0x06435008,0x0580f208,0x0bef8048,0x00000000,
-0x06435308,0x0900c208,0x0a6f8008,0x00000000,0x0cc00000,0x00000000,
-0x0640c408,0x02008308,0x06035108,0x06801008,0x06035208,0x06800609,
-0x0680c00a,0x0700024b,0x0740028b,0x0b611589,0x04001249,0x0c7fff00,
-0x0400128a,0x06a0c008,0x06035008,0x06435008,0x0580f208,0x0bef8048,
-0x00000000,0x06435308,0x0900c208,0x0a6f8008,0x00000000,0x0cc00000,
-0x00000000,0x0640c308,0x02008308,0x06035108,0x06800808,0x06035208,
-0x06b0c008,0x06035008,0x06435008,0x0580f208,0x0bef8048,0x00000000,
-0x06800149,0x0680c00a,0x0700028b,0x0740024b,0x0b6105c9,0x04001249,
-0x0c7fff00,0x0400128a,0x0cc00000,0x00000000,0x0640c408,0x02008308,
-0x06035108,0x06801008,0x06035208,0x06b0c008,0x06035008,0x06435008,
-0x0580f208,0x0bef8048,0x00000000,0x06800609,0x0680c00a,0x0700028b,
-0x0740024b,0x0b611589,0x04001249,0x0c7fff00,0x0400128a,0x0cc00000,
-0x00000000,0x0640c508,0x02008308,0x06035108,0x06801467,0x0c0092c0,
-0x06435128,0x06800c08,0x06035208,0x068015c9,0x0680c00a,0x0700024b,
-0x0740028b,0x0b612009,0x04001249,0x0c7fff00,0x0400128a,0x06a0c008,
-0x06035008,0x06435008,0x0580f208,0x0bef8048,0x00000000,0x06435308,
-0x0900c208,0x0a6f8008,0x00000000,0x07800f48,0x0aa20008,0x0540330c,
-0x07801608,0x0aa0c008,0x06800008,0x06900008,0x0c000100,0x0200c20c,
-0x0cc00000,0x00000000,0x0680000d,0x08070300,0x0680c00b,0x0680000a,
-0x06470408,0x06470409,0x09508209,0x074002c8,0x040012cb,0x0baeffca,
-0x0400128a,0x0aa3800d,0x00000000,0x06470508,0x07c0fe88,0x09210208,
-0x07c0fec8,0x06470608,0x07c0ff08,0x09210208,0x07c0ff48,0x06470708,
-0x07c0ff88,0x09210208,0x07c0ffc8,0x0640cd08,0x02008308,0x0540924d,
-0x02008248,0x06035108,0x06804008,0x06035208,0x06a0c008,0x06035008,
-0x06435008,0x0580f208,0x0bef8048,0x00000000,0x0ba0c04d,0x0cc00000,
-0x00000000,0x0c7ff640,0x0400134d,0x0640c508,0x02008308,0x06035108,
-0x06801427,0x0c007ec0,0x06435128,0x06800c08,0x06035208,0x06b0c008,
-0x06035008,0x06435008,0x0580f208,0x0bef8048,0x00000000,0x068015c9,
-0x0680c00a,0x0700028b,0x0740024b,0x0b612009,0x04001249,0x0c7fff00,
-0x0400128a,0x0c000e00,0x00000000,0x07800f48,0x0aa20008,0x0540330c,
-0x07801608,0x0aa0c008,0x06800008,0x06900008,0x0c000100,0x0200c20c,
-0x0cc00000,0x00000000,0x0680000d,0x08070200,0x0640cd08,0x02008308,
-0x0540924d,0x02008248,0x06035108,0x06804008,0x06035208,0x06b0c008,
-0x06035008,0x06435008,0x0580f208,0x0bef8048,0x00000000,0x0680c00b,
-0x0680000a,0x070002c8,0x040012cb,0x06070408,0x09108248,0x06070409,
-0x0baeffca,0x0400128a,0x0aa3800d,0x00000000,0x0780fe88,0x0780fec9,
-0x09610209,0x06070508,0x0780ff08,0x0780ff49,0x09610209,0x06070608,
-0x0780ff88,0x0780ffc9,0x09610209,0x06070708,0x0ba0c04d,0x0cc00000,
-0x00000000,0x0c7ff640,0x0400134d,0x07801708,0x07801889,0x09421209,
-0x07801849,0x09441209,0x07801a89,0x09461209,0x07800f09,0x09483209,
-0x07800ec9,0x094e3209,0x07800f89,0x09741209,0x078018c9,0x09761209,
-0x07800d49,0x0780190a,0x02409289,0x09782209,0x06011708,0x06412508,
-0x07801009,0x09401209,0x078010c9,0x09482209,0x07801109,0x094c2209,
-0x07801049,0x09504209,0x07801089,0x09584209,0x06800cc9,0x09706209,
-0x078008c9,0x09442209,0x0aa18009,0x0680018a,0x04401249,0x0340a24a,
-0x0960420a,0x09808048,0x07800909,0x097c2209,0x0aa18009,0x0680018a,
-0x04401249,0x0340a24a,0x0968420a,0x09808048,0x06012508,0x06470108,
-0x07800f49,0x09401209,0x09421209,0x09441209,0x07800d49,0x09482209,
-0x06070108,0x06470b08,0x078008c9,0x09402209,0x07800909,0x09482209,
-0x09502209,0x06070b08,0x06440808,0x078012c9,0x09401209,0x07801849,
-0x09421209,0x06040808,0x06440c08,0x078008c9,0x09402209,0x07800909,
-0x09442209,0x06040c08,0x0cc00000,0x00000000,0x0c003100,0x00000000,
-0x07802348,0x07c04408,0x07802388,0x07c04448,0x07802188,0x07c04488,
-0x07802288,0x07c044c8,0x07802148,0x07c04508,0x07802108,0x07c04548,
-0x07800848,0x07c045c8,0x07800888,0x07c04608,0x07800c88,0x07c04648,
-0x07800cc8,0x07c04688,0x07800948,0x07c046c8,0x07802208,0x07c04708,
-0x07802448,0x07c04748,0x07802488,0x07c04788,0x07801fc8,0x07c047c8,
-0x078024c8,0x07c04808,0x07800a88,0x07c04848,0x07802ac8,0x07c04888,
-0x07801ac8,0x07801b09,0x05401249,0x02c08248,0x07c048c8,0x07801b48,
-0x07c04908,0x07801b88,0x07c04948,0x07801bc8,0x07c04988,0x07801c08,
-0x07c049c8,0x07801c48,0x07c04a08,0x07801c88,0x07c04a48,0x07801cc8,
-0x07c04a88,0x07801d08,0x07c04ac8,0x07801d48,0x07c04b08,0x07801d88,
-0x07c04b48,0x07801f08,0x07c04bc8,0x07801f48,0x07c04c08,0x07802688,
-0x07c04c48,0x078026c8,0x07c04c88,0x07801948,0x07c04cc8,0x07801988,
-0x07c04d08,0x07802088,0x07c04d48,0x078014c8,0x07c04e08,0x07801508,
-0x07c04e48,0x07801548,0x07c04e88,0x07801588,0x07c04ec8,0x078008c8,
-0x07800909,0x09484209,0x07c04f08,0x06800009,0x07801148,0x0a20c048,
-0x07801008,0x09809009,0x0a20c048,0x07801dc8,0x09809049,0x0a20c048,
-0x07801e48,0x09809089,0x0a20c048,0x07801e88,0x098090c9,0x0a20c048,
-0x07801ec8,0x09809109,0x0a20c048,0x07802608,0x09809149,0x0a20c048,
-0x07802648,0x09809189,0x0a20c048,0x078022c8,0x098091c9,0x0a20c048,
-0x07802308,0x09809209,0x0a20c048,0x07802708,0x09809249,0x0a20c048,
-0x00000000,0x09809289,0x07c04b89,0x0680500a,0x06802b88,0x07000209,
-0x07400289,0x0400128a,0x0baf7348,0x04001208,0x0640c108,0x06035108,
-0x06802008,0x06035208,0x06a04008,0x06035008,0x06435008,0x0580f208,
-0x0bef8048,0x00000000,0x06435308,0x0900c208,0x0a6f8008,0x00000000,
-0x0cc00000,0x00000000,0x0800cf00,0x0800c0ff,0x06800009,0x0680ffca,
-0x07000248,0x09808408,0x0600cf08,0x00000000,0x0640cf08,0x0a6fc008,
-0x0b403289,0x0c7ffe40,0x04001249,0x0cc00000,0x00000000,0x0680000a,
-0x0680000b,0x06804008,0x07000209,0x0580f209,0x0be20048,0x0580e209,
-0x0a20c048,0x0400128a,0x040012cb,0x06804008,0x0bae040a,0x02008288,
-0x07c02a8b,0x0cc00000,0x00000000,0x06800009,0x07c02a89,0x068003ca,
-0x068043c8,0x07400209,0x0440128a,0x0aef800a,0x04401208,0x06a00009,
-0x07400209,0x0cc00000,0x00000000,0x06800048,0x07c02448,0x07c02288,
-0x0cc00000,0x00000000,0x0680580a,0x06802048,0x07000209,0x07400289,
-0x0400128a,0x0baf6748,0x04001208,0x0cc00000,0x00000000,0x06802b8d,
-0x06410c08,0x08010e81,0x093e1248,0x0aa10009,0x07c02ac9,0x0c0003c0,
-0x0780234c,0x0a62c00b,0x00000000,0x06410c08,0x08010e81,0x093e1248,
-0x0aa18009,0x07802ac9,0x09809049,0x07c02ac9,0x0c000100,0x0780238c,
-0x0cc00000,0x00000000,0x07802a88,0x0b21c088,0x06800049,0x0b214108,
-0x06800089,0x0b20c208,0x068000c9,0x06800109,0x0680080a,0x0240a24a,
-0x098091c9,0x06410c08,0x06010e09,0x03808288,0x07400348,0x0400134d,
-0x0aeec04c,0x0440130c,0x0cc00000,0x00000000,0x06460409,0x09001289,
-0x0aaf800a,0x00000000,0x0cc00000,0x00000000,0x078029c8,0x0680d009,
-0x02009209,0x0700024d,0x07802a08,0x0680ee09,0x02009209,0x0700024e,
-0x0680000f,0x0ac0338d,0x06ee000f,0x06ea000f,0x06050a0f,0x078029c8,
-0x0b615e08,0x0680d009,0x02009209,0x07802b4d,0x0740024d,0x07802a08,
-0x0b615108,0x0680ee09,0x02009209,0x07802b4e,0x0740024e,0x0cc00000,
-0x00000000,0x067f2f23,0x0befc063,0x0640c023,0x0a6f7fe3,0x00000000,
-0x06410b23,0x098230a3,0x06010b23,0x06412123,0x0a2fc063,0x00000000,
-0x06410c23,0x092039a3,0x07c04da6,0x093269a3,0x07c04de6,0x06410d23,
-0x06410b23,0x0600d326,0x0a61c8a6,0x00000000,0x0640ce24,0x0a2100a4,
-0x06440123,0x0a2fc063,0x00000000,0x08012101,0x0640d224,0x0a214064,
-0x00000000,0x0800c009,0x0c7ff840,0x08007401,0x0640d224,0x0be480a4,
-0x06803c25,0x078034e3,0x0aa3c826,0x0a25c063,0x0aa34866,0x0aa308a6,
-0x0a2500a3,0x0a24c123,0x0be24124,0x0be18223,0x0a20c224,0x0b218566,
-0x0c780380,0x0aa08526,0x0a6304e6,0x098230e3,0x07c034e3,0x0aa24826,
-0x06800065,0x0aa1c866,0x068000a5,0x0aa148a6,0x068000e5,0x0b20c566,
-0x06800125,0x06803c25,0x0ae1c566,0x0a61bc25,0x0640d224,0x0910c8e4,
-0x040018e3,0x0950c923,0x0600d224,0x068000a7,0x0c000180,0x04000a25,
-0x0600c025,0x08030504,0x0c7fedc0,0x00000000,0x0600d128,0x07803528,
-0x0aa18028,0x00000000,0x0600d027,0x08007401,0x0640d027,0x0a6fc027,
-0x00000000,0x0cc00000,0x00000000,0x0600d128,0x07803528,0x0aa54028,
-0x00000000,0x0640cf28,0x06035128,0x0680fc28,0x06035228,0x06a00028,
-0x06035028,0x06435028,0x0580fa28,0x0bef8068,0x00000000,0x06435328,
-0x0900ca28,0x0a6f8028,0x00000000,0x09827427,0x0600d027,0x08007401,
-0x0640d027,0x0a6fc027,0x0cc00000,0x00000000,0x07800848,0x07800889,
-0x09610209,0x06012308,0x06800208,0x07800d49,0x03408248,0x06040608,
-0x07800849,0x0780088a,0x0960f24a,0x06040209,0x07800e09,0x07800e4a,
-0x0960c24a,0x06040309,0x08040400,0x0cc00000,0x00000000,0x00000000,
-0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
-0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
-0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
-0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
-0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
-0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
+	0x6810001,0x6800000,0xd000001,0x7400040,0xc000900,0x0000000,0x6bffe40,0x7c00000,
+	0x6030400,0x0400000,0x800c0ff,0xc031700,0x0000000,0x0000000,0x0000000,0x0000000,
+	0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,0xc7ffd80,0x0000000,0x0000000,
+	0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,
+	0xc7a4fc0,0x0000000,0xc79fcc0,0x6412108,0xc780900,0x0000000,0xcc00000,0x0400000,
+	0x800c000,0x8002515,0x8002608,0x6bfbb80,0x6ffbfc0,0x6070500,0x6070600,0x6070700,
+	0x6803fc0,0x7c00140,0x7c007c0,0x7c01600,0x640d000,0x7c03580,0x640d200,0x7c03500,
+	0x640c108,0x6035108,0x6800408,0x6035208,0x6a04008,0x6035008,0x6435008,0x580f208,
+	0xbef8048,0x0000000,0x6435308,0x900c208,0xa6f8008,0x0000000,0xcc00000,0x0000000,
+	0x6bfff88,0x6030408,0x0400000,0x640c008,0xa618808,0x0000000,0xc02e580,0x0000000,
+	0xc79ecc0,0x800c0ff,0xaa0c048,0xc781c80,0x0000000,0x6410c08,0x8010e90,0x9326208,
+	0xaa0c808,0xc79ea80,0x800c0fe,0x7803548,0x9808008,0x7c03548,0x6410c08,0x8010e90,
+	0x9384288,0x9223248,0x7c00189,0x9201248,0x7c001c9,0x8010e90,0x7800148,0xa805288,
+	0x7c0010a,0xaa0ffc8,0xc026740,0x5407308,0x780010a,0x7c0014a,0x6410c08,0x8010e88,
+	0x9305248,0x7c00209,0x6410c08,0x8010e90,0x9210248,0x7c00249,0x6410c08,0x8010e90,
+	0x9210248,0x7c00289,0x6410c08,0x8010e84,0x9384248,0x7c04f49,0x8010e90,0x8010e90,
+	0x8010e8c,0x6410c08,0x8010e88,0x9308248,0x7c002c9,0x780018b,0xaa3800b,0x0000000,
+	0x6410c0a,0x8010e90,0xaa2800b,0x93e124a,0xaa08009,0xc780000,0x93c124a,0xaa08009,
+	0xc780000,0x540228a,0xc7ffe00,0x44012cb,0x6410c08,0x8010e81,0x93e1248,0x780018b,
+	0xa60c009,0x680000a,0x780018a,0xac0a2ca,0x0000000,0xc01da80,0x6800309,0xc01da00,
+	0x6800409,0xc01d980,0x6800509,0xc7ffe00,0x400128a,0x8010e86,0x6806008,0x6010e08,
+	0x6410f08,0xbefc0c8,0x9118208,0xaa08008,0xc780000,0x6410c08,0x8010e81,0x93e1248,
+	0xaa38009,0x8010e90,0x8010e90,0x8010e90,0x8010e90,0x6410c08,0x8010e81,0x93e1248,
+	0xaa0c009,0xc01d380,0x6800049,0xc01d300,0x6800049,0xaa04008,0x8010e81,0x7800148,
+	0xaa0ffc8,0xc025180,0x5407308,0xc79d000,0x800c0ff,0xaa0c088,0xc78bd40,0x0000000,
+	0x6410c08,0x8010e90,0x9326208,0xaa0c848,0xc79cdc0,0x800c0fe,0x7803548,0x9808048,
+	0x7c03548,0x6410c08,0x8010e88,0x9384288,0x7c0060a,0x9323248,0x7c00649,0x9301248,
+	0x7c00689,0x7800148,0xa808288,0x7c0010a,0xc024ac0,0x5407308,0x780010a,0x7c0014a,
+	0xc025640,0x540730a,0x6410c08,0x8010e88,0x9305248,0x7c006c9,0x6410c08,0x8010e90,
+	0x9210248,0x7c00709,0x6410c08,0x8010e90,0x9210248,0x7c00749,0x6410c08,0x8010e84,
+	0x8010e90,0x8010e90,0x8010e8c,0x6410c08,0x8010e88,0x9308248,0x7c00789,0x780064b,
+	0xaa3800b,0x0000000,0x6410c0a,0x8010e90,0xaa2800b,0x93e124a,0xaa08009,0xc780000,
+	0x93c124a,0xaa08009,0xc780000,0x540228a,0xc7ffe00,0x44012cb,0xc01c040,0x6800049,
+	0x78007c9,0xa805209,0x7c00108,0xaa0ffc9,0xc024500,0x5407309,0x7800108,0x7c007c8,
+	0xc01bdc0,0x6800809,0xc01bd40,0x6800849,0xc01bcc0,0x6800889,0x7800848,0x7800889,
+	0x9610209,0x6012308,0x6410c08,0x8010e81,0x93e1248,0xaa24009,0xc01ba40,0x6800049,
+	0xc01b9c0,0x6800049,0xc01b940,0x6800049,0xc01b8c0,0x6800049,0xc01b840,0x68008c9,
+	0xc01b7c0,0x6800909,0xc01b740,0x6800949,0x6410c08,0x8010e81,0x93e1248,0x780064b,
+	0xa60c009,0x680000a,0x780064a,0xac0a2ca,0x0000000,0xc01b480,0x6800989,0xc01b400,
+	0x6800a89,0xc01b380,0x6800b89,0xc7ffe00,0x400128a,0xc01b280,0x6800c89,0x7800c89,
+	0x7c00d09,0xc01b180,0x6800cc9,0x7800c89,0x7800cc8,0x2009209,0x7c00d49,0x7800d48,
+	0xa6300c8,0x7800849,0x403f249,0x5806249,0x7c00e09,0x7800889,0x403f249,0x5806249,
+	0x7c00e49,0x8040640,0xc780900,0x6823de0,0xa630088,0x7800849,0x401f249,0x5805249,
+	0x7c00e09,0x7800889,0x401f249,0x5805249,0x7c00e49,0x8040620,0xc780600,0x6824360,
+	0xa630048,0x7800849,0x400f249,0x5804249,0x7c00e09,0x7800889,0x400f249,0x5804249,
+	0x7c00e49,0x8040610,0xc780300,0x6824ba0,0x7800849,0x4007249,0x5803249,0x7c00e09,
+	0x7800889,0x4007249,0x5803249,0x7c00e49,0x8040608,0x68256e0,0x7800e08,0x7800e49,
+	0xe000248,0x0000000,0x0000000,0x6800009,0xf000200,0x4401208,0xaa10008,0x5801208,
+	0xc7fff80,0x4001249,0x7c01449,0x7800849,0x780088a,0x960f24a,0x6040209,0x7800e09,
+	0x7800e4a,0x960c24a,0x6040309,0x8040400,0xc019ec0,0x6800049,0x7800049,0x7c00d89,
+	0xc019dc0,0x6800089,0x7800049,0x7800088,0x2009209,0x7c00dc9,0xc019c40,0x6800ec9,
+	0xc019bc0,0x6800f09,0x6410c08,0x8010e81,0x93e1248,0xaa38009,0x7c00f49,0x6410c08,
+	0x8010e81,0x93e1248,0xaa0c009,0xc001a80,0x0000000,0x78007c8,0xaa0c008,0x68f000c,
+	0x69f000c,0xc0237c0,0x0000000,0x6410c08,0x8010e83,0x93e1248,0x7c00f89,0x93c1248,
+	0x7c00fc9,0x93a1248,0xaa58009,0x6800009,0x6410c08,0x8010e88,0x9384248,0x4001249,
+	0x7c01049,0x9304248,0x4001249,0x7c01089,0xc0192c0,0x68010c9,0xc019240,0x6801109,
+	0x78010c9,0x2008248,0x7c01108,0x6410c08,0x8010e81,0x93e1248,0x7c01149,0x6800049,
+	0x7c01009,0xc018f80,0x6801189,0x680000e,0x780118f,0x44013cf,0xaa1000f,0x58013cf,
+	0xc7fff80,0x400138e,0x7c011ce,0x780118f,0x680000e,0xb4143ce,0x0000000,0x480f20e,
+	0x5404208,0x680800d,0x200d20d,0xc002940,0x0000000,0x480f20e,0xaa1c3c8,0x0000000,
+	0x400120e,0xb4043c8,0x0000000,0xc780100,0x0000000,0xc0049c0,0x0000000,0xc7ffb80,
+	0x400138e,0x6410c08,0x8010e81,0x93e1248,0x7c01209,0xaa28009,0xc018640,0x6801249,
+	0xaa1c008,0x6410c08,0x8010e89,0x9308248,0x92e1248,0xc7ffec0,0x4401208,0x6410c08,
+	0x8010e83,0x93e1248,0x7c01289,0x93c1248,0x7c012c9,0x93a1248,0x6800008,0x7c014c8,
+	0x7c01508,0x7c01548,0x7c01588,0xaa0c009,0xc004b80,0x0000000,0x8010e81,0x78007c8,
+	0xaa0ffc8,0xc0205c0,0x5407308,0xc797e00,0x800c0ff,0x68c8408,0x6c41508,0x6070508,
+	0x6070608,0x6070708,0x680000b,0x680000a,0x6410c08,0x8010e81,0x93e1248,0xaa08009,
+	0xc780f00,0xc017b80,0x6800049,0xaa140cb,0x400e3ca,0xba0c0ca,0x680038f,0x68003cf,
+	0xa60c00b,0xc780180,0x647050d,0xa60c04b,0xc7800c0,0x647060d,0x647070d,0xaa38008,
+	0x400038f,0xaa300cb,0x680000e,0x240f20a,0xaa2410f,0x920438d,0xaa1c0cf,0x918438d,
+	0xaa1408f,0x910438d,0xaa0c04f,0x908438d,0x900438d,0xa61c0cb,0xa60c00a,0xc7800c0,
+	0x970434e,0x978434e,0xc780ec0,0x607070d,0xaa1c00a,0xaa2004a,0xaa2408a,0xaa280ca,
+	0xaa2c10a,0xc7802c0,0x968434e,0xc780240,0x940434e,0xc7801c0,0x948434e,0xc780140,
+	0x950434e,0xc7800c0,0x958434e,0x960434e,0xaa1000b,0xaa1404b,0xc7809c0,0x607070d,
+	0xc780940,0x607050d,0xc7808c0,0x607060d,0xba2c08b,0x680020c,0xc016e00,0x6800049,
+	0x4008308,0xaa0c08b,0x680f808,0x680f988,0x2008288,0x6070208,0x607040c,0xaa1c00b,
+	0x680e008,0xaa1404b,0x6800008,0xaa0c08b,0x6806008,0x680c008,0x680040e,0xaa1000b,
+	0x540424a,0x680100e,0x540624a,0x2008248,0x6070208,0x680004d,0xc016800,0x6800049,
+	0x200c20c,0x48ff30c,0x607040c,0xb8fb38d,0x400134d,0xba0c0cb,0x6800149,0x6800049,
+	0xb40324a,0xc7fe6c0,0x400128a,0xb60c0cb,0xc7fe5c0,0x40012cb,0xcc00000,0x0000000,
+	0xaa1400e,0x6800009,0x6410c08,0x8010e81,0x93e1248,0xa608009,0xc781540,0x7801189,
+	0xa40624e,0x440144e,0xc015f40,0x6800049,0xc002500,0x2411211,0x480f451,0x5404451,
+	0x6808008,0x2011211,0x6800010,0x6800012,0x6410c08,0x8010e81,0x93e1288,0xc015c00,
+	0x6800049,0xaa1000a,0x40014c8,0x6800009,0x24134c9,0xb60c412,0x6a0000b,0x700044b,
+	0x4001451,0x4001492,0x200c2d3,0x91e12cb,0x900e30c,0x6410c08,0x8010e81,0x93e1288,
+	0x95c130a,0xa62000a,0x6410c08,0x8010e81,0x93e1288,0xa61000a,0xa62400b,0xc7ffb80,
+	0x0000000,0x740034c,0x400134d,0x4001410,0xa60c00b,0xc7ffa00,0x0000000,0xb60c410,
+	0x6a00008,0x7400348,0xae08050,0xc780780,0x440134d,0x7000351,0x900e451,0x91a1491,
+	0x6900013,0xaa0c012,0x2012453,0x2412453,0x680004c,0xb41240c,0x241130d,0x7000451,
+	0x900e451,0x91a12d1,0x6900013,0xaa0c00b,0x200b453,0x240b453,0xb4072d2,0x241130d,
+	0x400048b,0x700044b,0x7000353,0x740034b,0x7400453,0xc7ffc00,0x400130c,0xc7ff8c0,
+	0x4401410,0xcc00000,0x0000000,0xc014b00,0x6800049,0xc014a80,0x6800089,0x6800010,
+	0x680000a,0x680000b,0x780004c,0xb41130b,0xc0148c0,0x68000c9,0x240a20a,0x440128a,
+	0x6410c08,0x8010e81,0x93e1248,0x900e20a,0x95c1209,0x7400348,0x400134d,0x4001410,
+	0xbacc410,0x40012cb,0xcc00000,0x0000000,0x680000a,0x680000b,0x780008c,0xb41130b,
+	0xc0143c0,0x68000c9,0x200a20a,0x400128a,0x6410c08,0x8010e81,0x93e1248,0x900e20a,
+	0x95c1209,0x7400348,0x400134d,0x4001410,0xbacc410,0x40012cb,0xcc00000,0x0000000,
+	0x6a00008,0x7400348,0xcc00000,0x0000000,0x580424e,0x7c01489,0x5409249,0x640c208,
+	0x2008248,0x6035108,0x6808008,0x6035208,0x6a08008,0x6035008,0x6435008,0x580f208,
+	0xbef8048,0x0000000,0x6435308,0x900c208,0xa6f8008,0x0000000,0xcc00000,0x0000000,
+	0x5804251,0x7801488,0xa80e209,0x7c01489,0x5409249,0x640c208,0x2008248,0x6035108,
+	0x6808008,0x6035208,0x6b08008,0x6035008,0x6435008,0x580f208,0xbef8048,0x0000000,
+	0xcc00000,0x0000000,0x6410c08,0x8010e81,0x93e1248,0xaa34009,0x0000000,0x6410c08,
+	0x8010e88,0x9308248,0x7c01309,0xa61ffc9,0x6410c08,0x8010e90,0x9210248,0x6410c08,
+	0x8010e90,0x9210248,0x6410c08,0x8010e81,0x93e1248,0xaa0c009,0x93c1248,0x8010e81,
+	0x6410c08,0x8010e81,0x93e1248,0xaa24009,0x6410c08,0x8010e85,0x9361248,0xaa14009,
+	0x0000000,0x8010e88,0x0000000,0x8010e90,0x6410c08,0x8010e81,0x93e1248,0xaa14009,
+	0xc012bc0,0x6800089,0xc012b40,0x6800089,0x6410c08,0x8010e84,0x93e1248,0x93c1248,
+	0x93a1248,0x7c015c9,0x9381248,0xaa38009,0x6410c08,0x9118208,0xa60c008,0xcc00000,
+	0x0000000,0xc012780,0x6801349,0xc012700,0x6801389,0xc012680,0x68013c9,0xc012600,
+	0x6801409,0x6410c08,0x8010e81,0x93e1248,0xaa10009,0x6410c08,0x9018208,0xa608008,
+	0xc7807c0,0x6410c08,0x8010e90,0x9210248,0x7c014c9,0x6410c08,0x8010e90,0x9210248,
+	0x7c01509,0x6410c08,0x8010e90,0x9210248,0x7c01549,0x6410c08,0x8010e90,0x9210248,
+	0x7c01589,0x6410c08,0x8010e81,0x93e1248,0xaa10009,0xc011e80,0x6800049,0x4001208,
+	0x6410c08,0x8010e81,0x93e1248,0xaa10009,0x680004a,0xc000100,0x780064b,0xcc00000,
+	0x0000000,0xa60c00a,0xc7807c0,0x0000000,0x6410c08,0x8010e82,0x93c2248,0xaaec009,
+	0x6410c08,0x8010e81,0x93e1308,0xaa2400c,0x6410c08,0x8010e88,0x9308248,0x6410c08,
+	0x8010e8b,0x9365248,0x9341248,0x92a5248,0x6410c08,0x8010e88,0x9384248,0x9304248,
+	0xaa1000c,0x6410c08,0x8010e84,0x9384248,0x6410c08,0x8010e8f,0x9365248,0x92c5248,
+	0x9225248,0xcc00000,0x0000000,0xaa0c0c8,0xc783180,0x0000000,0x6410c08,0x8010e90,
+	0x9326208,0xaa0c888,0xc791040,0x800c0fe,0x7803548,0x9808088,0x7c03548,0xc011000,
+	0x6800049,0x7801609,0xa805209,0x7c00108,0xaa0ffc9,0xc01a580,0x5407309,0x7800108,
+	0x7c01608,0xc010d80,0x6801649,0x78007ca,0xa806288,0x7c00108,0x780010a,0x7c007ca,
+	0xc019d80,0x540730a,0x780060a,0x7800148,0xa804288,0x7c0014a,0xc0196c0,0x540730a,
+	0x6410c08,0x8010e87,0x93e1248,0x7c01689,0x93c1248,0x7c016c9,0x9363248,0x7c01709,
+	0x9341248,0x7c01749,0x9321248,0x7c01789,0xc0106c0,0x68017c9,0x4001208,0x7c017c8,
+	0xc0105c0,0x6801809,0x4001208,0x7c01808,0xc010680,0x6801849,0x401a208,0x7c01848,
+	0x6410c08,0x8010e83,0x93e1248,0x7c01889,0x93c1248,0x7c018c9,0x93a1248,0x7c01909,
+	0xaa10009,0x6800008,0xc010140,0x6801949,0x7c01948,0xc010240,0x6801989,0xc0101c0,
+	0x68019c9,0x6410c08,0x8010e86,0x93e1248,0x7c01a09,0x93c1248,0x7c01a49,0x93a1248,
+	0x7c01a89,0x9381248,0x7c01ac9,0x9361248,0x7c01b09,0x9341248,0x7c01e89,0xaa0c009,
+	0xc015300,0x0000000,0x6800048,0x7c01e48,0x7801b08,0xa608008,0xc780a80,0xc00fa00,
+	0x6801bc9,0x7800e08,0x7c01c48,0xc00f900,0x6801c09,0x7800e48,0x7c01d48,0x6410c08,
+	0x8010e81,0x93e1248,0x7c01b89,0xaa14009,0xc015640,0x0000000,0xc780580,0x0000000,
+	0x7801bcb,0xae0010b,0x680000a,0xb4072ca,0xc00f4c0,0x407124a,0x4001208,0x7400248,
+	0xc7ffec0,0x400128a,0x7801c0b,0xae0010b,0x680000a,0xb4072ca,0xc00f240,0x407524a,
+	0x4001208,0x7400248,0xc7ffec0,0x400128a,0x6410c08,0x8010e81,0x93e1248,0x7c01e49,
+	0x6410c08,0x8010e82,0x93e1248,0x7c01ec9,0x93c1248,0xa618009,0x7c01f09,0x7c01f49,
+	0x7c01f89,0xc780340,0x7c01fc9,0x6410c08,0x8010e82,0x93e1248,0x7c01f09,0x93c1248,
+	0xa618009,0x7c01f49,0xc00ed00,0x6801f89,0xc00ec80,0x6801fc9,0x6410c08,0x8010e81,
+	0x93e1248,0xa628009,0x7800f48,0xaa28008,0x7801648,0xaa0c008,0x68f000c,0x69f000c,
+	0xc019b80,0x0000000,0xc7800c0,0xc076880,0x0000000,0x6410c08,0x8010e81,0x93e1248,
+	0x7c02009,0xc00e580,0x6802049,0x4002208,0x7c02048,0x6410c08,0x8010e81,0x93e1248,
+	0x7c02089,0x8010e81,0xc01a1c0,0x0000000,0x7801608,0xaa0ffc8,0xc017940,0x5407308,
+	0xc78e0c0,0x800c0ff,0x680400d,0xaa0c1c8,0xc780d80,0x0000000,0x8010e90,0x6803fcb,
+	0x6800009,0x6410c08,0x8010e88,0x9308208,0x2009209,0xa8fc2c8,0x680000a,0x6410c08,
+	0x8010e88,0x9308208,0x200a20a,0xa8fc2c8,0x0000000,0x6801027,0xc020f80,0x4000a09,
+	0x6801067,0xc020ec0,0x4000a0a,0x440134d,0xaa0800d,0xa60800a,0xc780680,0xaa2c049,
+	0x0000000,0xaa9800a,0x0000000,0x6410c08,0x8010e88,0x6801127,0xc020b80,0x4000a08,
+	0xc7ffe40,0x440128a,0x78015c9,0xa22c049,0x0000000,0x6410c08,0x8010e87,0x9327208,
+	0x7c04f88,0x68010a7,0xc020880,0x4000a08,0x8010e81,0x440128a,0xc7ffac0,0x0000000,
+	0xc78d2c0,0x800c0ff,0xaa0c108,0xc787600,0x0000000,0x69fff89,0x640d408,0x9010208,
+	0xa8fe248,0x0000000,0x6410c08,0x8010e90,0x9326208,0xb210548,0x7c020c8,0xc78cf00,
+	0x800c0fe,0x6410c08,0x8010e81,0x93e1248,0x7c02109,0x78020c8,0xba1c408,0x6800009,
+	0xae14548,0x6800009,0x6410c08,0x8010e81,0x93e1248,0x7c02149,0xc00cc40,0x6800049,
+	0x7801609,0xa812248,0x7c00108,0xa633fc9,0x0000000,0xc015700,0x680000c,0xc015bc0,
+	0x680000c,0xc017d40,0x0000000,0x680000c,0x7c00e8c,0xc0204c0,0x0000000,0x7800108,
+	0x7c01608,0xc017280,0x5407308,0x7801648,0x78007c9,0xa806248,0x7c00108,0x7800109,
+	0x7c007c9,0xc015740,0x5407309,0x780060a,0x7800148,0xa804288,0x7c0014a,0xc015080,
+	0x540730a,0x7802108,0x6800009,0xaa10008,0x7c021c9,0xc780440,0x7c02189,0x7801688,
+	0xaa14008,0x6800009,0x6410c08,0x8010e81,0x93e1248,0x7c021c9,0x7801449,0x6410c08,
+	0x680080a,0x240a24a,0x98091c9,0x6010e09,0x3808288,0x7c02188,0x78021c8,0xaa0c008,
+	0xc784d00,0x0000000,0xc01bf40,0x0000000,0x7801708,0xaa0c008,0x98081c8,0x6010e08,
+	0xc00bbc0,0x6802209,0x78016c8,0xaa14008,0x6800049,0x6410c08,0x8010e81,0x93e1248,
+	0x7c02249,0x78020c9,0xaa084c9,0xa610509,0x6800008,0xc7818c0,0x7c02288,0x6410c08,
+	0x7800949,0x4004249,0x680080a,0x240a24a,0x98091c9,0x6010e09,0x3808288,0x7c02288,
+	0x6410c08,0x8010e81,0x93e1248,0xa614009,0x680400d,0xc0752c0,0x780118e,0xc780600,
+	0x78011c9,0x6410c08,0x68007ca,0x240a24a,0x98091c9,0x6010e09,0x3808288,0x5801208,
+	0x7c022c8,0xc0777c0,0x4000448,0x480f211,0x5404208,0x6808009,0x2009209,0x680400d,
+	0x6800008,0x700024a,0x740034a,0x400134d,0x4001208,0xbaf0408,0x4001249,0x7801208,
+	0xa608008,0xc780b80,0x780124a,0xaa1400a,0x680000b,0xc00ac80,0x6800049,0x40002c8,
+	0xc00abc0,0x6800049,0x200c20b,0xa60800c,0xc7808c0,0xac0f2cc,0x7801248,0xba60048,
+	0x7801248,0xb21c088,0x6802049,0xb214108,0x6802089,0xb20c208,0x68020c9,0x6802109,
+	0x6410c08,0x6010e09,0xc780340,0x0000000,0x6410c08,0x7800949,0x4004249,0x680080a,
+	0x240a24a,0x98091c9,0x6010e09,0x3808288,0x6410c08,0x8010e81,0x93e1248,0x6410c08,
+	0x8010e81,0x93e1248,0xaa0c009,0xc00a300,0x6800049,0xc7ff780,0x440130c,0xc019d00,
+	0x0000000,0x7801288,0xaa14008,0x6800009,0x6410c08,0x8010e81,0x93e1248,0x7c02309,
+	0x7800fc8,0xa610008,0x7c02348,0xc780200,0x7c02388,0x6410c08,0x8010e82,0x93e1248,
+	0x7c02349,0x93c1248,0x7c02389,0x780220b,0xa60c08b,0xc781700,0x0000000,0x641170a,
+	0x6410c08,0x8010e81,0x93e1248,0xa628009,0x78017c9,0x9546289,0x7c023c9,0xa60c00b,
+	0x6800009,0x7801809,0x9606289,0xc7803c0,0x7c02409,0xc009880,0x68023c9,0x78023c9,
+	0x4001249,0x9546289,0x7c023c9,0xaa1c04b,0xc0096c0,0x6802409,0x7802409,0x4001249,
+	0x9606289,0x7c02409,0x601170a,0x6800009,0x7c02b49,0x7802009,0xaa14009,0x7802b09,
+	0xb20c049,0xc019900,0x0000000,0xa61400b,0x6800009,0x6410c08,0x8010e81,0x93e1248,
+	0x641170a,0x96c1289,0x601170a,0x7c02449,0x7801789,0xaa14009,0x6800009,0x6410c08,
+	0x8010e81,0x93e1248,0x7c02489,0x6411008,0x9581209,0x6011008,0x7802309,0xaa48009,
+	0xa61400b,0x6800049,0x6410c08,0x8010e81,0x93e1248,0x7c024c9,0xaa1808b,0xaa0c009,
+	0x6802409,0x68023c9,0x7000249,0xae10049,0x6800009,0xc780100,0x7c02509,0xc008a00,
+	0x6802509,0xaa0c04b,0x7801a49,0x7801a89,0x6047b09,0x8047c00,0xaa10009,0x8047d00,
+	0xc007180,0x0000000,0xc008740,0x6802549,0x6800149,0x2409209,0x6411708,0x96e3209,
+	0x6011708,0xc008740,0x6802589,0x7801848,0x7902589,0x2008248,0x7c025c8,0x7802209,
+	0x9446248,0x7802388,0x9501248,0x7802348,0x9521248,0x7800d08,0x9542248,0x7800d48,
+	0x9582248,0x7800d88,0x95c2248,0x7800dc8,0x9602248,0x7801988,0x9647248,0x78019c8,
+	0x9727248,0x6011109,0x6411009,0x9809389,0x6011009,0x7801a08,0xaa3c008,0xc007fc0,
+	0x6802609,0xc007f40,0x6802649,0x6411109,0x7801988,0x780260a,0x2008288,0x9647248,
+	0x78019c8,0x780264a,0x2008288,0x9727248,0x6011109,0x7801f08,0xaa14008,0x6800009,
+	0x6410c08,0x8010e81,0x93e1248,0x7c02689,0xa620009,0x7801f49,0x7c026c9,0x7801f89,
+	0x7c02709,0x7801fc9,0xc7802c0,0x7c02749,0x6410c08,0x8010e81,0x93e1248,0xa618009,
+	0x7c026c9,0xc007740,0x6802709,0xc0076c0,0x6802749,0x7801ec8,0xaa34008,0x6800009,
+	0x7802348,0xa61c008,0x7802388,0xa614008,0x78026c8,0xaa0c008,0xc780140,0x6800009,
+	0x6410c08,0x8010e81,0x93e1248,0x7c02789,0x7801b08,0xa610008,0x7801e88,0xa608008,
+	0xc780440,0xc006f80,0x68027c9,0x78027cb,0xaa3400b,0xc006e80,0x6800049,0x4001308,
+	0x680080a,0x240a30a,0x980c1cc,0x6410c08,0x6010e0c,0x3808288,0x7c00048,0xaef004b,
+	0x44012cb,0x7802088,0xaa20008,0xc006b00,0x6800049,0xaa14008,0x0000000,0x8010e88,
+	0xc7fff40,0x4401208,0xc013b80,0x0000000,0x640ce09,0xa238089,0x6420408,0xa2fc048,
+	0x0000000,0x9c08748,0x6020408,0x6460108,0xa216008,0x0000000,0x6460408,0xa2fc048,
+	0x0000000,0x6460408,0x6060408,0x7802108,0xaa14008,0x0000000,0x6460408,0x9808708,
+	0x6060408,0x69fffc9,0x640d408,0x9010208,0xa8fe248,0x0000000,0x640d208,0xa240208,
+	0x7803548,0xbe30208,0x7802189,0xa60c009,0x7802209,0xaa20089,0x640d209,0x928c209,
+	0x4001208,0x968c248,0x600d209,0xc785e00,0x800c0ff,0x98080c8,0x7c03548,0x800c008,
+	0x8007401,0xc785c80,0x0000000,0xaa0c148,0xc784540,0x0000000,0x8010e81,0x6812008,
+	0x6010e08,0x0000000,0x8010e00,0x78021c8,0xa60c008,0x6800008,0x7c02808,0x7802108,
+	0xaa58008,0x6800008,0x7c02a48,0x7c02a88,0x7c00e88,0x7c02848,0x7c02888,0x7c028c8,
+	0x7c02908,0x7801b09,0xaa0c009,0x7800e08,0x7801c48,0x7c02948,0x7c029c8,0xaa0c009,
+	0x7800e48,0x7801d48,0x7c02988,0x7c02a08,0xc780280,0x68001df,0x7802188,0x7800e89,
+	0xa806248,0x6800827,0xc018680,0x78021a8,0xc7851c0,0x800c0ff,0x78021c8,0xa61c008,
+	0x0000000,0x68001df,0x7802a49,0x7802a88,0x9508248,0x7c02bc9,0x7802a49,0xa614049,
+	0x7801e89,0xaa0c009,0x0000000,0x981f15f,0x7802a49,0x7802a88,0x958c248,0x978425f,
+	0x6011609,0xc000400,0x0000000,0x7800e88,0x9808788,0x98087c8,0x6012408,0x7800e88,
+	0x640d409,0x9010249,0xaa0c009,0xa8fd209,0x0000000,0x6a00008,0x6011408,0xc786200,
+	0x0000000,0x7802949,0x7c02b89,0x7802a89,0x780290a,0xa40b289,0x680000c,0x7802a4b,
+	0x78028ca,0xa40728b,0x680000c,0xa614009,0x680008c,0xa60c00a,0x680008c,0x68000cc,
+	0x78021c8,0x9441308,0x6460109,0x94a324c,0x6060109,0x6420109,0x944324c,0x7802208,
+	0x9402248,0x7800d48,0x4003208,0x9604248,0x7800d08,0x4003208,0x9684248,0x6020109,
+	0x7800848,0x7800889,0x9610209,0x6020508,0x78028c8,0x7802909,0x9610209,0x6020708,
+	0x6060708,0x78029c8,0x7802a09,0x9610209,0x6020808,0x6060808,0x7800e08,0x4401208,
+	0x7800e49,0x4401249,0x9610209,0x6020608,0x6800048,0x541f208,0x6020408,0x6450a08,
+	0x9005208,0xa6f8008,0x6800008,0x7801b09,0xa60c009,0x6f00008,0x6d00008,0x6050a08,
+	0x6450108,0x78008c9,0x9602209,0x7800909,0x9642209,0x6050108,0x78028c8,0x7802909,
+	0x960a209,0x7801b09,0x97e1209,0x6050608,0x78029ca,0x7802a09,0x960a289,0x605070a,
+	0x9c087c8,0x7802a4a,0x7802a89,0x960a289,0xa40c288,0x0000000,0x98087c8,0x78028c9,
+	0x780290a,0x960a24a,0xa618009,0x0000000,0x6450009,0x9809009,0x9809049,0x6050009,
+	0x6050808,0x7802a89,0x780290a,0xa404289,0x7802a49,0x78028ca,0xa802289,0xc780740,
+	0x640c908,0xe000248,0x640ca0a,0x0000000,0xf000240,0x200a24a,0x606110a,0x606150a,
+	0x606140a,0x4020208,0x7802a89,0xe000248,0x640cc0a,0x640cb0c,0xf000340,0x7802848,
+	0xe000308,0x200b34a,0x402028b,0x0000000,0xf000240,0x200a24a,0x606120a,0x606160a,
+	0x2409309,0x200b24b,0x606130b,0x606170b,0x6460408,0x6060408,0x6800048,0x541f208,
+	0x6060408,0x7801b08,0x6040508,0x78029c8,0x7802a09,0x9610209,0x6040308,0x78028c8,
+	0x7802909,0x9610209,0x6040408,0x78021c8,0xa638008,0x6804808,0x6043008,0x6443108,
+	0x900a248,0xa6f0009,0x91e5248,0xa6e8009,0x0000000,0x6440008,0x9808008,0x6040008,
+	0x9c08008,0x6040008,0x8040701,0x78021c8,0xaa4c008,0x7802a48,0xa614008,0x7801e89,
+	0xaa0c009,0xc007b80,0x0000000,0x6411009,0x91c1249,0xa6f8009,0x0000000,0x6411009,
+	0x98093c9,0x6011009,0x6411009,0x91e1249,0xa6f8009,0xcc00000,0x0000000,0x6411009,
+	0x91c1249,0xa6f8009,0x0000000,0x7800e09,0xae0c049,0xc007400,0x0000000,0x6411009,
+	0x98093c9,0x6011009,0x8011c00,0x8011e00,0x6411009,0x91e1249,0xa6f8009,0xcc00000,
+	0x0000000,0xa60fc08,0x0000000,0x8010e90,0xc7815c0,0x800c0ff,0x780080b,0xc001600,
+	0x6800049,0x6047e08,0xaa1000b,0xc0016c0,0x6800049,0x6047f08,0x8048000,0xc0002c0,
+	0x78023ca,0x6047c0c,0x780220a,0xa61400a,0x8048020,0xc000140,0x780240a,0x6047d0c,
+	0xcc00000,0x0000000,0x400034a,0x6410c0e,0x980d1cd,0x6010e0d,0x680000c,0x400034a,
+	0xaa1c00d,0x93e13ce,0x580130c,0x97e130f,0x540138e,0xc7ffec0,0x440134d,0x680040d,
+	0x240d28d,0x380c34c,0xaa4000b,0x400034a,0x6410c0e,0x980d1cd,0x6010e0d,0x400034a,
+	0xaa1c00d,0x93e13ce,0x580130c,0x97e130f,0x540138e,0xc7ffec0,0x440134d,0x680040d,
+	0x240d28d,0x380c34c,0x400034c,0xae0c00a,0xcc00000,0x0000000,0x680000e,0x680000f,
+	0x900140d,0xaa1c010,0xc000900,0x6800049,0x9408388,0xc000840,0x6800049,0x94083c8,
+	0x920140d,0xaa34010,0xc000700,0x6800049,0x9508388,0xc000640,0x6800049,0x950a3c8,
+	0xc000580,0x6800049,0x9608388,0xc0004c0,0x6800049,0x964a3c8,0x604810e,0x604810f,
+	0x580134d,0xc7ff880,0x440128a,0x0800000,0x7800008,0xc7e0840,0x6030408,0x6806008,
+	0x6010e08,0x6410f08,0xbefc0c8,0x9118208,0xcc00000,0x7400248,0x680e008,0x6010e08,
+	0x6410f08,0xbefc0c8,0x9118208,0xcc00000,0x7400248,0x6410509,0x6bfff89,0x6030409,
+	0x0400000,0xbe0c108,0xc7ffa40,0x0000000,0x8012104,0x7800e09,0xae0c049,0x6411c22,
+	0x4000862,0xa26891f,0x6011c21,0xa21481f,0xc005240,0x0000000,0xa25411f,0x9c1f15f,
+	0x7801e89,0xaa48009,0x8011e00,0xbe42022,0x6a907c9,0x6012b09,0x0000000,0x0000000,
+	0x6412b09,0xc005180,0x0000000,0x6411009,0x98093c9,0x6011009,0x6411009,0x91e1249,
+	0xa6f8009,0xc780840,0x0000000,0xa2fa022,0x6a907c9,0x6012b09,0x0000000,0x0000000,
+	0x6412b09,0xc010140,0x0000000,0x6411609,0x93e1249,0xaa4c009,0x6800008,0x7c02808,
+	0x6411109,0x78025c8,0x9446248,0x6011109,0x6411009,0x9809389,0x6011009,0x6411e08,
+	0xbe22008,0x68001df,0xc07a3c0,0x978479f,0x6420409,0x9c09749,0xc780100,0x6020409,
+	0xc7feac0,0x800c0ff,0x601161e,0x7800e88,0x9808788,0x98087c8,0x6012408,0x7800e88,
+	0x640d409,0x9010249,0xaa0c009,0xa8fd209,0x0000000,0x6a00008,0x6011408,0x7801b08,
+	0xaa0c008,0xc00f8c0,0x0000000,0x9c1f09f,0x7800e88,0x4001208,0x7c00e88,0x7802808,
+	0x4001208,0x7c02808,0xa21409f,0x78029c9,0xb803248,0x0000000,0x9c1f05f,0x7802a48,
+	0xa618048,0x4001208,0x7801e89,0xaa0c009,0x0000000,0x981f15f,0x7802949,0xb815248,
+	0x7c02a48,0x78028c8,0x7c02a48,0x981f09f,0x7800e88,0x7800e09,0x2008248,0x78029c9,
+	0x2408248,0x7c00e88,0x7802a88,0x4001208,0x7802989,0xb807248,0x7c02a88,0x7801b08,
+	0xaa0c008,0xc7806c0,0x0000000,0x981f0df,0x7802a88,0x4001208,0x7802989,0xb80f248,
+	0x7802a48,0x4001208,0x7802949,0xb80b248,0x7800e09,0xb807248,0x7802a88,0x4001208,
+	0x7800e49,0xb803248,0xc7800c0,0x9c1f11f,0x981f11f,0x981f0df,0x7802a5e,0x7802a88,
+	0x958c788,0x978479f,0xcb80020,0x0000000,0x6800048,0x7c021c8,0x7802848,0x7801bcc,
+	0xb41a308,0x6801c49,0x2009209,0x700024a,0x78028cb,0x200b28b,0x7c028cb,0x7c02a4b,
+	0x780290b,0x7c02a8b,0x4001208,0xb808308,0x7c02848,0x7800e09,0x7c02949,0x78028ca,
+	0x2409289,0xc780ac0,0x7c029c9,0x4001249,0x700024a,0x7c029ca,0x780294b,0x200b28b,
+	0xc780900,0x7c0294b,0x7802888,0x7801c0c,0xb802308,0xc7ff600,0x6800008,0x7c02848,
+	0x7c02a48,0x7c028c8,0x7801c49,0x7c029c9,0x7c02949,0x7802888,0x6801d49,0x2009209,
+	0x700024a,0x780290b,0x200b28b,0x7c0290b,0x7c02a8b,0x4001208,0xb808308,0x7c02888,
+	0x7800e49,0x7c02989,0x780290a,0x2409289,0xc780200,0x7c02a09,0x4001249,0x700024a,
+	0x7c02a0a,0x780298b,0x200b28b,0x7c0298b,0x7802908,0x7800e09,0xe000248,0x0000000,
+	0x0000000,0x78028c9,0xf000200,0x2008248,0x7c00e88,0xc7fe780,0x4c177df,0x7802a49,
+	0x78028ca,0x400228a,0xb407289,0x4402209,0x440128a,0x7802948,0xb403289,0x4401208,
+	0x4401208,0x680c009,0x2009209,0x7400262,0xa21009f,0x6800021,0xc7fbf40,0x0000000,
+	0x7802a48,0x680c009,0x2009209,0xc7fbe00,0x7000261,0x7802a49,0x78028ca,0x400228a,
+	0xb407289,0x4402209,0x440128a,0x7802948,0xb403289,0x4401208,0x4401208,0x680c009,
+	0x5801288,0x2009289,0x700024a,0xa20c048,0xc7800c0,0x94082a2,0x95102a2,0x740024a,
+	0xa21009f,0x6800021,0xc7fb840,0x0000000,0x7802a48,0x680c009,0x5801288,0x2009289,
+	0x700024a,0xa20c048,0x911084a,0x900884a,0xc7fb5c0,0x0000000,0x7802a49,0x78028ca,
+	0x400228a,0xb407289,0x4402209,0x440128a,0x7802948,0xb403289,0x4401208,0x4401208,
+	0x680c009,0x5802288,0x2009289,0x700024a,0x9002208,0xa60c008,0xc780240,0x95842a2,
+	0xa60c048,0xc780180,0x95042a2,0xa60c088,0xc7800c0,0x94842a2,0x94042a2,0x740024a,
+	0xa21009f,0x6800021,0xc7fae40,0x0000000,0x7802a48,0x680c009,0x5802288,0x2009289,
+	0x700024a,0x9002208,0xaa1c008,0x918484a,0xaa14048,0x910484a,0xaa0c088,0x908484a,
+	0x900484a,0xc7faa80,0x0000000,0xc780080,0x6800021,0xc7fa980,0x0000000,0x6412106,
+	0x90c1186,0xa6f8006,0xc7db100,0x0000000,0x6804009,0x6012d09,0x6800f8a,0x8012e00,
+	0x0000000,0xd07ff8a,0x0000000,0xcc00000,0x0000000,0x6804009,0x6012c09,0x6809009,
+	0x6012d09,0x6800f8a,0x6412e09,0xd07ffca,0x6012e09,0xcc00000,0x0000000,0x6809009,
+	0x6012c09,0x6804009,0x6012d09,0x6800f8a,0x6412e09,0xd07ffca,0x6012e09,0x6411109,
+	0x78025c8,0x9446248,0x6011109,0xcc00000,0x0000000,0x7800e08,0x7801bc9,0xa608009,
+	0xc780880,0xaa18049,0xaa20089,0xaa640c9,0xa608109,0xc7806c0,0xc780000,0x5801288,
+	0xc780680,0x7c01c4a,0x5802288,0x540124a,0x2009289,0xb0fe209,0x400128a,0x440224a,
+	0x7c01c49,0x5401289,0x400128a,0x540124a,0x2009289,0x5401208,0xb003209,0x7801c49,
+	0x440128a,0x240a24a,0xc780200,0x7c01c8a,0xc000b40,0x6801c4c,0xc780100,0x0000000,
+	0xc000dc0,0x6801c4c,0x7800e48,0x7801c09,0xa608009,0xc780880,0xaa18049,0xaa20089,
+	0xaa640c9,0xa608109,0xc7806c0,0xc780000,0x5801288,0xc780680,0x7c01d4a,0x5802288,
+	0x540124a,0x2009289,0xb0fe209,0x400128a,0x440224a,0x7c01d49,0x5401289,0x400128a,
+	0x540124a,0x2009289,0x5401208,0xb003209,0x7801d49,0x440128a,0x240a24a,0xc780200,
+	0x7c01d8a,0xc000200,0x6801d4c,0xcc00000,0x0000000,0xc000480,0x6801d4c,0xcc00000,
+	0x0000000,0x5802348,0x740030d,0x5801248,0x240a349,0x400130c,0x740030a,0x54012c8,
+	0x200b20b,0x58022cb,0x240a24b,0x400130c,0x740030a,0xcc00000,0x0000000,0x5803288,
+	0x540224a,0x2009289,0xb0fe209,0x400128a,0x440224a,0x7400309,0x54012c8,0x4000349,
+	0x540224a,0x2009289,0xb0fe2c9,0x400128a,0x440224a,0x240a349,0x400130c,0x740030a,
+	0x54012c8,0x200b20b,0x4000349,0x540224a,0x2009289,0xb0fe2c9,0x400128a,0x440224a,
+	0x240a349,0x400130c,0x740030a,0x54022c8,0x4000349,0x540224a,0x2009289,0xb0fe2c9,
+	0x400128a,0x440224a,0x240a349,0x400130c,0x740030a,0xcc00000,0x0000000,0x640c308,
+	0x2008308,0x6035108,0x6800808,0x6035208,0x6800149,0x680c00a,0x700024b,0x740028b,
+	0xb6105c9,0x4001249,0xc7fff00,0x400128a,0x6a0c008,0x6035008,0x6435008,0x580f208,
+	0xbef8048,0x0000000,0x6435308,0x900c208,0xa6f8008,0x0000000,0xcc00000,0x0000000,
+	0x640c408,0x2008308,0x6035108,0x6801008,0x6035208,0x6800609,0x680c00a,0x700024b,
+	0x740028b,0xb6115c9,0x4001249,0xc7fff00,0x400128a,0x6a0c008,0x6035008,0x6435008,
+	0x580f208,0xbef8048,0x0000000,0x6435308,0x900c208,0xa6f8008,0x0000000,0xcc00000,
+	0x0000000,0x640c308,0x2008308,0x6035108,0x6800808,0x6035208,0x6b0c008,0x6035008,
+	0x6435008,0x580f208,0xbef8048,0x0000000,0x6800149,0x680c00a,0x700028b,0x740024b,
+	0xb6105c9,0x4001249,0xc7fff00,0x400128a,0xcc00000,0x0000000,0x640c408,0x2008308,
+	0x6035108,0x6801008,0x6035208,0x6b0c008,0x6035008,0x6435008,0x580f208,0xbef8048,
+	0x0000000,0x6800609,0x680c00a,0x700028b,0x740024b,0xb6115c9,0x4001249,0xc7fff00,
+	0x400128a,0xcc00000,0x0000000,0x640c508,0x2008308,0x6035108,0x6801467,0xc009b40,
+	0x6435128,0x6800c08,0x6035208,0x6801609,0x680c00a,0x700024b,0x740028b,0xb612089,
+	0x4001249,0xc7fff00,0x400128a,0x6a0c008,0x6035008,0x6435008,0x580f208,0xbef8048,
+	0x0000000,0x6435308,0x900c208,0xa6f8008,0x0000000,0x7800f48,0xaa20008,0x540330c,
+	0x7801648,0xaa0c008,0x6800008,0x6900008,0xc000100,0x200c20c,0xcc00000,0x0000000,
+	0x680000d,0x8070300,0x680c00b,0x680000a,0x6470408,0x6470409,0x9508209,0x74002c8,
+	0x40012cb,0xbaeffca,0x400128a,0xaa3800d,0x0000000,0x6470508,0x7c0fe88,0x9210208,
+	0x7c0fec8,0x6470608,0x7c0ff08,0x9210208,0x7c0ff48,0x6470708,0x7c0ff88,0x9210208,
+	0x7c0ffc8,0x640cd08,0x2008308,0x540924d,0x2008248,0x6035108,0x6804008,0x6035208,
+	0x6a0c008,0x6035008,0x6435008,0x580f208,0xbef8048,0x0000000,0xba0c04d,0xcc00000,
+	0x0000000,0xc7ff640,0x400134d,0x640c508,0x2008308,0x6035108,0x6801427,0xc008740,
+	0x6435128,0x6800c08,0x6035208,0x6b0c008,0x6035008,0x6435008,0x580f208,0xbef8048,
+	0x0000000,0x6801609,0x680c00a,0x700028b,0x740024b,0xb612089,0x4001249,0xc7fff00,
+	0x400128a,0xc000e00,0x0000000,0x7800f48,0xaa20008,0x540330c,0x7801648,0xaa0c008,
+	0x6800008,0x6900008,0xc000100,0x200c20c,0xcc00000,0x0000000,0x680000d,0x8070200,
+	0x640cd08,0x2008308,0x540924d,0x2008248,0x6035108,0x6804008,0x6035208,0x6b0c008,
+	0x6035008,0x6435008,0x580f208,0xbef8048,0x0000000,0x680c00b,0x680000a,0x70002c8,
+	0x40012cb,0x6070408,0x9108248,0x6070409,0xbaeffca,0x400128a,0xaa3800d,0x0000000,
+	0x780fe88,0x780fec9,0x9610209,0x6070508,0x780ff08,0x780ff49,0x9610209,0x6070608,
+	0x780ff88,0x780ffc9,0x9610209,0x6070708,0xba0c04d,0xcc00000,0x0000000,0xc7ff640,
+	0x400134d,0x7801748,0x78018c9,0x9421209,0x7801889,0x9441209,0x7801ac9,0x9461209,
+	0x7800f09,0x9483209,0x7800ec9,0x94e3209,0x7800f89,0x9741209,0x7801909,0x9761209,
+	0x7800d49,0x780194a,0x2409289,0x9782209,0x6011708,0x6412508,0x7801009,0x9401209,
+	0x78010c9,0x9482209,0x7801109,0x94c2209,0x7801049,0x9504209,0x7801089,0x9584209,
+	0x6800cc9,0x9706209,0x78008c9,0x9442209,0xaa18009,0x680018a,0x4401249,0x340a24a,
+	0x960420a,0x9808048,0x7800909,0x97c2209,0xaa18009,0x680018a,0x4401249,0x340a24a,
+	0x968420a,0x9808048,0x6012508,0x6470108,0x7800f49,0x9401209,0x9421209,0x9441209,
+	0x7800d49,0x9482209,0x6070108,0x6470b08,0x78008c9,0x9402209,0x7800909,0x9482209,
+	0x9502209,0x6070b08,0x6440808,0x78012c9,0x9401209,0x7801889,0x9421209,0x6040808,
+	0x6440c08,0x78008c9,0x9402209,0x7800909,0x9442209,0x6040c08,0xcc00000,0x0000000,
+	0xc003100,0x0000000,0x78023c8,0x7c04408,0x7802408,0x7c04448,0x7802208,0x7c04488,
+	0x7802308,0x7c044c8,0x78021c8,0x7c04508,0x7802188,0x7c04548,0x7800848,0x7c045c8,
+	0x7800888,0x7c04608,0x7800c88,0x7c04648,0x7800cc8,0x7c04688,0x7800948,0x7c046c8,
+	0x7802288,0x7c04708,0x78024c8,0x7c04748,0x7802508,0x7c04788,0x7802048,0x7c047c8,
+	0x7802548,0x7c04808,0x7800a88,0x7c04848,0x7802b48,0x7c04888,0x7801b08,0x7801b89,
+	0x5401249,0x2c08248,0x7c048c8,0x7801bc8,0x7c04908,0x7801c08,0x7c04948,0x7801c48,
+	0x7c04988,0x7801c88,0x7c049c8,0x7801cc8,0x7c04a08,0x7801d08,0x7c04a48,0x7801d48,
+	0x7c04a88,0x7801d88,0x7c04ac8,0x7801dc8,0x7c04b08,0x7801e08,0x7c04b48,0x7801f88,
+	0x7c04bc8,0x7801fc8,0x7c04c08,0x7802708,0x7c04c48,0x7802748,0x7c04c88,0x7801988,
+	0x7c04cc8,0x78019c8,0x7c04d08,0x7802108,0x7c04d48,0x78014c8,0x7c04e08,0x7801508,
+	0x7c04e48,0x7801548,0x7c04e88,0x7801588,0x7c04ec8,0x78008c8,0x7800909,0x9484209,
+	0x7c04f08,0x6800009,0x7801148,0xa20c048,0x7801008,0x9809009,0xa20c048,0x7801e48,
+	0x9809049,0xa20c048,0x7801ec8,0x9809089,0xa20c048,0x7801f08,0x98090c9,0xa20c048,
+	0x7801f48,0x9809109,0xa20c048,0x7802688,0x9809149,0xa20c048,0x78026c8,0x9809189,
+	0xa20c048,0x7802348,0x98091c9,0xa20c048,0x7802388,0x9809209,0xa20c048,0x7802788,
+	0x9809249,0xa20c048,0x0000000,0x9809289,0x7c04b89,0x680500a,0x6802c08,0x7000209,
+	0x7400289,0x400128a,0xbaf73c8,0x4001208,0x640c108,0x6035108,0x6802008,0x6035208,
+	0x6a04008,0x6035008,0x6435008,0x580f208,0xbef8048,0x0000000,0x6435308,0x900c208,
+	0xa6f8008,0x0000000,0xcc00000,0x0000000,0x800cf00,0x800c0ff,0x6800009,0x680ffca,
+	0x7000248,0x9808408,0x600cf08,0x0000000,0x640cf08,0xa6fc008,0xb403289,0xc7ffe40,
+	0x4001249,0xcc00000,0x0000000,0x680000a,0x680000b,0x6804008,0x7000209,0x580f209,
+	0xbe20048,0x580e209,0xa20c048,0x400128a,0x40012cb,0x6804008,0xbae040a,0x2008288,
+	0x7c02b0b,0xcc00000,0x0000000,0x6800009,0x7c02b09,0x68003ca,0x68043c8,0x7400209,
+	0x440128a,0xaef800a,0x4401208,0x6a00009,0x7400209,0xcc00000,0x0000000,0x6800048,
+	0x7c024c8,0x7c02308,0xcc00000,0x0000000,0x680580a,0x68020c8,0x7000209,0x7400289,
+	0x400128a,0xbaf67c8,0x4001208,0xcc00000,0x0000000,0x6802c0d,0x6410c08,0x8010e81,
+	0x93e1248,0xaa10009,0x7c02b49,0xc0003c0,0x78023cc,0xa62c00b,0x0000000,0x6410c08,
+	0x8010e81,0x93e1248,0xaa18009,0x7802b49,0x9809049,0x7c02b49,0xc000100,0x780240c,
+	0xcc00000,0x0000000,0x7802b08,0xb21c088,0x6800049,0xb214108,0x6800089,0xb20c208,
+	0x68000c9,0x6800109,0x680080a,0x240a24a,0x98091c9,0x6410c08,0x6010e09,0x3808288,
+	0x7400348,0x400134d,0xaeec04c,0x440130c,0xcc00000,0x0000000,0x6460409,0x9001289,
+	0xaaf800a,0x0000000,0xcc00000,0x0000000,0x7802a48,0x680d009,0x2009209,0x700024d,
+	0x7802a88,0x680ee09,0x2009209,0x700024e,0x680000f,0xac0338d,0x6ee000f,0x6ea000f,
+	0x6050a0f,0x7802a48,0xb615e08,0x680d009,0x2009209,0x7802bcd,0x740024d,0x7802a88,
+	0xb615108,0x680ee09,0x2009209,0x7802bce,0x740024e,0xcc00000,0x0000000,0x67f2f23,
+	0xbefc063,0x640c023,0xa617fa3,0x0000000,0x6803ba7,0xc0019c0,0x4000a26,0xa6e3fe3,
+	0x0000000,0x640d223,0xbe0c063,0x908c9a3,0x6800026,0x40019a6,0xaa10066,0x68004a7,
+	0xc001700,0x4000a26,0x6410b23,0x98230a3,0x6010b23,0x6412123,0xa2fc063,0x0000000,
+	0xd07fda6,0x0000000,0x6410c23,0x92039a3,0x7c04da6,0x93269a3,0x7c04de6,0x6410d23,
+	0x6410b23,0x600d326,0x6800067,0xc001240,0x4000a26,0xa6288a6,0x0000000,0x640ce24,
+	0xa21c0a4,0x6411624,0x93e1924,0xaa10024,0x6440123,0xa2fc063,0x0000000,0x8012101,
+	0x640d224,0xa60c926,0x58108e4,0xa20c063,0xa214064,0x0000000,0x800c009,0xc7ff200,
+	0x8007401,0x640d224,0xbe580a4,0x9042924,0xa60c0e4,0x68003e3,0x7c03563,0x6803c25,
+	0x7803563,0xaa3c826,0xa270063,0xaa34866,0xaa308a6,0xa2640a3,0xa260123,0xaa24064,
+	0xbe18223,0xa20c0a4,0xb218566,0xc7804c0,0xaa08526,0xa6444e6,0x98230e3,0x7c03563,
+	0xaa38826,0x6800065,0xaa30866,0x68000a5,0xaa288a6,0x68000e5,0xb220566,0x6800125,
+	0x640d224,0x5811924,0xa20c064,0xaa0c9e6,0x68001e5,0x6803c25,0xae1c566,0xa61bc25,
+	0x640d224,0x928c8e4,0x40018e3,0x968c923,0x600d224,0x68000a7,0xc000180,0x4000a25,
+	0x600c025,0x8030504,0xc7fe540,0x0000000,0x600d128,0x78035a8,0xaa18028,0x0000000,
+	0x600d027,0x8007401,0x640d027,0xa6fc027,0x0000000,0xcc00000,0x0000000,0x600d128,
+	0x78035a8,0xaa54028,0x0000000,0x640cf28,0x6035128,0x680fc28,0x6035228,0x6a00028,
+	0x6035028,0x6435028,0x580fa28,0xbef8068,0x0000000,0x6435328,0x900ca28,0xa6f8028,
+	0x0000000,0x9827427,0x600d027,0x8007401,0x640d027,0xa6fc027,0xcc00000,0x0000000,
+	0x7800848,0x7800889,0x9610209,0x6012308,0x6800208,0x7800d49,0x3408248,0x6040608,
+	0x7800849,0x780088a,0x960f24a,0x6040209,0x7800e09,0x7800e4a,0x960c24a,0x6040309,
+	0x8040400,0xcc00000,0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,
+	0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,
+	0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,
+	0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,
+	0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,0x0000000,
 };
-
-//old
-//#define SEND_PARAM_WITH_REG
-const u32 vh265_mc_send_param_with_reg_mc[] __attribute__((aligned(8))) = {
-0x06810001,0x06800000,0x0d000001,0x07400040,0x0c000900,0x00000000,
-0x06bffe40,0x07c00000,0x06030400,0x00400000,0x0800c0ff,0x0c02dcc0,
-0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
-0x00000000,0x00000000,0x00000000,0x0c7ffd80,0x00000000,0x00000000,
-0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
-0x00000000,0x00000000,0x0c7a1a40,0x00000000,0x0c79c680,0x06412108,
-0x0c780580,0x00000000,0x0cc00000,0x00400000,0x0800c000,0x08002515,
-0x08002608,0x06bfbb80,0x06ffbfc0,0x06070500,0x06070600,0x06070700,
-0x06803fc0,0x07c00140,0x07c00780,0x07c01480,0x0640d000,0x07c033c0,
-0x0640d200,0x07c03340,0x0cc00000,0x00000000,0x06bfff88,0x06030408,
-0x00400000,0x0640c008,0x0a6181c8,0x00000000,0x0c02aec0,0x00000000,
-0x0c79ba00,0x0800c0ff,0x0aa0c048,0x0c781b40,0x00000000,0x06410c08,
-0x08010e90,0x09326208,0x0aa0c808,0x0c79b7c0,0x0800c0fe,0x07803388,
-0x09808008,0x07c03388,0x06410c08,0x08010e90,0x09384288,0x09223248,
-0x07c00189,0x09201248,0x07c001c9,0x08010e90,0x07800148,0x0a805288,
-0x07c0010a,0x0aa0ffc8,0x0c023540,0x05407308,0x0780010a,0x07c0014a,
-0x06410c08,0x08010e88,0x09305248,0x07c00209,0x06410c08,0x08010e90,
-0x09210248,0x07c00249,0x06410c08,0x08010e90,0x09210248,0x07c00289,
-0x06410c08,0x08010e84,0x08010e90,0x08010e90,0x08010e8c,0x06410c08,
-0x08010e88,0x09308248,0x07c002c9,0x0780018b,0x0aa3800b,0x00000000,
-0x06410c0a,0x08010e90,0x0aa2800b,0x093e124a,0x0aa08009,0x0c780000,
-0x093c124a,0x0aa08009,0x0c780000,0x0540228a,0x0c7ffe00,0x044012cb,
-0x06410c08,0x08010e81,0x093e1248,0x0780018b,0x0ae000cb,0x0a60c009,
-0x0680000a,0x0780018a,0x0ac0a2ca,0x00000000,0x0c01a800,0x0400c24a,
-0x0c01a780,0x0401024a,0x0c01a700,0x0401424a,0x0c7ffe00,0x0400128a,
-0x08010e86,0x06806008,0x06010e08,0x06410f08,0x0befc0c8,0x09118208,
-0x0aa08008,0x0c780000,0x06410c08,0x08010e81,0x093e1248,0x0aa38009,
-0x08010e90,0x08010e90,0x08010e90,0x08010e90,0x06410c08,0x08010e81,
-0x093e1248,0x0aa0c009,0x0c01a100,0x06800049,0x0c01a080,0x06800049,
-0x0aa04008,0x08010e81,0x0c799e80,0x0800c0ff,0x0aa0c088,0x0c78a600,
-0x00000000,0x06410c08,0x08010e90,0x09326208,0x0aa0c848,0x0c799c40,
-0x0800c0fe,0x07803388,0x09808048,0x07c03388,0x06410c08,0x08010e88,
-0x09384288,0x09323248,0x07c00609,0x09301248,0x07c00649,0x07800148,
-0x0a808288,0x07c0010a,0x0c021a40,0x05407308,0x0780010a,0x07c0014a,
-0x0c0225c0,0x0540730a,0x06410c08,0x08010e88,0x09305248,0x07c00689,
-0x06410c08,0x08010e90,0x09210248,0x07c006c9,0x06410c08,0x08010e90,
-0x09210248,0x07c00709,0x06410c08,0x08010e84,0x08010e90,0x08010e90,
-0x08010e8c,0x06410c08,0x08010e88,0x09308248,0x07c00749,0x0780060b,
-0x0aa3800b,0x00000000,0x06410c0a,0x08010e90,0x0aa2800b,0x093e124a,
-0x0aa08009,0x0c780000,0x093c124a,0x0aa08009,0x0c780000,0x0540228a,
-0x0c7ffe00,0x044012cb,0x0c018f00,0x06800049,0x07800789,0x0a805209,
-0x07c00108,0x0aa0ffc9,0x0c021480,0x05407309,0x07800108,0x07c00788,
-0x0c018c80,0x068007c9,0x0c018c00,0x06800809,0x0c018b80,0x06800849,
-0x07800808,0x07800849,0x09610209,0x06012308,0x06410c08,0x08010e81,
-0x093e1248,0x0aa24009,0x0c018900,0x06800049,0x0c018880,0x06800049,
-0x0c018800,0x06800049,0x0c018780,0x06800049,0x0c018700,0x06800889,
-0x0c018680,0x068008c9,0x0c018600,0x06800909,0x06410c08,0x08010e81,
-0x093e1248,0x0780060b,0x0ae000cb,0x0a60c009,0x0680000a,0x0780060a,
-0x0ac0a2ca,0x00000000,0x0c018300,0x0402524a,0x0c018280,0x0402924a,
-0x0c018200,0x0402d24a,0x0c7ffe00,0x0400128a,0x0c018100,0x06800c49,
-0x07800c49,0x07c00cc9,0x0c018000,0x06800c89,0x07800c49,0x07800c88,
-0x02009209,0x07c00d09,0x07800d08,0x0a6300c8,0x07800809,0x0403f249,
-0x05806249,0x07c00dc9,0x07800849,0x0403f249,0x05806249,0x07c00e09,
-0x08040640,0x0c780900,0x06820860,0x0a630088,0x07800809,0x0401f249,
-0x05805249,0x07c00dc9,0x07800849,0x0401f249,0x05805249,0x07c00e09,
-0x08040620,0x0c780600,0x06820de0,0x0a630048,0x07800809,0x0400f249,
-0x05804249,0x07c00dc9,0x07800849,0x0400f249,0x05804249,0x07c00e09,
-0x08040610,0x0c780300,0x06821620,0x07800809,0x04007249,0x05803249,
-0x07c00dc9,0x07800849,0x04007249,0x05803249,0x07c00e09,0x08040608,
-0x06822160,0x07800dc8,0x07800e09,0x0e000248,0x00000000,0x00000000,
-0x06800009,0x0f000200,0x04401208,0x0aa10008,0x05801208,0x0c7fff80,
-0x04001249,0x07c01409,0x07800809,0x0780084a,0x0960f24a,0x06040209,
-0x07800dc9,0x07800e0a,0x0960c24a,0x06040309,0x08040400,0x0c016d40,
-0x06800049,0x07800049,0x07c00d49,0x0c016c40,0x06800089,0x07800049,
-0x07800088,0x02009209,0x07c00d89,0x0c016ac0,0x06800e89,0x0c016a40,
-0x06800ec9,0x06410c08,0x08010e81,0x093e1248,0x0aa38009,0x07c00f09,
-0x06410c08,0x08010e81,0x093e1248,0x0aa0c009,0x0c0016c0,0x00000000,
-0x07800788,0x0aa0c008,0x068f000c,0x069f000c,0x0c020640,0x00000000,
-0x06410c08,0x08010e83,0x093e1248,0x07c00f49,0x093c1248,0x07c00f89,
-0x093a1248,0x0aa58009,0x06800009,0x06410c08,0x08010e88,0x09384248,
-0x04001249,0x07c01009,0x09304248,0x04001249,0x07c01049,0x0c016140,
-0x06801089,0x0c0160c0,0x068010c9,0x07801089,0x02008248,0x07c010c8,
-0x06410c08,0x08010e81,0x093e1248,0x07c01109,0x06800049,0x07c00fc9,
-0x0c015e00,0x06801149,0x0680000e,0x0780114f,0x044013cf,0x0aa1000f,
-0x058013cf,0x0c7fff80,0x0400138e,0x07c0118e,0x0780114f,0x0680000e,
-0x0b4143ce,0x00000000,0x0480f20e,0x05404208,0x0680800d,0x0200d20d,
-0x0c002580,0x00000000,0x0480f20e,0x0aa1c3c8,0x00000000,0x0400120e,
-0x0b4043c8,0x00000000,0x0c780100,0x00000000,0x0c004600,0x00000000,
-0x0c7ffb80,0x0400138e,0x06410c08,0x08010e81,0x093e1248,0x07c011c9,
-0x0aa10009,0x0c0154c0,0x06801209,0x0a600008,0x06410c08,0x08010e83,
-0x093e1248,0x07c01249,0x093c1248,0x07c01289,0x093a1248,0x0aa0c009,
-0x0c004a80,0x00000000,0x08010e81,0x0c795040,0x0800c0ff,0x068c8408,
-0x06c41508,0x06070508,0x06070608,0x06070708,0x0680000b,0x0680000a,
-0x06410c08,0x08010e81,0x093e1248,0x0aa08009,0x0c780f00,0x0c014dc0,
-0x06800049,0x0aa140cb,0x0400e3ca,0x0ba0c0ca,0x0680038f,0x068003cf,
-0x0a60c00b,0x0c780180,0x0647050d,0x0a60c04b,0x0c7800c0,0x0647060d,
-0x0647070d,0x0aa38008,0x0400038f,0x0aa300cb,0x0680000e,0x0240f20a,
-0x0aa2410f,0x0920438d,0x0aa1c0cf,0x0918438d,0x0aa1408f,0x0910438d,
-0x0aa0c04f,0x0908438d,0x0900438d,0x0a61c0cb,0x0a60c00a,0x0c7800c0,
-0x0970434e,0x0978434e,0x0c780ec0,0x0607070d,0x0aa1c00a,0x0aa2004a,
-0x0aa2408a,0x0aa280ca,0x0aa2c10a,0x0c7802c0,0x0968434e,0x0c780240,
-0x0940434e,0x0c7801c0,0x0948434e,0x0c780140,0x0950434e,0x0c7800c0,
-0x0958434e,0x0960434e,0x0aa1000b,0x0aa1404b,0x0c7809c0,0x0607070d,
-0x0c780940,0x0607050d,0x0c7808c0,0x0607060d,0x0ba2c08b,0x0680020c,
-0x0c014040,0x06800049,0x04008308,0x0aa0c08b,0x0680f808,0x0680f988,
-0x02008288,0x06070208,0x0607040c,0x0aa1c00b,0x0680e008,0x0aa1404b,
-0x06800008,0x0aa0c08b,0x06806008,0x0680c008,0x0680040e,0x0aa1000b,
-0x0540424a,0x0680100e,0x0540624a,0x02008248,0x06070208,0x0680004d,
-0x0c013a40,0x06800049,0x0200c20c,0x048ff30c,0x0607040c,0x0b8fb38d,
-0x0400134d,0x0ba0c0cb,0x06800149,0x06800049,0x0b40324a,0x0c7fe6c0,
-0x0400128a,0x0b60c0cb,0x0c7fe5c0,0x040012cb,0x0cc00000,0x00000000,
-0x0aa1400e,0x06800009,0x06410c08,0x08010e81,0x093e1248,0x0a608009,
-0x0c781540,0x07801149,0x0a40624e,0x0440144e,0x0c013180,0x06800049,
-0x0c002500,0x02411211,0x0480f451,0x05404451,0x06808008,0x02011211,
-0x06800010,0x06800012,0x06410c08,0x08010e81,0x093e1288,0x0c012e40,
-0x06800049,0x0aa1000a,0x040014c8,0x06800009,0x024134c9,0x0b60c412,
-0x06a0000b,0x0700044b,0x04001451,0x04001492,0x0200c2d3,0x091e12cb,
-0x0900e30c,0x06410c08,0x08010e81,0x093e1288,0x095c130a,0x0a62000a,
-0x06410c08,0x08010e81,0x093e1288,0x0a61000a,0x0a62400b,0x0c7ffb80,
-0x00000000,0x0740034c,0x0400134d,0x04001410,0x0a60c00b,0x0c7ffa00,
-0x00000000,0x0b60c410,0x06a00008,0x07400348,0x0ae08050,0x0c780780,
-0x0440134d,0x07000351,0x0900e451,0x091a1491,0x06900013,0x0aa0c012,
-0x02012453,0x02412453,0x0680004c,0x0b41240c,0x0241130d,0x07000451,
-0x0900e451,0x091a12d1,0x06900013,0x0aa0c00b,0x0200b453,0x0240b453,
-0x0b4072d2,0x0241130d,0x0400048b,0x0700044b,0x07000353,0x0740034b,
-0x07400453,0x0c7ffc00,0x0400130c,0x0c7ff8c0,0x04401410,0x0cc00000,
-0x00000000,0x0c011d40,0x06800049,0x0c011cc0,0x06800089,0x06800010,
-0x0680000a,0x0680000b,0x0780004c,0x0b41130b,0x0c011b00,0x068000c9,
-0x0240a20a,0x0440128a,0x06410c08,0x08010e81,0x093e1248,0x0900e20a,
-0x095c1209,0x07400348,0x0400134d,0x04001410,0x0bacc410,0x040012cb,
-0x0cc00000,0x00000000,0x0680000a,0x0680000b,0x0780008c,0x0b41130b,
-0x0c011600,0x068000c9,0x0200a20a,0x0400128a,0x06410c08,0x08010e81,
-0x093e1248,0x0900e20a,0x095c1209,0x07400348,0x0400134d,0x04001410,
-0x0bacc410,0x040012cb,0x0cc00000,0x00000000,0x06a00008,0x07400348,
-0x0cc00000,0x00000000,0x0580424e,0x07c01449,0x05409249,0x0640c208,
-0x02008248,0x06035108,0x06808008,0x06035208,0x06a08008,0x06035008,
-0x06435008,0x0580f208,0x0bef8048,0x00000000,0x06435308,0x0900c208,
-0x0a6f8008,0x00000000,0x0cc00000,0x00000000,0x05804251,0x07801448,
-0x0a80e209,0x07c01449,0x05409249,0x0640c208,0x02008248,0x06035108,
-0x06808008,0x06035208,0x06b08008,0x06035008,0x06435008,0x0580f208,
-0x0bef8048,0x00000000,0x0cc00000,0x00000000,0x06410c08,0x08010e81,
-0x093e1248,0x0aa1c009,0x00000000,0x06410c08,0x08010e88,0x09301248,
-0x07c012c9,0x0aa03fc9,0x06410c08,0x08010e81,0x093e1248,0x0aa08009,
-0x0c780000,0x06410c08,0x08010e81,0x093e1248,0x0aa24009,0x06410c08,
-0x08010e85,0x09361248,0x0aa14009,0x00000000,0x08010e88,0x00000000,
-0x08010e90,0x06410c08,0x08010e81,0x093e1248,0x0aa08009,0x0c780000,
-0x06410c08,0x08010e81,0x093e1248,0x093c1248,0x093a1248,0x09381248,
-0x0aa24009,0x0c00fdc0,0x06801309,0x0c00fd40,0x06801349,0x0c00fcc0,
-0x06801389,0x0c00fc40,0x068013c9,0x06410c08,0x08010e81,0x093e1248,
-0x0aa08009,0x0c780000,0x06410c08,0x08010e81,0x093e1248,0x0aa08009,
-0x0c780000,0x0cc00000,0x00000000,0x0aa0c0c8,0x0c782f80,0x00000000,
-0x06410c08,0x08010e90,0x09326208,0x0aa0c888,0x0c78f600,0x0800c0fe,
-0x07803388,0x09808088,0x07c03388,0x0c00f5c0,0x06800049,0x07801489,
-0x0a805209,0x07c00108,0x0aa0ffc9,0x0c018c00,0x05407309,0x07800108,
-0x07c01488,0x0c00f340,0x068014c9,0x0780078a,0x0a808288,0x07c00108,
-0x0c017900,0x0540730a,0x0780010a,0x07c0078a,0x0c018380,0x0540730a,
-0x06410c08,0x08010e87,0x093e1248,0x07c01509,0x093c1248,0x07c01549,
-0x09363248,0x07c01589,0x09341248,0x07c015c9,0x09321248,0x07c01609,
-0x0c00ed80,0x06801649,0x04001208,0x07c01648,0x0c00ec80,0x06801689,
-0x04001208,0x07c01688,0x0c00ed40,0x068016c9,0x0401a208,0x07c016c8,
-0x06410c08,0x08010e83,0x093e1248,0x07c01709,0x093c1248,0x07c01749,
-0x093a1248,0x07c01789,0x0aa10009,0x06800008,0x0c00e800,0x068017c9,
-0x07c017c8,0x0c00e900,0x06801809,0x0c00e880,0x06801849,0x06410c08,
-0x08010e86,0x093e1248,0x07c01889,0x093c1248,0x07c018c9,0x093a1248,
-0x07c01909,0x09381248,0x07c01949,0x09361248,0x07c01989,0x09341248,
-0x07c01cc9,0x0aa0c009,0x0c013a80,0x00000000,0x06800048,0x07c01c88,
-0x07801988,0x0a608008,0x0c780a80,0x0c00e0c0,0x06801a09,0x07800dc8,
-0x07c01a88,0x0c00dfc0,0x06801a49,0x07800e08,0x07c01b88,0x06410c08,
-0x08010e81,0x093e1248,0x07c019c9,0x0aa14009,0x0c013dc0,0x00000000,
-0x0c780580,0x00000000,0x07801a0b,0x0ae0010b,0x0680000a,0x0b4072ca,
-0x0c00db80,0x0406a24a,0x04001208,0x07400248,0x0c7ffec0,0x0400128a,
-0x07801a4b,0x0ae0010b,0x0680000a,0x0b4072ca,0x0c00d900,0x0406e24a,
-0x04001208,0x07400248,0x0c7ffec0,0x0400128a,0x06410c08,0x08010e81,
-0x093e1248,0x07c01c89,0x06410c08,0x08010e82,0x093e1248,0x07c01d09,
-0x093c1248,0x0a618009,0x07c01d49,0x07c01d89,0x07c01dc9,0x0c780340,
-0x07c01e09,0x06410c08,0x08010e82,0x093e1248,0x07c01d49,0x093c1248,
-0x0a618009,0x07c01d89,0x0c00d3c0,0x06801dc9,0x0c00d340,0x06801e09,
-0x06410c08,0x08010e81,0x093e1248,0x0a628009,0x07800f08,0x0aa28008,
-0x078014c8,0x0aa0c008,0x068f000c,0x069f000c,0x0c018180,0x00000000,
-0x0c7800c0,0x0c077d00,0x00000000,0x06410c08,0x08010e81,0x093e1248,
-0x07c01e49,0x0c00cc40,0x06801e89,0x04002208,0x07c01e88,0x06410c08,
-0x08010e81,0x093e1248,0x07c01ec9,0x08010e81,0x0c0187c0,0x00000000,
-0x0c78c880,0x0800c0ff,0x0aa0c108,0x0c786e40,0x00000000,0x069fff89,
-0x0640d408,0x09010208,0x0a8fe248,0x00000000,0x06410c08,0x08010e90,
-0x09326208,0x0b210548,0x07c01f08,0x0c78c4c0,0x0800c0fe,0x06410c08,
-0x08010e81,0x093e1248,0x07c01f49,0x07801f08,0x0ba1c408,0x06800009,
-0x0ae14548,0x06800009,0x06410c08,0x08010e81,0x093e1248,0x07c01f89,
-0x0c00c200,0x06800049,0x07801489,0x0a808248,0x07c00108,0x0c015880,
-0x05407309,0x07800108,0x07c01488,0x0c016ac0,0x05407308,0x078014c8,
-0x07800789,0x0a808248,0x07c00108,0x0c014540,0x05407309,0x07800109,
-0x07c00789,0x0c014fc0,0x05407309,0x07801f48,0x06800009,0x0aa10008,
-0x07c02009,0x0c780440,0x07c01fc9,0x07801508,0x0aa14008,0x06800009,
-0x06410c08,0x08010e81,0x093e1248,0x07c02009,0x07801409,0x06410c08,
-0x0680080a,0x0240a24a,0x098091c9,0x06010e09,0x03808288,0x07c01fc8,
-0x07802008,0x0aa0c008,0x0c784a40,0x00000000,0x0c01b480,0x00000000,
-0x07801588,0x0aa0c008,0x098081c8,0x06010e08,0x0c00b500,0x06802049,
-0x07801548,0x0aa14008,0x06800049,0x06410c08,0x08010e81,0x093e1248,
-0x07c02089,0x07801f09,0x0aa084c9,0x0a610509,0x06800008,0x0c781600,
-0x07c020c8,0x06410c08,0x07800909,0x04004249,0x0680080a,0x0240a24a,
-0x098091c9,0x06010e09,0x03808288,0x07c020c8,0x06410c08,0x08010e81,
-0x093e1248,0x0a614009,0x0680400d,0x0c0779c0,0x0780114e,0x0c780600,
-0x07801189,0x06410c08,0x068007ca,0x0240a24a,0x098091c9,0x06010e09,
-0x03808288,0x05801208,0x07c02108,0x0c079ec0,0x04000448,0x0480f211,
-0x05404208,0x06808009,0x02009209,0x0680400d,0x06800008,0x0700024a,
-0x0740034a,0x0400134d,0x04001208,0x0baf0408,0x04001249,0x078011c8,
-0x0a608008,0x0c7808c0,0x0780120a,0x0aa1400a,0x0680000b,0x0c00a5c0,
-0x06800049,0x040002c8,0x0c00a500,0x06800049,0x0200c20b,0x0aa6400c,
-0x0ac052cc,0x07801208,0x0ba50048,0x0c780000,0x00000000,0x06410c08,
-0x07800909,0x04004249,0x0680080a,0x0240a24a,0x098091c9,0x06010e09,
-0x03808288,0x06410c08,0x08010e81,0x093e1248,0x06410c08,0x08010e81,
-0x093e1248,0x0aa0c009,0x0c009f00,0x06800049,0x0c7ffa40,0x0440130c,
-0x0c019500,0x00000000,0x07801248,0x0aa14008,0x06800009,0x06410c08,
-0x08010e81,0x093e1248,0x07c02149,0x07800f88,0x0a610008,0x07c02188,
-0x0c780200,0x07c021c8,0x06410c08,0x08010e82,0x093e1248,0x07c02189,
-0x093c1248,0x07c021c9,0x0780204b,0x0a60c08b,0x0c781700,0x00000000,
-0x0641170a,0x06410c08,0x08010e81,0x093e1248,0x0a628009,0x07801649,
-0x09546289,0x07c02209,0x0a60c00b,0x06800009,0x07801689,0x09606289,
-0x0c7803c0,0x07c02249,0x0c009480,0x06802209,0x07802209,0x04001249,
-0x09546289,0x07c02209,0x0aa1c04b,0x0c0092c0,0x06802249,0x07802249,
-0x04001249,0x09606289,0x07c02249,0x0601170a,0x06800009,0x07c02989,
-0x07801e49,0x0aa14009,0x07802949,0x0b20c049,0x0c019100,0x00000000,
-0x0a61400b,0x06800009,0x06410c08,0x08010e81,0x093e1248,0x0641170a,
-0x096c1289,0x0601170a,0x07c02289,0x07801609,0x0aa14009,0x06800009,
-0x06410c08,0x08010e81,0x093e1248,0x07c022c9,0x06411008,0x09581209,
-0x06011008,0x07802149,0x0aa48009,0x0a61400b,0x06800049,0x06410c08,
-0x08010e81,0x093e1248,0x07c02309,0x0aa1808b,0x0aa0c009,0x06802249,
-0x06802209,0x07000249,0x0ae10049,0x06800009,0x0c780100,0x07c02349,
-0x0c008600,0x06802349,0x0aa0c04b,0x078018c9,0x07801909,0x06047b09,
-0x08047c00,0x0aa10009,0x08047d00,0x0c006d80,0x00000000,0x0c008340,
-0x06802389,0x06800149,0x02409209,0x06411708,0x096e3209,0x06011708,
-0x0c008340,0x068023c9,0x078016c8,0x079023c9,0x02008248,0x07c02408,
-0x07802049,0x09446248,0x078021c8,0x09501248,0x07802188,0x09521248,
-0x07800cc8,0x09542248,0x07800d08,0x09582248,0x07800d48,0x095c2248,
-0x07800d88,0x09602248,0x07801808,0x09647248,0x07801848,0x09727248,
-0x06011109,0x06411009,0x09809389,0x06011009,0x07801888,0x0aa3c008,
-0x0c007bc0,0x06802449,0x0c007b40,0x06802489,0x06411109,0x07801808,
-0x0780244a,0x02008288,0x09647248,0x07801848,0x0780248a,0x02008288,
-0x09727248,0x06011109,0x07801d48,0x0aa14008,0x06800009,0x06410c08,
-0x08010e81,0x093e1248,0x07c024c9,0x0a620009,0x07801d89,0x07c02509,
-0x07801dc9,0x07c02549,0x07801e09,0x0c7802c0,0x07c02589,0x06410c08,
-0x08010e81,0x093e1248,0x0a618009,0x07c02509,0x0c007340,0x06802549,
-0x0c0072c0,0x06802589,0x07801d08,0x0aa34008,0x06800009,0x07802188,
-0x0a61c008,0x078021c8,0x0a614008,0x07802508,0x0aa0c008,0x0c780140,
-0x06800009,0x06410c08,0x08010e81,0x093e1248,0x07c025c9,0x07801988,
-0x0a610008,0x07801cc8,0x0a608008,0x0c780440,0x0c006b80,0x06802609,
-0x0780260b,0x0aa3400b,0x0c006a80,0x06800049,0x04001308,0x0680080a,
-0x0240a30a,0x0980c1cc,0x06410c08,0x06010e0c,0x03808288,0x07c00048,
-0x0aef004b,0x044012cb,0x07801ec8,0x0aa20008,0x0c006700,0x06800049,
-0x0aa14008,0x00000000,0x08010e88,0x0c7fff40,0x04401208,0x0640ce09,
-0x0a238089,0x06420408,0x0a2fc048,0x00000000,0x09c08748,0x06020408,
-0x06460108,0x0a216008,0x00000000,0x06460408,0x0a2fc048,0x00000000,
-0x06460408,0x06060408,0x069fffc9,0x0640d408,0x09010208,0x0a8fe248,
-0x00000000,0x0640d208,0x0a240208,0x07803388,0x0be30208,0x07801fc9,
-0x0a60c009,0x07802049,0x0aa20089,0x0640d209,0x0928c209,0x04001208,
-0x0968c248,0x0600d209,0x0c785c00,0x0800c0ff,0x098080c8,0x07c03388,
-0x0800c008,0x08007401,0x0c012d00,0x00000000,0x0c785a00,0x00000000,
-0x0aa0c148,0x0c7842c0,0x00000000,0x08010e81,0x06812008,0x06010e08,
-0x00000000,0x08010e00,0x07802008,0x0a60c008,0x06800008,0x07c02648,
-0x07801f48,0x0aa58008,0x06800008,0x07c02888,0x07c028c8,0x07c00e48,
-0x07c02688,0x07c026c8,0x07c02708,0x07c02748,0x07801989,0x0aa0c009,
-0x07800dc8,0x07801a88,0x07c02788,0x07c02808,0x0aa0c009,0x07800e08,
-0x07801b88,0x07c027c8,0x07c02848,0x0c780180,0x068001df,0x07801fc8,
-0x07800e49,0x0a802248,0x0c780000,0x07802008,0x0a61c008,0x00000000,
-0x068001df,0x07802889,0x078028c8,0x09508248,0x07c02a09,0x07802889,
-0x0a614049,0x07801cc9,0x0aa0c009,0x00000000,0x0981f15f,0x07802889,
-0x078028c8,0x0958c248,0x0978425f,0x06011609,0x0c0004c0,0x00000000,
-0x07800e48,0x09808788,0x098087c8,0x06012408,0x07800e48,0x06800427,
-0x0c0172c0,0x04000a08,0x0640d409,0x09010249,0x0aa0c009,0x0a8fd209,
-0x00000000,0x06a00008,0x06011408,0x0c786080,0x00000000,0x07802789,
-0x07c029c9,0x078028c9,0x0780274a,0x0a40b289,0x0680000c,0x0780288b,
-0x0780270a,0x0a40728b,0x0680000c,0x0a614009,0x0680008c,0x0a60c00a,
-0x0680008c,0x068000cc,0x07802008,0x09441308,0x06460109,0x094a324c,
-0x06060109,0x06420109,0x0944324c,0x07802048,0x09402248,0x07800d08,
-0x04003208,0x09604248,0x07800cc8,0x04003208,0x09684248,0x06020109,
-0x07800808,0x07800849,0x09610209,0x06020508,0x07802708,0x07802749,
-0x09610209,0x06020708,0x06060708,0x07802808,0x07802849,0x09610209,
-0x06020808,0x06060808,0x07800dc8,0x04401208,0x07800e09,0x04401249,
-0x09610209,0x06020608,0x06800048,0x0541f208,0x06020408,0x06450a08,
-0x09005208,0x0a6f8008,0x06800008,0x07801989,0x0a60c009,0x06f00008,
-0x06d00008,0x06050a08,0x06450108,0x07800889,0x09602209,0x078008c9,
-0x09642209,0x06050108,0x07802708,0x07802749,0x0960a209,0x07801989,
-0x097e1209,0x06050608,0x0780280a,0x07802849,0x0960a289,0x0605070a,
-0x09c087c8,0x0780288a,0x078028c9,0x0960a289,0x0a403288,0x00000000,
-0x098087c8,0x06050808,0x078028c9,0x0780274a,0x0a404289,0x07802889,
-0x0780270a,0x0a802289,0x0c780740,0x0640c908,0x0e000248,0x0640ca0a,
-0x00000000,0x0f000240,0x0200a24a,0x0606110a,0x0606150a,0x0606140a,
-0x04020208,0x078028c9,0x0e000248,0x0640cc0a,0x0640cb0c,0x0f000340,
-0x07802688,0x0e000308,0x0200b34a,0x0402028b,0x00000000,0x0f000240,
-0x0200a24a,0x0606120a,0x0606160a,0x02409309,0x0200b24b,0x0606130b,
-0x0606170b,0x06460408,0x06060408,0x06800048,0x0541f208,0x06060408,
-0x07801988,0x06040508,0x07802808,0x07802849,0x09610209,0x06040308,
-0x07802708,0x07802749,0x09610209,0x06040408,0x07802008,0x0a638008,
-0x06804808,0x06043008,0x06443108,0x0900a248,0x0a6f0009,0x091e5248,
-0x0a6e8009,0x00000000,0x06440008,0x09808008,0x06040008,0x09c08008,
-0x06040008,0x08040701,0x07802008,0x0aa4c008,0x07802888,0x0a614008,
-0x07801cc9,0x0aa0c009,0x0c007c40,0x00000000,0x06411009,0x091c1249,
-0x0a6f8009,0x00000000,0x06411009,0x098093c9,0x06011009,0x06411009,
-0x091e1249,0x0a6f8009,0x0cc00000,0x00000000,0x06411009,0x091c1249,
-0x0a6f8009,0x00000000,0x07800dc9,0x0ae0c049,0x0c0074c0,0x00000000,
-0x06411009,0x098093c9,0x06011009,0x08011c00,0x08011e00,0x06411009,
-0x091e1249,0x0a6f8009,0x0cc00000,0x00000000,0x0a60fc08,0x00000000,
-0x08010e90,0x0c7815c0,0x0800c0ff,0x078007cb,0x0c001600,0x06800049,
-0x06047e08,0x0aa1000b,0x0c0016c0,0x06800049,0x06047f08,0x08048000,
-0x0c0002c0,0x0780220a,0x06047c0c,0x0780204a,0x0a61400a,0x08048020,
-0x0c000140,0x0780224a,0x06047d0c,0x0cc00000,0x00000000,0x0400034a,
-0x06410c0e,0x0980d1cd,0x06010e0d,0x0680000c,0x0400034a,0x0aa1c00d,
-0x093e13ce,0x0580130c,0x097e130f,0x0540138e,0x0c7ffec0,0x0440134d,
-0x0680040d,0x0240d28d,0x0380c34c,0x0aa4000b,0x0400034a,0x06410c0e,
-0x0980d1cd,0x06010e0d,0x0400034a,0x0aa1c00d,0x093e13ce,0x0580130c,
-0x097e130f,0x0540138e,0x0c7ffec0,0x0440134d,0x0680040d,0x0240d28d,
-0x0380c34c,0x0400034c,0x0ae0c00a,0x0cc00000,0x00000000,0x0680000e,
-0x0680000f,0x0900140d,0x0aa1c010,0x0c000900,0x06800049,0x09408388,
-0x0c000840,0x06800049,0x094083c8,0x0920140d,0x0aa34010,0x0c000700,
-0x06800049,0x09508388,0x0c000640,0x06800049,0x0950a3c8,0x0c000580,
-0x06800049,0x09608388,0x0c0004c0,0x06800049,0x0964a3c8,0x0604810e,
-0x0604810f,0x0580134d,0x0c7ff880,0x0440128a,0x00800000,0x07800008,
-0x0c7e3e80,0x06030408,0x06806008,0x06010e08,0x06410f08,0x0befc0c8,
-0x09118208,0x0cc00000,0x07400248,0x0680e008,0x06010e08,0x06410f08,
-0x0befc0c8,0x09118208,0x0cc00000,0x07400248,0x06410509,0x06bfff89,
-0x06030409,0x00400000,0x0be0c108,0x0c7ffa40,0x00000000,0x08012104,
-0x07800dc9,0x0ae0c049,0x06411c22,0x04000862,0x0a26891f,0x06011c21,
-0x0a21481f,0x0c005300,0x00000000,0x0a25411f,0x09c1f15f,0x07801cc9,
-0x0aa48009,0x08011e00,0x0be42022,0x06a907c9,0x06012b09,0x00000000,
-0x00000000,0x06412b09,0x0c005240,0x00000000,0x06411009,0x098093c9,
-0x06011009,0x06411009,0x091e1249,0x0a6f8009,0x0c780840,0x00000000,
-0x0a27e022,0x06a907c9,0x06012b09,0x00000000,0x00000000,0x06412b09,
-0x0c00fd40,0x00000000,0x06411609,0x093e1249,0x0aa4c009,0x06800008,
-0x07c02648,0x06411109,0x07802408,0x09446248,0x06011109,0x06411009,
-0x09809389,0x06011009,0x06411e08,0x0be22008,0x068001df,0x0c07a600,
-0x0978479f,0x06420409,0x09c09749,0x0c780100,0x06020409,0x0c7feac0,
-0x0800c0ff,0x0601161e,0x07800e48,0x09808788,0x098087c8,0x06012408,
-0x07800e48,0x06800427,0x0c011240,0x04000a08,0x0640d409,0x09010249,
-0x0aa0c009,0x0a8fd209,0x00000000,0x06a00008,0x06011408,0x07801988,
-0x0aa0c008,0x0c00f400,0x00000000,0x09c1f09f,0x07800e48,0x04001208,
-0x07c00e48,0x07802648,0x04001208,0x07c02648,0x0a21409f,0x07802809,
-0x0b803248,0x00000000,0x09c1f05f,0x07802888,0x0a618048,0x04001208,
-0x07801cc9,0x0aa0c009,0x00000000,0x0981f15f,0x07802789,0x0b815248,
-0x07c02888,0x07802708,0x07c02888,0x0981f09f,0x07800e48,0x07800dc9,
-0x02008248,0x07802809,0x02408248,0x07c00e48,0x078028c8,0x04001208,
-0x078027c9,0x0b807248,0x07c028c8,0x07801988,0x0aa0c008,0x0c7806c0,
-0x00000000,0x0981f0df,0x078028c8,0x04001208,0x078027c9,0x0b80f248,
-0x07802888,0x04001208,0x07802789,0x0b80b248,0x07800dc9,0x0b807248,
-0x078028c8,0x04001208,0x07800e09,0x0b803248,0x0c7800c0,0x09c1f11f,
-0x0981f11f,0x0981f0df,0x0780289e,0x078028c8,0x0958c788,0x0978479f,
-0x0cb80020,0x00000000,0x06800048,0x07c02008,0x07802688,0x07801a0c,
-0x0b41a308,0x06801a89,0x02009209,0x0700024a,0x0780270b,0x0200b28b,
-0x07c0270b,0x07c0288b,0x0780274b,0x07c028cb,0x04001208,0x0b808308,
-0x07c02688,0x07800dc9,0x07c02789,0x0780270a,0x02409289,0x0c780ac0,
-0x07c02809,0x04001249,0x0700024a,0x07c0280a,0x0780278b,0x0200b28b,
-0x0c780900,0x07c0278b,0x078026c8,0x07801a4c,0x0b802308,0x0c7ff600,
-0x06800008,0x07c02688,0x07c02888,0x07c02708,0x07801a89,0x07c02809,
-0x07c02789,0x078026c8,0x06801b89,0x02009209,0x0700024a,0x0780274b,
-0x0200b28b,0x07c0274b,0x07c028cb,0x04001208,0x0b808308,0x07c026c8,
-0x07800e09,0x07c027c9,0x0780274a,0x02409289,0x0c780200,0x07c02849,
-0x04001249,0x0700024a,0x07c0284a,0x078027cb,0x0200b28b,0x07c027cb,
-0x07802748,0x07800dc9,0x0e000248,0x00000000,0x00000000,0x07802709,
-0x0f000200,0x02008248,0x07c00e48,0x0c7fe780,0x04c177df,0x07802889,
-0x0780270a,0x0400228a,0x0b407289,0x04402209,0x0440128a,0x07802788,
-0x0b403289,0x04401208,0x04401208,0x0680c009,0x02009209,0x07400262,
-0x0a21009f,0x06800021,0x0c7fbe80,0x00000000,0x07802888,0x0680c009,
-0x02009209,0x0c7fbd40,0x07000261,0x07802889,0x0780270a,0x0400228a,
-0x0b407289,0x04402209,0x0440128a,0x07802788,0x0b403289,0x04401208,
-0x04401208,0x0680c009,0x05801288,0x02009289,0x0700024a,0x0a20c048,
-0x0c7800c0,0x094082a2,0x095102a2,0x0740024a,0x0a21009f,0x06800021,
-0x0c7fb780,0x00000000,0x07802888,0x0680c009,0x05801288,0x02009289,
-0x0700024a,0x0a20c048,0x0911084a,0x0900884a,0x0c7fb500,0x00000000,
-0x07802889,0x0780270a,0x0400228a,0x0b407289,0x04402209,0x0440128a,
-0x07802788,0x0b403289,0x04401208,0x04401208,0x0680c009,0x05802288,
-0x02009289,0x0700024a,0x09002208,0x0a60c008,0x0c780240,0x095842a2,
-0x0a60c048,0x0c780180,0x095042a2,0x0a60c088,0x0c7800c0,0x094842a2,
-0x094042a2,0x0740024a,0x0a21009f,0x06800021,0x0c7fad80,0x00000000,
-0x07802888,0x0680c009,0x05802288,0x02009289,0x0700024a,0x09002208,
-0x0aa1c008,0x0918484a,0x0aa14048,0x0910484a,0x0aa0c088,0x0908484a,
-0x0900484a,0x0c7fa9c0,0x00000000,0x0c780080,0x06800021,0x0c7fa8c0,
-0x00000000,0x06412107,0x090c11c7,0x0a6f8007,0x0c7de680,0x00000000,
-0x06804009,0x06012d09,0x06800f8a,0x08012e00,0x00000000,0x0d07ff8a,
-0x00000000,0x0cc00000,0x00000000,0x06804009,0x06012c09,0x06809009,
-0x06012d09,0x06800f8a,0x06412e09,0x0d07ffca,0x06012e09,0x0cc00000,
-0x00000000,0x06809009,0x06012c09,0x06804009,0x06012d09,0x06800f8a,
-0x06412e09,0x0d07ffca,0x06012e09,0x06411109,0x07802408,0x09446248,
-0x06011109,0x0cc00000,0x00000000,0x07800dc8,0x07801a09,0x0a608009,
-0x0c780880,0x0aa18049,0x0aa20089,0x0aa640c9,0x0a608109,0x0c7806c0,
-0x0c780000,0x05801288,0x0c780680,0x07c01a8a,0x05802288,0x0540124a,
-0x02009289,0x0b0fe209,0x0400128a,0x0440224a,0x07c01a89,0x05401289,
-0x0400128a,0x0540124a,0x02009289,0x05401208,0x0b003209,0x07801a89,
-0x0440128a,0x0240a24a,0x0c780200,0x07c01aca,0x0c000b40,0x06801a8c,
-0x0c780100,0x00000000,0x0c000dc0,0x06801a8c,0x07800e08,0x07801a49,
-0x0a608009,0x0c780880,0x0aa18049,0x0aa20089,0x0aa640c9,0x0a608109,
-0x0c7806c0,0x0c780000,0x05801288,0x0c780680,0x07c01b8a,0x05802288,
-0x0540124a,0x02009289,0x0b0fe209,0x0400128a,0x0440224a,0x07c01b89,
-0x05401289,0x0400128a,0x0540124a,0x02009289,0x05401208,0x0b003209,
-0x07801b89,0x0440128a,0x0240a24a,0x0c780200,0x07c01bca,0x0c000200,
-0x06801b8c,0x0cc00000,0x00000000,0x0c000480,0x06801b8c,0x0cc00000,
-0x00000000,0x05802348,0x0740030d,0x05801248,0x0240a349,0x0400130c,
-0x0740030a,0x054012c8,0x0200b20b,0x058022cb,0x0240a24b,0x0400130c,
-0x0740030a,0x0cc00000,0x00000000,0x05803288,0x0540224a,0x02009289,
-0x0b0fe209,0x0400128a,0x0440224a,0x07400309,0x054012c8,0x04000349,
-0x0540224a,0x02009289,0x0b0fe2c9,0x0400128a,0x0440224a,0x0240a349,
-0x0400130c,0x0740030a,0x054012c8,0x0200b20b,0x04000349,0x0540224a,
-0x02009289,0x0b0fe2c9,0x0400128a,0x0440224a,0x0240a349,0x0400130c,
-0x0740030a,0x054022c8,0x04000349,0x0540224a,0x02009289,0x0b0fe2c9,
-0x0400128a,0x0440224a,0x0240a349,0x0400130c,0x0740030a,0x0cc00000,
-0x00000000,0x0640c308,0x02008308,0x06035108,0x06800808,0x06035208,
-0x06800149,0x0680c00a,0x0700024b,0x0740028b,0x0b6105c9,0x04001249,
-0x0c7fff00,0x0400128a,0x06a0c008,0x06035008,0x06435008,0x0580f208,
-0x0bef8048,0x00000000,0x06435308,0x0900c208,0x0a6f8008,0x00000000,
-0x0cc00000,0x00000000,0x0640c408,0x02008308,0x06035108,0x06801008,
-0x06035208,0x06800609,0x0680c00a,0x0700024b,0x0740028b,0x0b611449,
-0x04001249,0x0c7fff00,0x0400128a,0x06a0c008,0x06035008,0x06435008,
-0x0580f208,0x0bef8048,0x00000000,0x06435308,0x0900c208,0x0a6f8008,
-0x00000000,0x0cc00000,0x00000000,0x0640c308,0x02008308,0x06035108,
-0x06800808,0x06035208,0x06b0c008,0x06035008,0x06435008,0x0580f208,
-0x0bef8048,0x00000000,0x06800149,0x0680c00a,0x0700028b,0x0740024b,
-0x0b6105c9,0x04001249,0x0c7fff00,0x0400128a,0x0cc00000,0x00000000,
-0x0640c408,0x02008308,0x06035108,0x06801008,0x06035208,0x06b0c008,
-0x06035008,0x06435008,0x0580f208,0x0bef8048,0x00000000,0x06800609,
-0x0680c00a,0x0700028b,0x0740024b,0x0b611449,0x04001249,0x0c7fff00,
-0x0400128a,0x0cc00000,0x00000000,0x0640c508,0x02008308,0x06035108,
-0x06800c08,0x06035208,0x06801489,0x0680c00a,0x0700024b,0x0740028b,
-0x0b611ec9,0x04001249,0x0c7fff00,0x0400128a,0x06a0c008,0x06035008,
-0x06435008,0x0580f208,0x0bef8048,0x00000000,0x06435308,0x0900c208,
-0x0a6f8008,0x00000000,0x07800f08,0x0aa20008,0x0540330c,0x078014c8,
-0x0aa0c008,0x06800008,0x06900008,0x0c000100,0x0200c20c,0x0cc00000,
-0x00000000,0x0680000d,0x08070300,0x0680c00b,0x0680000a,0x06470408,
-0x06470409,0x09508209,0x074002c8,0x040012cb,0x0baeffca,0x0400128a,
-0x0aa3800d,0x00000000,0x06470508,0x07c0fe88,0x09210208,0x07c0fec8,
-0x06470608,0x07c0ff08,0x09210208,0x07c0ff48,0x06470708,0x07c0ff88,
-0x09210208,0x07c0ffc8,0x0640cd08,0x02008308,0x0540924d,0x02008248,
-0x06035108,0x06804008,0x06035208,0x06a0c008,0x06035008,0x06435008,
-0x0580f208,0x0bef8048,0x00000000,0x0ba0c04d,0x0cc00000,0x00000000,
-0x0c7ff640,0x0400134d,0x0640c508,0x02008308,0x06035108,0x06800c08,
-0x06035208,0x06b0c008,0x06035008,0x06435008,0x0580f208,0x0bef8048,
-0x00000000,0x06801489,0x0680c00a,0x0700028b,0x0740024b,0x0b611ec9,
-0x04001249,0x0c7fff00,0x0400128a,0x0c000e00,0x00000000,0x07800f08,
-0x0aa20008,0x0540330c,0x078014c8,0x0aa0c008,0x06800008,0x06900008,
-0x0c000100,0x0200c20c,0x0cc00000,0x00000000,0x0680000d,0x08070200,
-0x0640cd08,0x02008308,0x0540924d,0x02008248,0x06035108,0x06804008,
-0x06035208,0x06b0c008,0x06035008,0x06435008,0x0580f208,0x0bef8048,
-0x00000000,0x0680c00b,0x0680000a,0x070002c8,0x040012cb,0x06070408,
-0x09108248,0x06070409,0x0baeffca,0x0400128a,0x0aa3800d,0x00000000,
-0x0780fe88,0x0780fec9,0x09610209,0x06070508,0x0780ff08,0x0780ff49,
-0x09610209,0x06070608,0x0780ff88,0x0780ffc9,0x09610209,0x06070708,
-0x0ba0c04d,0x0cc00000,0x00000000,0x0c7ff640,0x0400134d,0x078015c8,
-0x07801749,0x09421209,0x07801709,0x09441209,0x07801949,0x09461209,
-0x07800ec9,0x09483209,0x07800e89,0x094e3209,0x07800f49,0x09741209,
-0x07801789,0x09761209,0x07800d09,0x078017ca,0x02409289,0x09782209,
-0x06011708,0x06412508,0x07800fc9,0x09401209,0x07801089,0x09482209,
-0x078010c9,0x094c2209,0x07801009,0x09504209,0x07801049,0x09584209,
-0x06800cc9,0x09706209,0x07800889,0x09442209,0x0aa18009,0x0680018a,
-0x04401249,0x0340a24a,0x0960420a,0x09808048,0x078008c9,0x097c2209,
-0x0aa18009,0x0680018a,0x04401249,0x0340a24a,0x0968420a,0x09808048,
-0x06012508,0x06470108,0x07800f09,0x09401209,0x09421209,0x09441209,
-0x07800d09,0x09482209,0x06070108,0x06470b08,0x07800889,0x09402209,
-0x078008c9,0x09482209,0x09502209,0x06070b08,0x06440808,0x07801289,
-0x09401209,0x07801709,0x09421209,0x06040808,0x06440c08,0x07800889,
-0x09402209,0x078008c9,0x09442209,0x06040c08,0x0cc00000,0x00000000,
-0x0c002dc0,0x00000000,0x07802208,0x07c04408,0x07802248,0x07c04448,
-0x07802048,0x07c04488,0x07802148,0x07c044c8,0x07802008,0x07c04508,
-0x07801fc8,0x07c04548,0x07800808,0x07c045c8,0x07800848,0x07c04608,
-0x07800c48,0x07c04648,0x07800c88,0x07c04688,0x07800908,0x07c046c8,
-0x078020c8,0x07c04708,0x07802308,0x07c04748,0x07802348,0x07c04788,
-0x07801e88,0x07c047c8,0x07802388,0x07c04808,0x07800a48,0x07c04848,
-0x07802988,0x07c04888,0x07801988,0x078019c9,0x05401249,0x02c08248,
-0x07c048c8,0x07801a08,0x07c04908,0x07801a48,0x07c04948,0x07801a88,
-0x07c04988,0x07801ac8,0x07c049c8,0x07801b08,0x07c04a08,0x07801b48,
-0x07c04a48,0x07801b88,0x07c04a88,0x07801bc8,0x07c04ac8,0x07801c08,
-0x07c04b08,0x07801c48,0x07c04b48,0x07801dc8,0x07c04bc8,0x07801e08,
-0x07c04c08,0x07802548,0x07c04c48,0x07802588,0x07c04c88,0x07801808,
-0x07c04cc8,0x07801848,0x07c04d08,0x07801f48,0x07c04d48,0x06800009,
-0x07801108,0x0a20c048,0x07800fc8,0x09809009,0x0a20c048,0x07801c88,
-0x09809049,0x0a20c048,0x07801d08,0x09809089,0x0a20c048,0x07801d48,
-0x098090c9,0x0a20c048,0x07801d88,0x09809109,0x0a20c048,0x078024c8,
-0x09809149,0x0a20c048,0x07802508,0x09809189,0x0a20c048,0x07802188,
-0x098091c9,0x0a20c048,0x078021c8,0x09809209,0x0a20c048,0x078025c8,
-0x09809249,0x0a20c048,0x00000000,0x09809289,0x07c04b89,0x0680500a,
-0x06802a48,0x07000209,0x07400289,0x0400128a,0x0baf7208,0x04001208,
-0x0800cf00,0x06800009,0x06804008,0x02008248,0x07000208,0x09808408,
-0x0600cf08,0x00000000,0x0640cf08,0x0a6fc008,0x0b60dfc9,0x0c7ffdc0,
-0x04001249,0x0cc00000,0x00000000,0x0800cf00,0x0800c0ff,0x06800009,
-0x0680ffca,0x07000248,0x09808408,0x0600cf08,0x00000000,0x0640cf08,
-0x0a6fc008,0x0b403289,0x0c7ffe40,0x04001249,0x0cc00000,0x00000000,
-0x0680000a,0x0680000b,0x06804008,0x07000209,0x0580f209,0x0be20048,
-0x0580e209,0x0a20c048,0x0400128a,0x040012cb,0x06804008,0x0bae040a,
-0x02008288,0x07c0294b,0x0cc00000,0x00000000,0x06800009,0x07c02949,
-0x068003ca,0x068043c8,0x07400209,0x0440128a,0x0aef800a,0x04401208,
-0x06a00009,0x07400209,0x0cc00000,0x00000000,0x06800048,0x07c02308,
-0x07c02148,0x0cc00000,0x00000000,0x0680580a,0x06801f08,0x07000209,
-0x07400289,0x0400128a,0x0baf6608,0x04001208,0x0cc00000,0x00000000,
-0x06802a4d,0x06410c08,0x08010e81,0x093e1248,0x0aa10009,0x07c02989,
-0x0c0003c0,0x0780220c,0x0a62c00b,0x00000000,0x06410c08,0x08010e81,
-0x093e1248,0x0aa18009,0x07802989,0x09809049,0x07c02989,0x0c000100,
-0x0780224c,0x0cc00000,0x00000000,0x07802948,0x0b21c088,0x06800049,
-0x0b214108,0x06800089,0x0b20c208,0x068000c9,0x06800109,0x0680080a,
-0x0240a24a,0x098091c9,0x06410c08,0x06010e09,0x03808288,0x07400348,
-0x0400134d,0x0aeec04c,0x0440130c,0x0cc00000,0x00000000,0x06460409,
-0x09001289,0x0aaf800a,0x00000000,0x0cc00000,0x00000000,0x07802888,
-0x0680d009,0x02009209,0x0700024d,0x078028c8,0x0680ee09,0x02009209,
-0x0700024e,0x0680000f,0x0ac0338d,0x06ee000f,0x06ea000f,0x06050a0f,
-0x07802888,0x0b615e08,0x0680d009,0x02009209,0x07802a0d,0x0740024d,
-0x078028c8,0x0b615108,0x0680ee09,0x02009209,0x07802a0e,0x0740024e,
-0x0cc00000,0x00000000,0x067f2f23,0x0befc063,0x0640c023,0x0a6f7fe3,
-0x00000000,0x06410b23,0x098230a3,0x06010b23,0x06412123,0x0a2fc063,
-0x00000000,0x06410c23,0x092039a3,0x07c04da6,0x093269a3,0x07c04de6,
-0x06410d23,0x06410b23,0x0600d326,0x06800067,0x0c000fc0,0x04000a26,
-0x0a6308a6,0x00000000,0x06411423,0x090188e3,0x0640ce24,0x0a610023,
-0x0be0c064,0x05801924,0x0a610024,0x06440123,0x0a2fc063,0x00000000,
-0x08012101,0x0640d224,0x0a214064,0x00000000,0x0800c009,0x0c7ff640,
-0x08007401,0x0640d224,0x0be480a4,0x06803c25,0x078033a3,0x0aa3c826,
-0x0a25c063,0x0aa34866,0x0aa308a6,0x0a2500a3,0x0a24c123,0x0be24124,
-0x0be18223,0x0a20c224,0x0b218566,0x0c780380,0x0aa08526,0x0a6304e6,
-0x098230e3,0x07c033a3,0x0aa24826,0x06800065,0x0aa1c866,0x068000a5,
-0x0aa148a6,0x068000e5,0x0b20c566,0x06800125,0x06803c25,0x0ae1c566,
-0x0a61bc25,0x0640d224,0x0910c8e4,0x040018e3,0x0950c923,0x0600d224,
-0x068000a7,0x0c000180,0x04000a25,0x0600c025,0x08030504,0x0c7febc0,
-0x00000000,0x0600d128,0x078033e8,0x0aa18028,0x00000000,0x0600d027,
-0x08007401,0x0640d027,0x0a6fc027,0x00000000,0x0cc00000,0x00000000,
-0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
-0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
-0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
-0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
-0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
-0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
-};
\ No newline at end of file
diff --git a/drivers/amlogic/amports/vh265.c b/drivers/amlogic/amports/vh265.c
index 48acc6f..4d45af0 100644
--- a/drivers/amlogic/amports/vh265.c
+++ b/drivers/amlogic/amports/vh265.c
@@ -1,4063 +1,4934 @@
-/*
- * AMLOGIC Audio/Video streaming port driver.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the named License,
- * or any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
- *
- */
-
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/types.h>
-#include <linux/errno.h>
-#include <linux/interrupt.h>
-#include <linux/semaphore.h>
-#include <linux/delay.h>
-#include <linux/timer.h>
-#include <linux/kfifo.h>
-#include <linux/kthread.h>
-#include <linux/platform_device.h>
-#include <linux/amlogic/amports/vframe.h>
-#include <linux/amlogic/amports/amstream.h>
-#include <linux/amlogic/amports/vformat.h>
-#include <linux/amlogic/amports/ptsserv.h>
-#include <linux/amlogic/amports/canvas.h>
-#include <linux/amlogic/amports/vframe.h>
-#include <linux/amlogic/amports/vframe_provider.h>
-#include <linux/amlogic/amports/vframe_receiver.h>
-#include <linux/dma-mapping.h>
-#include <linux/dma-contiguous.h>
-
-#include <mach/am_regs.h>
-#include "vdec_reg.h"
-
-#include "vdec.h"
-#include "amvdec.h"
-#include "vh265_mc.h"
-
-//#define ERROR_HANDLE_DEBUG
-#ifndef STAT_KTHREAD
-#define STAT_KTHREAD 0x40
-#endif
-
-#define DRIVER_NAME "amvdec_h265"
-#define MODULE_NAME "amvdec_h265"
-
-#define PUT_INTERVAL        (HZ/100)
-#define ERROR_SYSTEM_RESET_COUNT   200
-
-#define PTS_NORMAL                0
-#define PTS_NONE_REF_USE_DURATION 1
-
-#define PTS_MODE_SWITCHING_THRESHOLD           3
-#define PTS_MODE_SWITCHING_RECOVERY_THREASHOLD 3
-
-#define DUR2PTS(x) ((x)*90/96)
-
-static int  vh265_vf_states(vframe_states_t *states, void*);
-static vframe_t *vh265_vf_peek(void*);
-static vframe_t *vh265_vf_get(void*);
-static void vh265_vf_put(vframe_t *, void*);
-static int vh265_event_cb(int type, void *data, void *private_data);
-
-static void vh265_prot_init(void);
-static int vh265_local_init(void);
-static void vh265_put_timer_func(unsigned long arg);
-
-static const char vh265_dec_id[] = "vh265-dev";
-
-#define PROVIDER_NAME   "decoder.h265"
-
-static const struct vframe_operations_s vh265_vf_provider = {
-    .peek      = vh265_vf_peek,
-    .get       = vh265_vf_get,
-    .put       = vh265_vf_put,
-    .event_cb  = vh265_event_cb,
-    .vf_states = vh265_vf_states,
-};
-static struct vframe_provider_s vh265_vf_prov;
-
-static u32 frame_width, frame_height, frame_dur, frame_ar;
-static bool get_frame_dur;
-static struct timer_list recycle_timer;
-static u32 stat;
-static u32 bit_depth_luma;
-static u32 bit_depth_chroma;
-static u32 error_watchdog_count;
-static u32 error_skip_nal_watchdog_count;
-static u32 error_system_watchdog_count;
-
-#define H265_DEBUG_BUFMGR                   0x01
-#define H265_DEBUG_BUFMGR_MORE              0x02
-#define H265_DEBUG_UCODE                    0x04
-#define H265_DEBUG_REG                      0x08
-#define H265_DEBUG_MAN_SEARCH_NAL           0x10
-#define H265_DEBUG_MAN_SKIP_NAL             0x20
-#define H265_DEBUG_DISPLAY_CUR_FRAME        0x40
-#define H265_DEBUG_FORCE_CLK                0x80
-#define H265_DEBUG_SEND_PARAM_WITH_REG      0x100
-#define H265_DEBUG_NO_DISPLAY               0x200
-#define H265_DEBUG_DISCARD_NAL              0x400
-#define H265_DEBUG_OUT_PTS					0x800
-#define H265_DEBUG_DIS_LOC_ERROR_PROC       0x10000
-#define H265_DEBUG_DIS_SYS_ERROR_PROC   0x20000
-#define H265_DEBUG_DUMP_PIC_LIST       0x40000
-#define H265_DEBUG_TRIG_SLICE_SEGMENT_PROC 0x80000
-#define H265_DEBUG_HW_RESET               0x100000
-#define H265_DEBUG_LOAD_UCODE_FROM_FILE   0x200000
-#define H265_DEBUG_ERROR_TRIG             0x400000
-
-
-static u32 debug = 0;
-#ifdef ERROR_HANDLE_DEBUG
-static u32 dbg_nal_skip_flag = 0;   //bit[0], skip vps; bit[1], skip sps; bit[2], skip pps
-static u32 dbg_nal_skip_count = 0;
-#endif
-/*for debug*/
-static u32 decode_stop_pos = 0;
-static u32 decode_stop_pos_pre = 0;
-static u32 decode_pic_begin = 0;
-static uint slice_parse_begin=0;
-static u32 step = 0;
-/**/
-/* 
-bit[1:0]PB_skip_mode: 0, start decoding at begin; 1, start decoding after first I;  2, only decode and display none error picture; 3, start decoding and display after IDR,etc
-bit[31:16] PB_skip_count_after_decoding (decoding but not display),  only for mode 0 and 1.
- */
-static u32 nal_skip_policy = 2;
-
-static u32 use_cma = 1;
-static unsigned char init_flag = 0;
-static unsigned char uninit_list = 0;
-
-static struct semaphore  h265_sema;
-struct task_struct *h265_task = NULL;
-
-/*
-error handling
-*/
-static u32 error_handle_policy = 0;  /* bit 0: 1, wait vps/sps/pps after error recovery; */
-static u32 error_skip_nal_count = 6;
-static u32 error_handle_threshold = 30;
-static u32 error_handle_nal_skip_threshold = 10;
-static u32 error_handle_system_threshold = 30;
-
-#define DEBUG_REG
-#ifdef DEBUG_REG
-void WRITE_VREG_DBG(unsigned adr, unsigned val)
-{
-    if(debug&H265_DEBUG_REG)
-        printk("%s(%x, %x)\n", __func__, adr, val); 
-    WRITE_VREG(adr, val);   
-}    
-#undef WRITE_VREG
-#define WRITE_VREG WRITE_VREG_DBG
-#endif
-#ifdef DEBUG_PTS
-static unsigned long pts_missed, pts_hit;
-#endif
-
-static struct dec_sysinfo vh265_amstream_dec_info;
-extern u32 trickmode_i;
-
-static DEFINE_SPINLOCK(lock);
-static int fatal_error;
-
-static DEFINE_MUTEX(vh265_mutex);
-
-static struct device *cma_dev;
-
-/**************************************************
-
-h265 buffer management include
-
-***************************************************/
-enum NalUnitType
-{
-  NAL_UNIT_CODED_SLICE_TRAIL_N = 0,   // 0
-  NAL_UNIT_CODED_SLICE_TRAIL_R,   // 1
-  
-  NAL_UNIT_CODED_SLICE_TSA_N,     // 2
-  NAL_UNIT_CODED_SLICE_TLA,       // 3   // Current name in the spec: TSA_R
-  
-  NAL_UNIT_CODED_SLICE_STSA_N,    // 4
-  NAL_UNIT_CODED_SLICE_STSA_R,    // 5
-
-  NAL_UNIT_CODED_SLICE_RADL_N,    // 6
-  NAL_UNIT_CODED_SLICE_DLP,       // 7 // Current name in the spec: RADL_R
-  
-  NAL_UNIT_CODED_SLICE_RASL_N,    // 8
-  NAL_UNIT_CODED_SLICE_TFD,       // 9 // Current name in the spec: RASL_R
-
-  NAL_UNIT_RESERVED_10,
-  NAL_UNIT_RESERVED_11,
-  NAL_UNIT_RESERVED_12,
-  NAL_UNIT_RESERVED_13,
-  NAL_UNIT_RESERVED_14,
-  NAL_UNIT_RESERVED_15,
-
-  NAL_UNIT_CODED_SLICE_BLA,       // 16   // Current name in the spec: BLA_W_LP
-  NAL_UNIT_CODED_SLICE_BLANT,     // 17   // Current name in the spec: BLA_W_DLP
-  NAL_UNIT_CODED_SLICE_BLA_N_LP,  // 18
-  NAL_UNIT_CODED_SLICE_IDR,       // 19  // Current name in the spec: IDR_W_DLP
-  NAL_UNIT_CODED_SLICE_IDR_N_LP,  // 20
-  NAL_UNIT_CODED_SLICE_CRA,       // 21
-  NAL_UNIT_RESERVED_22,
-  NAL_UNIT_RESERVED_23,
-
-  NAL_UNIT_RESERVED_24,
-  NAL_UNIT_RESERVED_25,
-  NAL_UNIT_RESERVED_26,
-  NAL_UNIT_RESERVED_27,
-  NAL_UNIT_RESERVED_28,
-  NAL_UNIT_RESERVED_29,
-  NAL_UNIT_RESERVED_30,
-  NAL_UNIT_RESERVED_31,
-
-  NAL_UNIT_VPS,                   // 32
-  NAL_UNIT_SPS,                   // 33
-  NAL_UNIT_PPS,                   // 34
-  NAL_UNIT_ACCESS_UNIT_DELIMITER, // 35
-  NAL_UNIT_EOS,                   // 36
-  NAL_UNIT_EOB,                   // 37
-  NAL_UNIT_FILLER_DATA,           // 38
-  NAL_UNIT_SEI,                   // 39 Prefix SEI
-  NAL_UNIT_SEI_SUFFIX,            // 40 Suffix SEI
-  NAL_UNIT_RESERVED_41,
-  NAL_UNIT_RESERVED_42,
-  NAL_UNIT_RESERVED_43,
-  NAL_UNIT_RESERVED_44,
-  NAL_UNIT_RESERVED_45,
-  NAL_UNIT_RESERVED_46,
-  NAL_UNIT_RESERVED_47,
-  NAL_UNIT_UNSPECIFIED_48,
-  NAL_UNIT_UNSPECIFIED_49,
-  NAL_UNIT_UNSPECIFIED_50,
-  NAL_UNIT_UNSPECIFIED_51,
-  NAL_UNIT_UNSPECIFIED_52,
-  NAL_UNIT_UNSPECIFIED_53,
-  NAL_UNIT_UNSPECIFIED_54,
-  NAL_UNIT_UNSPECIFIED_55,
-  NAL_UNIT_UNSPECIFIED_56,
-  NAL_UNIT_UNSPECIFIED_57,
-  NAL_UNIT_UNSPECIFIED_58,
-  NAL_UNIT_UNSPECIFIED_59,
-  NAL_UNIT_UNSPECIFIED_60,
-  NAL_UNIT_UNSPECIFIED_61,
-  NAL_UNIT_UNSPECIFIED_62,
-  NAL_UNIT_UNSPECIFIED_63,
-  NAL_UNIT_INVALID,
-};
-
-
-//---------------------------------------------------
-// Amrisc Software Interrupt 
-//---------------------------------------------------
-#define AMRISC_STREAM_EMPTY_REQ 0x01
-#define AMRISC_PARSER_REQ       0x02
-#define AMRISC_MAIN_REQ         0x04
-
-//---------------------------------------------------
-// HEVC_DEC_STATUS define
-//---------------------------------------------------
-#define HEVC_DEC_IDLE                        0
-#define HEVC_NAL_UNIT_VPS                    1
-#define HEVC_NAL_UNIT_SPS                    2
-#define HEVC_NAL_UNIT_PPS                    3
-#define HEVC_NAL_UNIT_CODED_SLICE_SEGMENT    4
-#define HEVC_CODED_SLICE_SEGMENT_DAT         5
-#define HEVC_DUMP_LMEM				7
-#define HEVC_SLICE_SEGMENT_DONE  		8
-#define HEVC_NAL_SEARCH_DONE			9
-
-#define HEVC_DISCARD_NAL         0xf0
-#define HEVC_ACTION_ERROR        0xfe
-#define HEVC_ACTION_DONE         0xff
-
-
-
-//---------------------------------------------------
-// Include "parser_cmd.h"
-//---------------------------------------------------
-#define PARSER_CMD_SKIP_CFG_0 0x0000090b
-
-#define PARSER_CMD_SKIP_CFG_1 0x1b14140f
-
-#define PARSER_CMD_SKIP_CFG_2 0x001b1910
-
-#define PARSER_CMD_NUMBER 37
-
-static unsigned short parser_cmd[PARSER_CMD_NUMBER] = {
-0x0401,
-0x8401,
-0x0800,
-0x0402,
-0x9002,
-0x1423,
-0x8CC3,
-0x1423,
-0x8804,
-0x9825,
-0x0800,
-0x04FE,
-0x8406,
-0x8411,
-0x1800,
-0x8408,
-0x8409,
-0x8C2A,
-0x9C2B,
-0x1C00,
-0x840F,
-0x8407,
-0x8000,
-0x8408,
-0x2000,
-0xA800,
-0x8410,
-0x04DE,
-0x840C,
-0x840D,
-0xAC00,
-0xA000,
-0x08C0,
-0x08E0,
-0xA40E,
-0xFC00,
-0x7C00
-};
-
-/**************************************************
-
-h265 buffer management
-
-***************************************************/
-//#define BUFFER_MGR_ONLY
-//#define CONFIG_HEVC_CLK_FORCED_ON
-//#define ENABLE_SWAP_TEST
-#define   MCRCC_ENABLE
-#define MEM_MAP_MODE 2  // 0:linear 1:32x32 2:64x32 ; m8baby test1902
-#define INVALID_POC 0x80000000
-
-
-#define HEVC_DEC_STATUS_REG       HEVC_ASSIST_SCRATCH_0
-#define HEVC_RPM_BUFFER           HEVC_ASSIST_SCRATCH_1
-#define HEVC_SHORT_TERM_RPS       HEVC_ASSIST_SCRATCH_2
-#define HEVC_VPS_BUFFER           HEVC_ASSIST_SCRATCH_3
-#define HEVC_SPS_BUFFER           HEVC_ASSIST_SCRATCH_4
-#define HEVC_PPS_BUFFER           HEVC_ASSIST_SCRATCH_5
-#define HEVC_SAO_UP               HEVC_ASSIST_SCRATCH_6
-#define HEVC_STREAM_SWAP_BUFFER   HEVC_ASSIST_SCRATCH_7
-#define HEVC_STREAM_SWAP_BUFFER2  HEVC_ASSIST_SCRATCH_8
-#define HEVC_sao_mem_unit         HEVC_ASSIST_SCRATCH_9
-#define HEVC_SAO_ABV              HEVC_ASSIST_SCRATCH_A
-#define HEVC_sao_vb_size          HEVC_ASSIST_SCRATCH_B
-#define HEVC_SAO_VB               HEVC_ASSIST_SCRATCH_C
-#define HEVC_SCALELUT             HEVC_ASSIST_SCRATCH_D
-#define HEVC_WAIT_FLAG	          HEVC_ASSIST_SCRATCH_E
-#define RPM_CMD_REG               HEVC_ASSIST_SCRATCH_F
-#define LMEM_DUMP_ADR		          HEVC_ASSIST_SCRATCH_F
-#define HEVC_STREAM_SWAP_TEST     HEVC_ASSIST_SCRATCH_L
-#define HEVC_DECODE_PIC_BEGIN_REG HEVC_ASSIST_SCRATCH_M
-#define HEVC_DECODE_PIC_NUM_REG   HEVC_ASSIST_SCRATCH_N
-
-#define DEBUG_REG1              HEVC_ASSIST_SCRATCH_G
-#define DEBUG_REG2              HEVC_ASSIST_SCRATCH_H
-/* 
-ucode parser/search control
-bit 0:  0, header auto parse; 1, header manual parse
-bit 1:  0, auto skip for noneseamless stream; 1, no skip
-bit [3:2]: valid when bit1==0;  
-0, auto skip nal before first vps/sps/pps/idr; 
-1, auto skip nal before first vps/sps/pps
-2, auto skip nal before fist  vps/sps/pps, and not decode until the first I slice (with slice address of 0)
-*/
-#define NAL_SEARCH_CTL		      HEVC_ASSIST_SCRATCH_I
-#define CUR_NAL_UNIT_TYPE       HEVC_ASSIST_SCRATCH_J
-#define DECODE_STOP_POS         HEVC_ASSIST_SCRATCH_K
-
-#define MAX_INT 0x7FFFFFFF
-
-#define RPM_BEGIN                                              0x100
-#define modification_list_cur                                  0x140
-#define RPM_END                                                0x180
-
-#define RPS_USED_BIT  		14
-//MISC_FLAG0
-#define PCM_LOOP_FILTER_DISABLED_FLAG_BIT		0
-#define PCM_ENABLE_FLAG_BIT				1
-#define LOOP_FILER_ACROSS_TILES_ENABLED_FLAG_BIT	2
-#define PPS_LOOP_FILTER_ACROSS_SLICES_ENABLED_FLAG_BIT	3
-#define DEBLOCKING_FILTER_OVERRIDE_ENABLED_FLAG_BIT	4
-#define PPS_DEBLOCKING_FILTER_DISABLED_FLAG_BIT		5
-#define DEBLOCKING_FILTER_OVERRIDE_FLAG_BIT		6
-#define SLICE_DEBLOCKING_FILTER_DISABLED_FLAG_BIT	7
-#define SLICE_SAO_LUMA_FLAG_BIT				8
-#define SLICE_SAO_CHROMA_FLAG_BIT			9
-#define SLICE_LOOP_FILTER_ACROSS_SLICES_ENABLED_FLAG_BIT 10
-
-typedef union PARAM_{
-    struct{
-        unsigned short data[RPM_END-RPM_BEGIN];
-    }l;
-    struct{ 
-        /* from ucode lmem, do not change this struct */
-        unsigned short CUR_RPS[0x10];                             
-        unsigned short num_ref_idx_l0_active;                 
-        unsigned short num_ref_idx_l1_active;                 
-        unsigned short slice_type;                            
-        unsigned short slice_temporal_mvp_enable_flag;        
-        unsigned short dependent_slice_segment_flag;          
-        unsigned short slice_segment_address;                 
-        unsigned short num_title_rows_minus1;                 
-        unsigned short pic_width_in_luma_samples;             
-        unsigned short pic_height_in_luma_samples;            
-        unsigned short log2_min_coding_block_size_minus3;     
-        unsigned short log2_diff_max_min_coding_block_size;   
-        unsigned short log2_max_pic_order_cnt_lsb_minus4;     
-        unsigned short POClsb;                                
-        unsigned short collocated_from_l0_flag;               
-        unsigned short collocated_ref_idx;                    
-        unsigned short log2_parallel_merge_level;             
-        unsigned short five_minus_max_num_merge_cand;         
-        unsigned short sps_num_reorder_pics_0;                
-        unsigned short modification_flag;                     
-        unsigned short tiles_enabled_flag;                    
-        unsigned short num_tile_columns_minus1;               
-        unsigned short num_tile_rows_minus1;                  
-        unsigned short tile_width[4];                          
-        unsigned short tile_height[4];                         
-        unsigned short misc_flag0;                            
-        unsigned short pps_beta_offset_div2;                  
-        unsigned short pps_tc_offset_div2;                    
-        unsigned short slice_beta_offset_div2;                
-        unsigned short slice_tc_offset_div2;                  
-        unsigned short pps_cb_qp_offset;                      
-        unsigned short pps_cr_qp_offset;                      
-        unsigned short first_slice_segment_in_pic_flag;       
-        unsigned short m_temporalId;                          
-        unsigned short m_nalUnitType;  
-        
-        unsigned short vui_num_units_in_tick_hi;
-        unsigned short vui_num_units_in_tick_lo;
-        unsigned short vui_time_scale_hi;
-        unsigned short vui_time_scale_lo;
-        unsigned short bit_depth;
-        unsigned short reserved[3];
-        
-        unsigned short modification_list[0x20];                      
-    }p;
-}param_t;
-
-
-typedef struct
-{
-    u32 buf_start;
-    u32 buf_size;
-    u32 buf_end;
-} buff_t;
-
-typedef struct
-{
-    u32 max_width;
-    u32 max_height;
-    u32 start_adr;
-    u32 end_adr;
-    buff_t ipp;
-    buff_t sao_abv;
-    buff_t sao_vb;
-    buff_t short_term_rps;
-    buff_t vps;
-    buff_t sps;
-    buff_t pps;
-    buff_t sao_up;
-    buff_t swap_buf;
-    buff_t swap_buf2;
-    buff_t scalelut;
-    buff_t dblk_para;
-    buff_t dblk_data;
-    buff_t mpred_above;
-    buff_t mpred_mv;
-    buff_t rpm;
-    buff_t lmem;
-} BuffInfo_t;
-#define WORK_BUF_SPEC_NUM 2
-static BuffInfo_t amvh265_workbuff_spec[WORK_BUF_SPEC_NUM]={
-    { //8M bytes
-        .max_width = 1920,
-        .max_height = 1088,
-        .ipp = {
-            // IPP work space calculation : 4096 * (Y+CbCr+Flags) = 12k, round to 16k
-            .buf_size = 0x4000,
-        },
-        .sao_abv = {
-            .buf_size = 0x30000,
-        },
-        .sao_vb = {
-            .buf_size = 0x30000,
-        },
-        .short_term_rps = {
-            // SHORT_TERM_RPS - Max 64 set, 16 entry every set, total 64x16x2 = 2048 bytes (0x800)
-            .buf_size = 0x800,
-        },
-        .vps = {
-            // VPS STORE AREA - Max 16 VPS, each has 0x80 bytes, total 0x0800 bytes
-            .buf_size = 0x800,
-        },
-        .sps = {
-            // SPS STORE AREA - Max 16 SPS, each has 0x80 bytes, total 0x0800 bytes
-            .buf_size = 0x800,
-        },
-        .pps = {
-            // PPS STORE AREA - Max 64 PPS, each has 0x80 bytes, total 0x2000 bytes
-            .buf_size = 0x2000,
-        },
-        .sao_up = {
-            // SAO UP STORE AREA - Max 640(10240/16) LCU, each has 16 bytes total 0x2800 bytes
-            .buf_size = 0x2800,
-        },
-        .swap_buf = {
-            // 256cyclex64bit = 2K bytes 0x800 (only 144 cycles valid)
-            .buf_size = 0x800,
-        },
-        .swap_buf2 = {
-            .buf_size = 0x800,
-        },
-        .scalelut = {
-            // support up to 32 SCALELUT 1024x32 = 32Kbytes (0x8000)
-            .buf_size = 0x8000,
-        },
-        .dblk_para = {
-            // DBLK -> Max 256(4096/16) LCU, each para 512bytes(total:0x20000), data 1024bytes(total:0x40000)
-            .buf_size = 0x20000,
-        },
-        .dblk_data = {
-            .buf_size = 0x40000,
-        },
-        .mpred_above = {
-            .buf_size = 0x8000,
-        },
-        .mpred_mv = {
-           .buf_size = 0x40000*16, //1080p, 0x40000 per buffer
-        },
-        .rpm = {
-           .buf_size = 0x80*2,
-        },
-        .lmem = {
-           .buf_size = 0x400*2,    
-        }
-    },
-    { 
-        .max_width = 4096,
-        .max_height = 2048,
-        .ipp = {
-            // IPP work space calculation : 4096 * (Y+CbCr+Flags) = 12k, round to 16k
-            .buf_size = 0x4000,
-        },
-        .sao_abv = {
-            .buf_size = 0x30000,
-        },
-        .sao_vb = {
-            .buf_size = 0x30000,
-        },
-        .short_term_rps = {
-            // SHORT_TERM_RPS - Max 64 set, 16 entry every set, total 64x16x2 = 2048 bytes (0x800)
-            .buf_size = 0x800,
-        },
-        .vps = {
-            // VPS STORE AREA - Max 16 VPS, each has 0x80 bytes, total 0x0800 bytes
-            .buf_size = 0x800,
-        },
-        .sps = {
-            // SPS STORE AREA - Max 16 SPS, each has 0x80 bytes, total 0x0800 bytes
-            .buf_size = 0x800,
-        },
-        .pps = {
-            // PPS STORE AREA - Max 64 PPS, each has 0x80 bytes, total 0x2000 bytes
-            .buf_size = 0x2000,
-        },
-        .sao_up = {
-            // SAO UP STORE AREA - Max 640(10240/16) LCU, each has 16 bytes total 0x2800 bytes
-            .buf_size = 0x2800,
-        },
-        .swap_buf = {
-            // 256cyclex64bit = 2K bytes 0x800 (only 144 cycles valid)
-            .buf_size = 0x800,
-        },
-        .swap_buf2 = {
-            .buf_size = 0x800,
-        },
-        .scalelut = {
-            // support up to 32 SCALELUT 1024x32 = 32Kbytes (0x8000)
-            .buf_size = 0x8000,
-        },
-        .dblk_para = {
-            // DBLK -> Max 256(4096/16) LCU, each para 512bytes(total:0x20000), data 1024bytes(total:0x40000)
-            .buf_size = 0x20000,
-        },
-        .dblk_data = {
-            .buf_size = 0x40000,
-        },
-        .mpred_above = {
-            .buf_size = 0x8000,
-        },
-        .mpred_mv = {
-           .buf_size = 0x100000*16, //4k2k , 0x100000 per buffer
-        },
-        .rpm = {
-           .buf_size = 0x80*2,
-        },
-        .lmem = {
-           .buf_size = 0x400*2,    
-        }
-    }
-};
-
-static void init_buff_spec(BuffInfo_t* buf_spec)
-{
-    buf_spec->ipp.buf_start = buf_spec->start_adr;
-    buf_spec->sao_abv.buf_start = buf_spec->ipp.buf_start + buf_spec->ipp.buf_size;
-
-    buf_spec->sao_vb.buf_start   = buf_spec->sao_abv.buf_start + buf_spec->sao_abv.buf_size;
-    buf_spec->short_term_rps.buf_start    = buf_spec->sao_vb.buf_start + buf_spec->sao_vb.buf_size;
-    buf_spec->vps.buf_start     = buf_spec->short_term_rps.buf_start + buf_spec->short_term_rps.buf_size;
-    buf_spec->sps.buf_start     = buf_spec->vps.buf_start + buf_spec->vps.buf_size;
-    buf_spec->pps.buf_start     = buf_spec->sps.buf_start + buf_spec->sps.buf_size;
-    buf_spec->sao_up.buf_start  = buf_spec->pps.buf_start + buf_spec->pps.buf_size;
-    buf_spec->swap_buf.buf_start= buf_spec->sao_up.buf_start + buf_spec->sao_up.buf_size;
-    buf_spec->swap_buf2.buf_start  = buf_spec->swap_buf.buf_start + buf_spec->swap_buf.buf_size;
-    buf_spec->scalelut.buf_start= buf_spec->swap_buf2.buf_start + buf_spec->swap_buf2.buf_size;
-    buf_spec->dblk_para.buf_start = buf_spec->scalelut.buf_start + buf_spec->scalelut.buf_size;
-    buf_spec->dblk_data.buf_start = buf_spec->dblk_para.buf_start + buf_spec->dblk_para.buf_size;
-    buf_spec->mpred_above.buf_start = buf_spec->dblk_data.buf_start + buf_spec->dblk_data.buf_size;
-    buf_spec->mpred_mv.buf_start    = buf_spec->mpred_above.buf_start + buf_spec->mpred_above.buf_size;
-    if(debug&H265_DEBUG_SEND_PARAM_WITH_REG){
-        buf_spec->end_adr = buf_spec->mpred_mv.buf_start + buf_spec->mpred_mv.buf_size;
-    }
-    else{
-        buf_spec->rpm.buf_start         = buf_spec->mpred_mv.buf_start + buf_spec->mpred_mv.buf_size;
-        if(debug&H265_DEBUG_UCODE){
-            buf_spec->lmem.buf_start = buf_spec->rpm.buf_start + buf_spec->rpm.buf_size;
-            buf_spec->end_adr = buf_spec->lmem.buf_start + buf_spec->lmem.buf_size;
-        }
-        else{
-            buf_spec->end_adr = buf_spec->rpm.buf_start + buf_spec->rpm.buf_size;
-        }    
-    }
-
-    
-    if(debug)printk("%s workspace (%x %x) size = %x\n", __func__,buf_spec->start_adr, buf_spec->end_adr, buf_spec->end_adr-buf_spec->start_adr);
-    if(debug){
-        printk("ipp.buf_start             :%x\n"  , buf_spec->ipp.buf_start         );
-        printk("sao_abv.buf_start          :%x\n"  , buf_spec->sao_abv.buf_start         );
-        printk("sao_vb.buf_start          :%x\n"  , buf_spec->sao_vb.buf_start         );
-        printk("short_term_rps.buf_start  :%x\n"  , buf_spec->short_term_rps.buf_start );    
-        printk("vps.buf_start             :%x\n"  , buf_spec->vps.buf_start            );
-        printk("sps.buf_start             :%x\n"  , buf_spec->sps.buf_start            );
-        printk("pps.buf_start             :%x\n"  , buf_spec->pps.buf_start            );
-        printk("sao_up.buf_start          :%x\n"  , buf_spec->sao_up.buf_start         );
-        printk("swap_buf.buf_start        :%x\n"  , buf_spec->swap_buf.buf_start       );
-        printk("swap_buf2.buf_start       :%x\n"  , buf_spec->swap_buf2.buf_start      );
-        printk("scalelut.buf_start        :%x\n"  , buf_spec->scalelut.buf_start       );
-        printk("dblk_para.buf_start       :%x\n"  , buf_spec->dblk_para.buf_start      );
-        printk("dblk_data.buf_start       :%x\n"  , buf_spec->dblk_data.buf_start      );
-        printk("mpred_above.buf_start     :%x\n"  , buf_spec->mpred_above.buf_start    );
-        printk("mpred_mv.buf_start        :%x\n"  , buf_spec->mpred_mv.buf_start       );
-        if((debug&H265_DEBUG_SEND_PARAM_WITH_REG)==0){
-            printk("rpm.buf_start             :%x\n"  , buf_spec->rpm.buf_start            );
-        }
-    }
-    
-}
-
-
-enum SliceType
-{
-  B_SLICE,
-  P_SLICE,
-  I_SLICE
-};
-
-#define MAX_REF_PIC_NUM 16
-#define MAX_SLICE_NUM 1024
-typedef struct PIC_{
-	struct PIC_ * next;
-        int index;
-	int POC;
-	int decode_idx;
-	int slice_type;
-	int RefNum_L0;
-	int RefNum_L1;
-	int num_reorder_pic;
-        int stream_offset;
-	unsigned char referenced;
-	unsigned char output_mark;
-	unsigned char recon_mark;
-	unsigned char output_ready;
-	unsigned char error_mark;
-	/**/
-	int slice_idx;
-	int m_aiRefPOCList0[MAX_SLICE_NUM][16];
-	int m_aiRefPOCList1[MAX_SLICE_NUM][16];
-	/*buffer*/
-  unsigned int  cma_page_count;
-  struct page *alloc_pages;
-	unsigned long mpred_mv_wr_start_addr;
-	unsigned long mc_y_adr;
-	unsigned long mc_u_v_adr;
-	int mc_canvas_y;
-	int mc_canvas_u_v;
-}PIC_t;
-static PIC_t m_PIC[MAX_REF_PIC_NUM ];
-
-
-typedef struct hevc_state_{
-    BuffInfo_t* work_space_buf;
-    buff_t* mc_buf;
-    
-    unsigned int pic_list_init_flag;
-    unsigned int use_cma_flag;
-    
-    PIC_t* free_pic_list;
-    PIC_t* decode_pic_list;
-    unsigned short* rpm_ptr;
-    unsigned short* lmem_ptr;
-    unsigned short* debug_ptr;
-    int debug_ptr_size;
-    int     pic_w           ;
-    int     pic_h           ;
-    int     lcu_x_num;
-    int     lcu_y_num;
-    int     lcu_total;
-    int     lcu_size        ;
-    int     lcu_size_log2   ;
-
-    int num_tile_col;
-    int num_tile_row;
-    int tile_enabled;
-    int     tile_x;
-    int     tile_y;
-    int     tile_y_x;
-    int     tile_start_lcu_x;
-    int     tile_start_lcu_y; 
-    int     tile_width_lcu  ;
-    int     tile_height_lcu ; 
-
-    int     slice_type      ;
-    int     slice_addr;
-    int     slice_segment_addr;
-
-    unsigned short misc_flag0;
-    int     m_temporalId;
-    int     m_nalUnitType;
-    int     TMVPFlag        ;
-    int     isNextSliceSegment;
-    int     LDCFlag         ;
-    int     m_pocRandomAccess;
-    int     plevel          ;
-    int     MaxNumMergeCand ;
-
-    int     new_pic;
-    int     new_tile;
-    int     curr_POC        ;
-    int     iPrevPOC;
-    int     iPrevTid0POC;
-    int     list_no;
-    int     RefNum_L0       ;
-    int     RefNum_L1       ;
-    int     ColFromL0Flag   ;
-    int     LongTerm_Curr   ;
-    int     LongTerm_Col    ;
-    int     Col_POC         ;
-    int     LongTerm_Ref    ;
-    
-    
-    PIC_t* cur_pic;
-    PIC_t* col_pic;
-    int skip_flag;
-    int decode_idx;
-    int slice_idx;    
-    unsigned char have_vps;
-    unsigned char have_sps;
-    unsigned char have_pps;
-    unsigned char have_valid_start_slice;
-    unsigned char wait_buf;
-    unsigned char error_flag;
-    unsigned int  error_skip_nal_count;
-
-    unsigned char ignore_bufmgr_error; /* bit 0, for decoding; bit 1, for displaying */
-    int PB_skip_mode;
-    int PB_skip_count_after_decoding;
-
-    int pts_mode;
-    int last_lookup_pts;
-    int last_pts;
-    u64 last_lookup_pts_us64;
-    u64 last_pts_us64;
-    u64 shift_byte_count;
-    u32 shift_byte_count_lo;
-	u32 shift_byte_count_hi;
-    int pts_mode_switching_count;
-    int pts_mode_recovery_count;
-}hevc_stru_t;
-
-
-static void hevc_init_stru(hevc_stru_t* hevc, BuffInfo_t* buf_spec_i, buff_t* mc_buf_i)
-{
-    int i;
-    hevc->work_space_buf = buf_spec_i;
-    hevc->mc_buf = mc_buf_i;
-
-    hevc->curr_POC = INVALID_POC;
-    hevc->free_pic_list = NULL;
-    hevc->decode_pic_list = NULL;
-
-    hevc->pic_list_init_flag = 0;
-    hevc->use_cma_flag = 0;
-    hevc->decode_idx = 0;
-    hevc->slice_idx = 0;
-    hevc->new_pic=0;
-    hevc->new_tile=0;
-    hevc->iPrevPOC=0;
-    hevc->list_no=0;
-    //int m_uiMaxCUWidth = 1<<7;
-    //int m_uiMaxCUHeight = 1<<7;
-    hevc->m_pocRandomAccess = MAX_INT;
-    hevc->tile_enabled = 0;
-    hevc->tile_x = 0;
-    hevc->tile_y = 0;
-    hevc->iPrevTid0POC = 0;
-    hevc->slice_addr = 0;
-    hevc->slice_segment_addr = 0;
-    hevc->skip_flag = 0;
-    hevc->misc_flag0 = 0;
-        
-    hevc->cur_pic = NULL;
-    hevc->col_pic = NULL;
-    hevc->wait_buf = 0;
-    hevc->error_flag = 0;
-    hevc->error_skip_nal_count = 0;
-    hevc->have_vps = 0;
-    hevc->have_sps = 0;
-    hevc->have_pps = 0;
-    hevc->have_valid_start_slice = 0;
-
-    hevc->pts_mode = PTS_NORMAL;
-    hevc->last_pts = 0;
-    hevc->last_lookup_pts = 0;
-    hevc->last_pts_us64 = 0;
-    hevc->last_lookup_pts_us64 = 0;
-    hevc->shift_byte_count = 0;
-    hevc->shift_byte_count_lo = 0;
-    hevc->shift_byte_count_hi = 0;
-    hevc->pts_mode_switching_count = 0;
-    hevc->pts_mode_recovery_count = 0;
-
-    hevc->PB_skip_mode = nal_skip_policy&0x3;
-    hevc->PB_skip_count_after_decoding = (nal_skip_policy>>16)&0xffff;
-    if(hevc->PB_skip_mode==0){
-        hevc->ignore_bufmgr_error = 0x1;
-    }
-    else{
-        hevc->ignore_bufmgr_error = 0x0;
-    }
-
-    for(i=0; i<MAX_REF_PIC_NUM; i++){
-        m_PIC[i].index = -1;
-    }
-}    
-
-static int prepare_display_buf(hevc_stru_t* hevc, int display_buff_id, int stream_offset, unsigned short slice_type);
-
-static void get_rpm_param(param_t* params)
-{
-	int i;
-	unsigned int data32;
-	for(i=0; i<128; i++){
-		do{
-			data32 = READ_VREG(RPM_CMD_REG);
-			//printk("%x\n", data32);
-		}while((data32&0x10000)==0);	
-		params->l.data[i] = data32&0xffff;
-		//printk("%x\n", data32);
-		WRITE_VREG(RPM_CMD_REG, 0);		
-	}
-}
-
-
-static void in_q(PIC_t** list_head, PIC_t* pic)
-{
-	PIC_t* list_tail = *list_head;	
-	pic->next = NULL;
-	if(*list_head == NULL){
-		*list_head = pic;	
-	}
-	else{
-		while(list_tail->next){
-			list_tail = list_tail->next;		
-		}
-		list_tail->next = pic;
-	}
-}
-
-static PIC_t* out_q(PIC_t** list_head)
-{
-	PIC_t* pic = *list_head;
-	if(pic){
-		*list_head = pic->next;
-	}
-	return pic;
-}
-
-static PIC_t* get_pic_by_POC(hevc_stru_t* hevc, int POC)
-{
-	PIC_t* pic = hevc->decode_pic_list;
-	PIC_t* ret_pic = NULL;
-	while(pic){
-		if(pic->POC==POC){
-			if(ret_pic==NULL){
-				ret_pic = pic;		
-			}
-			else{
-				if(pic->decode_idx > ret_pic->decode_idx)
-					ret_pic = pic;			
-			}
-		}
-		pic = pic->next;
-	}
-	return ret_pic;
-}
-
-static PIC_t* get_ref_pic_by_POC(hevc_stru_t* hevc, int POC)
-{
-	PIC_t* pic = hevc->decode_pic_list;
-	PIC_t* ret_pic = NULL;
-	while(pic){
-		if((pic->POC==POC)&&(pic->referenced)){
-			if(ret_pic==NULL){
-			    ret_pic = pic;
-		  }
-		  else{
-    	    if(pic->decode_idx > ret_pic->decode_idx)
-				    ret_pic = pic;			
-			}
-		}
-		pic = pic->next;
-	}
-	
-	if(ret_pic==NULL){
-		if(debug) printk("Wrong, POC of %d is not in referenced list\n", POC);		
-		ret_pic = get_pic_by_POC(hevc, POC);
-	}
-	return ret_pic;
-}
-
-static PIC_t* get_pic_by_IDX(hevc_stru_t* hevc, int idx)
-{
-	int i = 0;
-	PIC_t* pic = hevc->decode_pic_list;
-	while(pic){
-		if(i==idx)
-			break;
-		pic = pic->next;
-		i++;
-	}
-	return pic;
-}
-
-static unsigned int log2i (unsigned int val) {
-    unsigned int ret = -1;
-    while (val != 0) {
-        val >>= 1;
-        ret++;
-    }
-    return ret;
-}
-
-static int init_buf_spec(hevc_stru_t* hevc);
-
-static void uninit_pic_list(hevc_stru_t* hevc)
-{
-	int i;
-	for(i=0; i<MAX_REF_PIC_NUM; i++){
-    if(m_PIC[i].alloc_pages!=NULL && m_PIC[i].cma_page_count>0){
-        dma_release_from_contiguous(cma_dev, m_PIC[i].alloc_pages, m_PIC[i].cma_page_count);
-        printk("release cma buffer[%d] (%d %x)\n", i, m_PIC[i].cma_page_count, (unsigned)m_PIC[i].alloc_pages);
-        m_PIC[i].alloc_pages=NULL;
-        m_PIC[i].cma_page_count=0;
-    }
-  }    
-  hevc->pic_list_init_flag = 0;
-}
-
-static void init_pic_list(hevc_stru_t* hevc)
-{
-	int i;
-	int pic_width = hevc->pic_w;
-	int pic_height = hevc->pic_h;
-	int lcu_size = hevc->lcu_size ;
-        int pic_width_lcu  = ( pic_width %lcu_size  ) ? pic_width /lcu_size  + 1 : pic_width /lcu_size; 
-        int pic_height_lcu = ( pic_height %lcu_size ) ? pic_height/lcu_size + 1 : pic_height/lcu_size; 
-        int lcu_total       =pic_width_lcu*pic_height_lcu;
-        int lcu_size_log2 = hevc->lcu_size_log2;
-	//int MV_MEM_UNIT=lcu_size_log2==6 ? 0x100 : lcu_size_log2==5 ? 0x40 : 0x10;
-	int MV_MEM_UNIT=lcu_size_log2==6 ? 0x200 : lcu_size_log2==5 ? 0x80 : 0x20;
-	int mc_buffer_size_u_v = lcu_total*lcu_size*lcu_size/2;
-	int mc_buffer_size_u_v_h = (mc_buffer_size_u_v + 0xffff)>>16;
-	int mpred_mv_end = hevc->work_space_buf->mpred_mv.buf_start + hevc->work_space_buf->mpred_mv.buf_size;
-	int mc_buffer_end = hevc->mc_buf->buf_start + hevc->mc_buf->buf_size;
-	if(mc_buffer_size_u_v&0xffff){ //64k alignment
-		mc_buffer_size_u_v_h+=1;
-	}
-
-	if(debug)printk("[Buffer Management] init_pic_list (%d %d):\n", hevc->pic_w, hevc->pic_h);	
-
-	WRITE_VREG(HEVCD_MPP_ANC2AXI_TBL_CONF_ADDR, 0x0);
-	for(i=0; i<MAX_REF_PIC_NUM; i++){
-		if(((i+1)*(mc_buffer_size_u_v_h<<16)*3) > hevc->mc_buf->buf_size){
-        if(use_cma){
-            hevc->use_cma_flag = 1;
-        }
-        else{
-            if(debug)printk("%s maximum buf size is used\n", __func__);
-              break;
-        }
-    }
-    m_PIC[i].index = i;
-		m_PIC[i].mpred_mv_wr_start_addr = hevc->work_space_buf->mpred_mv.buf_start + ((i * lcu_total)*MV_MEM_UNIT);
-		
-		if(hevc->use_cma_flag){
-		    if((m_PIC[i].cma_page_count!=0) && (m_PIC[i].alloc_pages!=NULL) &&
-		        (m_PIC[i].cma_page_count != PAGE_ALIGN((mc_buffer_size_u_v_h<<16)*3)/PAGE_SIZE)){
-            dma_release_from_contiguous(cma_dev, m_PIC[i].alloc_pages, m_PIC[i].cma_page_count);
-            printk("release cma buffer[%d] (%d %x)\n", i, m_PIC[i].cma_page_count, (unsigned)m_PIC[i].alloc_pages);
-            m_PIC[i].alloc_pages=NULL;
-            m_PIC[i].cma_page_count=0;		        
-		    }
-		    if(m_PIC[i].alloc_pages == NULL){
-    		    m_PIC[i].cma_page_count = PAGE_ALIGN((mc_buffer_size_u_v_h<<16)*3)/PAGE_SIZE;
-            m_PIC[i].alloc_pages = dma_alloc_from_contiguous(cma_dev, m_PIC[i].cma_page_count, 4);
-            if(m_PIC[i].alloc_pages == NULL){
-                printk("allocate cma buffer[%d] fail\n", i);
-                m_PIC[i].cma_page_count = 0;
-                break;
-            }
-            m_PIC[i].mc_y_adr = page_to_phys(m_PIC[i].alloc_pages);
-    		    m_PIC[i].mc_u_v_adr = m_PIC[i].mc_y_adr + ((mc_buffer_size_u_v_h<<16)<<1);
-            printk("allocate cma buffer[%d] (%d,%x,%x)\n", i, m_PIC[i].cma_page_count , (unsigned)m_PIC[i].alloc_pages, (unsigned)m_PIC[i].mc_y_adr);
-		    }
-		    else{
-            printk("reuse cma buffer[%d] (%d,%x,%x)\n", i, m_PIC[i].cma_page_count , (unsigned)m_PIC[i].alloc_pages, (unsigned)m_PIC[i].mc_y_adr);
-		    }
-		}
-		else{
-		    m_PIC[i].cma_page_count = 0;
-		    m_PIC[i].alloc_pages = NULL;
-		    m_PIC[i].mc_y_adr = hevc->mc_buf->buf_start + i*(mc_buffer_size_u_v_h<<16)*3;
-		    m_PIC[i].mc_u_v_adr = m_PIC[i].mc_y_adr + ((mc_buffer_size_u_v_h<<16)<<1);
-    }		    
-		m_PIC[i].mc_canvas_y = (i<<1);
-		m_PIC[i].mc_canvas_u_v = (i<<1)+1;
-
-		if((((m_PIC[i].mc_y_adr+((mc_buffer_size_u_v_h<<16)*3)) > mc_buffer_end) && (m_PIC[i].alloc_pages==NULL))
-		    ||((m_PIC[i].mpred_mv_wr_start_addr+(lcu_total*MV_MEM_UNIT)) > mpred_mv_end)){
-	    if(debug) printk("Max mc buffer or mpred_mv buffer is used\n");		
-			break;
-		}
-    in_q(&hevc->free_pic_list, &m_PIC[i]);
-
-
-		WRITE_VREG(HEVCD_MPP_ANC2AXI_TBL_CMD_ADDR, m_PIC[i].mc_y_adr|(m_PIC[i].mc_canvas_y<<8)|0x1);
-		WRITE_VREG(HEVCD_MPP_ANC2AXI_TBL_CMD_ADDR, m_PIC[i].mc_u_v_adr|(m_PIC[i].mc_canvas_u_v<<8)|0x1);
-
-    if(debug&H265_DEBUG_BUFMGR){
-        printk("Buffer %d: canv_y %x  canv_u_v %x mc_y_adr %lx mc_u_v_adr %lx mpred_mv_wr_start_addr %lx\n", i, m_PIC[i].mc_canvas_y,m_PIC[i].mc_canvas_u_v,m_PIC[i].mc_y_adr, m_PIC[i].mc_u_v_adr, m_PIC[i].mpred_mv_wr_start_addr);
-    }
-	}
-	WRITE_VREG(HEVCD_MPP_ANC2AXI_TBL_CONF_ADDR, 0x1);
-
-
-    // Zero out canvas registers in IPP -- avoid simulation X
-	    WRITE_VREG(HEVCD_MPP_ANC_CANVAS_ACCCONFIG_ADDR, (0 << 8) | (0<<1) | 1);
-		for(i=0; i<32; i++){
-				WRITE_VREG(HEVCD_MPP_ANC_CANVAS_DATA_ADDR, 0);
-        }
-
-}
-
-static void init_pic_list_hw(void)
-{
-	int i;
-	WRITE_VREG(HEVCD_MPP_ANC2AXI_TBL_CONF_ADDR, 0x0);
-	for(i=0; i<MAX_REF_PIC_NUM; i++){
-      if(m_PIC[i].index == -1)
-         break;
-		  WRITE_VREG(HEVCD_MPP_ANC2AXI_TBL_CMD_ADDR, m_PIC[i].mc_y_adr|(m_PIC[i].mc_canvas_y<<8)|0x1);
-		  WRITE_VREG(HEVCD_MPP_ANC2AXI_TBL_CMD_ADDR, m_PIC[i].mc_u_v_adr|(m_PIC[i].mc_canvas_u_v<<8)|0x1);
-	}
-	WRITE_VREG(HEVCD_MPP_ANC2AXI_TBL_CONF_ADDR, 0x1);
-
- // Zero out canvas registers in IPP -- avoid simulation X
-  WRITE_VREG(HEVCD_MPP_ANC_CANVAS_ACCCONFIG_ADDR, (0 << 8) | (0<<1) | 1);
-  for(i=0; i<32; i++){
-			WRITE_VREG(HEVCD_MPP_ANC_CANVAS_DATA_ADDR, 0);
-  }
-    
-}    
-
-
-static void dump_pic_list(hevc_stru_t* hevc)
-{
-	PIC_t* pic = hevc->decode_pic_list;
-	printk("pic_list_init_flag is %d\r\n", hevc->pic_list_init_flag);
-	while(pic){
-		printk("index %d decode_idx:%d,	POC:%d,	referenced:%d,	num_reorder_pic:%d, output_mark:%d, output_ready:%d, mv_wr_start %lx\n", pic->index, pic->decode_idx, pic->POC, pic->referenced, pic->num_reorder_pic, pic->output_mark, pic->output_ready, pic->mpred_mv_wr_start_addr);
-		pic = pic->next;
-	}
-}
-
-static PIC_t* output_pic(hevc_stru_t* hevc, unsigned char flush_flag)
-{
-	int num_pic_not_yet_display = 0;
-	PIC_t* pic = hevc->decode_pic_list;
-	PIC_t* pic_display = NULL;
-	while(pic){
-		if(pic->output_mark){
-			num_pic_not_yet_display++;
-		}
-		pic = pic->next;
-	}
-
-	pic = hevc->decode_pic_list;
-	while(pic){
-		if(pic->output_mark){
-			if(pic_display){
-				if(pic->POC < pic_display->POC){
-					pic_display = pic;
-				}
-			}
-			else{
-				pic_display = pic;			
-			}
-		}
-		pic = pic->next;
-	}
-	if(pic_display){
-		if((num_pic_not_yet_display > pic_display->num_reorder_pic)||flush_flag){
-			pic_display->output_mark = 0;
-			pic_display->recon_mark = 0;
-			pic_display->output_ready = 1;
-		}
-		else{
-			pic_display = NULL;		
-		}
-	}
-	return pic_display;
-}
-
-static int config_mc_buffer(hevc_stru_t* hevc, PIC_t* cur_pic)
-{
-	int i;	
-	PIC_t* pic;
-    if(debug&H265_DEBUG_BUFMGR) 
-        printk("config_mc_buffer entered .....\n");
-	if(cur_pic->slice_type != 2){ //P and B pic
-	    WRITE_VREG(HEVCD_MPP_ANC_CANVAS_ACCCONFIG_ADDR, (0 << 8) | (0<<1) | 1);
-		for(i=0; i<cur_pic->RefNum_L0; i++){
-			pic = get_ref_pic_by_POC(hevc, cur_pic->m_aiRefPOCList0[cur_pic->slice_idx][i]);
-			if(pic){
-				if(pic->error_mark){
-            cur_pic->error_mark = 1;
-				}
-				WRITE_VREG(HEVCD_MPP_ANC_CANVAS_DATA_ADDR, (pic->mc_canvas_u_v<<16)|(pic->mc_canvas_u_v<<8)|pic->mc_canvas_y);
-        if(debug&H265_DEBUG_BUFMGR) 
-            printk("refid %x mc_canvas_u_v %x mc_canvas_y %x\n", i,pic->mc_canvas_u_v,pic->mc_canvas_y);
-			}
-			else{
-				if(debug) printk("Error %s, %dth poc (%d) of RPS is not in the pic list0\n", __func__, i, cur_pic->m_aiRefPOCList0[cur_pic->slice_idx][i]);
-        cur_pic->error_mark = 1;
-				//dump_lmem();
-			}
-		}
-	}
-	if(cur_pic->slice_type == 0){ //B pic
-        if(debug&H265_DEBUG_BUFMGR) 
-            printk("config_mc_buffer RefNum_L1\n");
-	    WRITE_VREG(HEVCD_MPP_ANC_CANVAS_ACCCONFIG_ADDR, (16 << 8) | (0<<1) | 1);
-		for(i=0; i<cur_pic->RefNum_L1; i++){
-			pic = get_ref_pic_by_POC(hevc, cur_pic->m_aiRefPOCList1[cur_pic->slice_idx][i]);
-			if(pic){
-				if(pic->error_mark){
-            cur_pic->error_mark = 1;
-				}
-				WRITE_VREG(HEVCD_MPP_ANC_CANVAS_DATA_ADDR, (pic->mc_canvas_u_v<<16)|(pic->mc_canvas_u_v<<8)|pic->mc_canvas_y);
-                if(debug&H265_DEBUG_BUFMGR){
-                    printk("refid %x mc_canvas_u_v %x mc_canvas_y %x\n", i,pic->mc_canvas_u_v,pic->mc_canvas_y);
-                }
-			}
-			else{
-				if(debug) printk("Error %s, %dth poc (%d) of RPS is not in the pic list1\n", __func__, i, cur_pic->m_aiRefPOCList1[cur_pic->slice_idx][i]);
-        cur_pic->error_mark = 1;
-				//dump_lmem();
-			}
-		}
-	}
-	return 0;
-}
-
-static void apply_ref_pic_set(hevc_stru_t* hevc, int cur_poc, param_t* params)
-{
-	int i;
-	int poc_tmp;
-	PIC_t* pic = hevc->decode_pic_list;
-	unsigned char is_referenced;
-	//printk("%s cur_poc %d\n", __func__, cur_poc);	
-	while(pic){
-		if((pic->referenced == 0 || pic->POC == cur_poc)){
-			pic = pic->next;
-			continue;
-		}
-		is_referenced = 0;
-		for(i=0; i<16; i++){
-			int delt;
-			if(params->p.CUR_RPS[i]&0x8000)
-				break;		
-			delt = params->p.CUR_RPS[i]&((1<<(RPS_USED_BIT-1))-1);
-			if(params->p.CUR_RPS[i]&(1<<(RPS_USED_BIT-1))){
-				poc_tmp = cur_poc - ((1<<(RPS_USED_BIT-1))-delt) ;
-			}
-			else{
-				poc_tmp = cur_poc + delt;
-			}
-			if(poc_tmp == pic->POC){
-				is_referenced = 1;
-				//printk("i is %d\n", i);
-				break;
-			}
-		}
-		if(is_referenced == 0){
-			pic->referenced = 0;
-			//printk("set poc %d reference to 0\n", pic->POC);
-		}
-		pic = pic->next;
-	}
-
-}
-
-static void set_ref_pic_list(PIC_t* pic,  param_t* params)
-{
-	int i, rIdx;
-	int num_neg = 0;
-	int num_pos = 0;
-	int total_num;
-	int num_ref_idx_l0_active = params->p.num_ref_idx_l0_active;
-	int num_ref_idx_l1_active = params->p.num_ref_idx_l1_active;
-	int RefPicSetStCurr0[16];
-	int RefPicSetStCurr1[16];
-	for(i=0;i<16;i++){
-		RefPicSetStCurr0[i]=0; RefPicSetStCurr1[i]=0;
-		pic->m_aiRefPOCList0[pic->slice_idx][i] = 0;
-		pic->m_aiRefPOCList1[pic->slice_idx][i] = 0;
-	}
-	for(i=0; i<16; i++){
-		if(params->p.CUR_RPS[i]&0x8000)
-			break;		
-		if((params->p.CUR_RPS[i]>>RPS_USED_BIT)&1){
-			int delt = params->p.CUR_RPS[i]&((1<<(RPS_USED_BIT-1))-1);
-			if((params->p.CUR_RPS[i]>>(RPS_USED_BIT-1))&1){
-				RefPicSetStCurr0[num_neg]=pic->POC - ((1<<(RPS_USED_BIT-1))-delt) ;
-				//printk("RefPicSetStCurr0 %x %x %x\n", RefPicSetStCurr0[num_neg], pic->POC, (0x800-(params[i]&0x7ff)));
-				num_neg++;
-			}
-			else{
-				RefPicSetStCurr1[num_pos]=pic->POC + delt;
-				//printk("RefPicSetStCurr1 %d\n", RefPicSetStCurr1[num_pos]);
-				num_pos++;
-			}
-		}	
-	}
-	total_num = num_neg + num_pos;
-	if(debug&H265_DEBUG_BUFMGR){
-	    printk("%s: curpoc %d slice_type %d, total %d num_neg %d num_list0 %d num_list1 %d\n", __func__,
-		        pic->POC, params->p.slice_type, total_num, num_neg,num_ref_idx_l0_active, num_ref_idx_l1_active);
-	}
-	
-	if(total_num>0){
-		if(params->p.modification_flag&0x1){
-			if(debug&H265_DEBUG_BUFMGR) 
-			    printk("ref0 POC (modification):");
-			for(rIdx=0; rIdx<num_ref_idx_l0_active; rIdx++){
-				int cIdx = params->p.modification_list[rIdx];
-				pic->m_aiRefPOCList0[pic->slice_idx][rIdx] = cIdx>=num_neg?RefPicSetStCurr1[cIdx-num_neg]:RefPicSetStCurr0[cIdx];	
-				if(debug&H265_DEBUG_BUFMGR) 
-				    printk("%d ", pic->m_aiRefPOCList0[pic->slice_idx][rIdx]);
-			}
-		}
-		else{
-			if(debug&H265_DEBUG_BUFMGR) 
-			    printk("ref0 POC:");
-			for(rIdx=0; rIdx<num_ref_idx_l0_active; rIdx++){
-				int cIdx = rIdx % total_num;		
-				pic->m_aiRefPOCList0[pic->slice_idx][rIdx] = cIdx>=num_neg?RefPicSetStCurr1[cIdx-num_neg]:RefPicSetStCurr0[cIdx];	
-				if(debug&H265_DEBUG_BUFMGR) 
-				    printk("%d ", pic->m_aiRefPOCList0[pic->slice_idx][rIdx]);
-			}
-		}
-		if(debug&H265_DEBUG_BUFMGR) 
-		    printk("\n");
-		if(params->p.slice_type == B_SLICE){
-			if(params->p.modification_flag&0x2){
-				if(debug&H265_DEBUG_BUFMGR) 
-				    printk("ref1 POC (modification):");
-				for(rIdx=0; rIdx<num_ref_idx_l1_active; rIdx++){
-					int cIdx;
-					if(params->p.modification_flag&0x1){
-					    cIdx = params->p.modification_list[num_ref_idx_l0_active+rIdx];
-					}
-					else{
-				            cIdx = params->p.modification_list[rIdx];
-					}
-					pic->m_aiRefPOCList1[pic->slice_idx][rIdx] = cIdx>=num_pos?RefPicSetStCurr0[cIdx-num_pos]:RefPicSetStCurr1[cIdx];
-					if(debug&H265_DEBUG_BUFMGR) 
-					    printk("%d ", pic->m_aiRefPOCList1[pic->slice_idx][rIdx]);
-				}
-			}
-			else{
-				if(debug&H265_DEBUG_BUFMGR) 
-				    printk("ref1 POC:");
-				for(rIdx=0; rIdx<num_ref_idx_l1_active; rIdx++){
-					int cIdx = rIdx % total_num;		
-					pic->m_aiRefPOCList1[pic->slice_idx][rIdx] = cIdx>=num_pos?RefPicSetStCurr0[cIdx-num_pos]:RefPicSetStCurr1[cIdx];
-					if(debug&H265_DEBUG_BUFMGR) 
-					    printk("%d ", pic->m_aiRefPOCList1[pic->slice_idx][rIdx]);
-				}
-			}
-			if(debug&H265_DEBUG_BUFMGR) 
-			    printk("\n");
-		}
-	}
-	/*set m_PIC */
-	pic->slice_type = (params->p.slice_type == I_SLICE ) ? 2 :
-                                (params->p.slice_type == P_SLICE ) ? 1 :
-                                (params->p.slice_type == B_SLICE ) ? 0 : 3;
-	pic->RefNum_L0 = num_ref_idx_l0_active;
-	pic->RefNum_L1 = num_ref_idx_l1_active;
-}
-
-#define MAX_TILE_COL_NUM	5
-#define MAX_TILE_ROW_NUM	5
-typedef struct{
-	int width;
-	int height;
-	int start_cu_x;
-	int start_cu_y;
-	
-	unsigned long sao_vb_start_addr;
-	unsigned long sao_abv_start_addr;
-}tile_t;
-tile_t m_tile[MAX_TILE_ROW_NUM][MAX_TILE_COL_NUM];
-
-static void update_tile_info(hevc_stru_t* hevc,  int pic_width_cu, int pic_height_cu, int sao_mem_unit, param_t* params)
-{
-	int i,j;	
-	int start_cu_x, start_cu_y;
-    int sao_vb_size = (sao_mem_unit+(2<<4))*pic_height_cu;
-    int sao_abv_size = sao_mem_unit*pic_width_cu;
-
-	hevc->tile_enabled = params->p.tiles_enabled_flag&1;
-	if(params->p.tiles_enabled_flag&1){
-		hevc->num_tile_col = params->p.num_tile_columns_minus1 + 1;
-		hevc->num_tile_row = params->p.num_tile_rows_minus1 + 1;
-		if(debug&H265_DEBUG_BUFMGR){
-		    printk("%s pic_w_cu %d pic_h_cu %d tile_enabled num_tile_col %d num_tile_row %d:\n", __func__, pic_width_cu, pic_height_cu, hevc->num_tile_col, hevc->num_tile_row);
-		}
-
-
-		if(params->p.tiles_enabled_flag&2){ //uniform flag
-			int w = pic_width_cu/hevc->num_tile_col;
-			int h = pic_height_cu/hevc->num_tile_row;
-			start_cu_y = 0;			
-			for(i=0; i<hevc->num_tile_row; i++){
-				start_cu_x = 0;
-				for(j=0; j<hevc->num_tile_col; j++){
-					if(j == (hevc->num_tile_col-1))
-						m_tile[i][j].width = pic_width_cu - start_cu_x;
-					else			
-						m_tile[i][j].width = w;
-					if(i == (hevc->num_tile_row-1))
-						m_tile[i][j].height = pic_height_cu - start_cu_y;
-					else			
-						m_tile[i][j].height = h;
-					m_tile[i][j].start_cu_x = start_cu_x;
-					m_tile[i][j].start_cu_y = start_cu_y;
-					m_tile[i][j].sao_vb_start_addr = hevc->work_space_buf->sao_vb.buf_start + j*sao_vb_size ;
-					m_tile[i][j].sao_abv_start_addr = hevc->work_space_buf->sao_abv.buf_start + i*sao_abv_size ;
-					if(debug&H265_DEBUG_BUFMGR){
-					    printk("{y=%d, x=%d w %d h %d start_x %d start_y %d sao_vb_start 0x%lx sao_abv_start 0x%lx}\n", 
-						    i,j,m_tile[i][j].width,m_tile[i][j].height, m_tile[i][j].start_cu_x, m_tile[i][j].start_cu_y,m_tile[i][j].sao_vb_start_addr, m_tile[i][j].sao_abv_start_addr);
-					}
-					start_cu_x += m_tile[i][j].width;
-					
-				}
-				start_cu_y += m_tile[i][0].height;
-			}			
-		}
-		else{
-			start_cu_y = 0;			
-			for(i=0; i<hevc->num_tile_row; i++){
-				start_cu_x = 0;
-				for(j=0; j<hevc->num_tile_col; j++){
-					if(j == (hevc->num_tile_col-1))
-						m_tile[i][j].width = pic_width_cu - start_cu_x;
-					else			
-						m_tile[i][j].width = params->p.tile_width[j];
-					if(i == (hevc->num_tile_row-1))
-						m_tile[i][j].height = pic_height_cu - start_cu_y;
-					else			
-						m_tile[i][j].height = params->p.tile_height[i];
-					m_tile[i][j].start_cu_x = start_cu_x;
-					m_tile[i][j].start_cu_y = start_cu_y;
-					m_tile[i][j].sao_vb_start_addr = hevc->work_space_buf->sao_vb.buf_start + j*sao_vb_size ;
-					m_tile[i][j].sao_abv_start_addr = hevc->work_space_buf->sao_abv.buf_start + i*sao_abv_size ;
-					if(debug&H265_DEBUG_BUFMGR){
-					    printk("{y=%d, x=%d w %d h %d start_x %d start_y %d sao_vb_start 0x%lx sao_abv_start 0x%lx}\n", 
-						    i,j,m_tile[i][j].width,m_tile[i][j].height, m_tile[i][j].start_cu_x, m_tile[i][j].start_cu_y,m_tile[i][j].sao_vb_start_addr, m_tile[i][j].sao_abv_start_addr);
-				  }
-					start_cu_x += m_tile[i][j].width;
-				}
-				start_cu_y += m_tile[i][0].height;
-			}			
-		}
-	}
-	else{
-		hevc->num_tile_col = 1;
-		hevc->num_tile_row = 1;
-		m_tile[0][0].width = pic_width_cu;
-		m_tile[0][0].height = pic_height_cu;
-		m_tile[0][0].start_cu_x = 0;
-		m_tile[0][0].start_cu_y = 0;
-		m_tile[0][0].sao_vb_start_addr = hevc->work_space_buf->sao_vb.buf_start;
-		m_tile[0][0].sao_abv_start_addr = hevc->work_space_buf->sao_abv.buf_start;
-	}
-}
-
-static int get_tile_index(hevc_stru_t* hevc, int cu_adr, int pic_width_lcu)
-{
-	int cu_x;
-	int cu_y;
-	int tile_x = 0;
-	int tile_y = 0;
-	int i;
-	if(pic_width_lcu == 0){
-	    if(debug) printk("%s Error, pic_width_lcu is 0, pic_w %d, pic_h %d\n", __func__, hevc->pic_w, hevc->pic_h);
-	    return -1;
-  }
-	cu_x = cu_adr%pic_width_lcu;
-	cu_y = cu_adr/pic_width_lcu;
-	if(hevc->tile_enabled){	
-		for(i=0;i<hevc->num_tile_col;i++){	
-			if(cu_x>=m_tile[0][i].start_cu_x){
-				tile_x = i;		
-			}
-			else{
-				break;
-			}
-		}
-		for(i=0;i<hevc->num_tile_row;i++){	
-			if(cu_y>=m_tile[i][0].start_cu_y){
-				tile_y = i;		
-			}
-			else{
-				break;
-			}
-		}
-	}
-	return (tile_x)|(tile_y<<8);
-}
-
-static void print_scratch_error(int error_num)
-{
-  if(debug) printk(" ERROR : HEVC_ASSIST_SCRATCH_TEST Error : %d\n", error_num);
-}
-
-static void hevc_config_work_space_hw(hevc_stru_t* hevc)
-{
-    BuffInfo_t* buf_spec = hevc->work_space_buf;
-    
-    if(debug) printk("%s %x %x %x %x %x %x %x %x %x %x %x %x\n", __func__,
-			buf_spec->ipp.buf_start,
-			buf_spec->start_adr,
-			buf_spec->short_term_rps.buf_start,
-			buf_spec->vps.buf_start,
-			buf_spec->sps.buf_start,
-                        buf_spec->pps.buf_start,
-                        buf_spec->sao_up.buf_start,
-                        buf_spec->swap_buf.buf_start,
-			buf_spec->swap_buf2.buf_start,
-			buf_spec->scalelut.buf_start,
-			buf_spec->dblk_para.buf_start,
-			buf_spec->dblk_data.buf_start);
-    WRITE_VREG(HEVCD_IPP_LINEBUFF_BASE,buf_spec->ipp.buf_start);
-    if((debug&H265_DEBUG_SEND_PARAM_WITH_REG)==0){
-        WRITE_VREG(HEVC_RPM_BUFFER, buf_spec->rpm.buf_start);
-    }
-    WRITE_VREG(HEVC_SHORT_TERM_RPS, buf_spec->short_term_rps.buf_start);
-    WRITE_VREG(HEVC_VPS_BUFFER, buf_spec->vps.buf_start);
-    WRITE_VREG(HEVC_SPS_BUFFER, buf_spec->sps.buf_start);
-    WRITE_VREG(HEVC_PPS_BUFFER, buf_spec->pps.buf_start);
-    WRITE_VREG(HEVC_SAO_UP, buf_spec->sao_up.buf_start);
-    WRITE_VREG(HEVC_STREAM_SWAP_BUFFER, buf_spec->swap_buf.buf_start);
-    WRITE_VREG(HEVC_STREAM_SWAP_BUFFER2, buf_spec->swap_buf2.buf_start);
-    WRITE_VREG(HEVC_SCALELUT, buf_spec->scalelut.buf_start);
-
-    WRITE_VREG(HEVC_DBLK_CFG4, buf_spec->dblk_para.buf_start); // cfg_p_addr
-    WRITE_VREG(HEVC_DBLK_CFG5, buf_spec->dblk_data.buf_start); // cfg_d_addr
-    
-    if(debug&H265_DEBUG_UCODE){
-        WRITE_VREG(LMEM_DUMP_ADR, buf_spec->lmem.buf_start);
-    }
-    
-}    
-
-static void hevc_init_decoder_hw(int decode_pic_begin, int decode_pic_num)
-{
-    unsigned int data32;
-    int i;
-
-#if 1
-// m8baby test1902
-    if(debug&H265_DEBUG_BUFMGR) 
-        printk("[test.c] Test Parser Register Read/Write\n");
-    data32 = READ_VREG(HEVC_PARSER_VERSION);
-    if(data32 != 0x00010001) { print_scratch_error(25); return; } 
-    WRITE_VREG(HEVC_PARSER_VERSION, 0x5a5a55aa);
-    data32 = READ_VREG(HEVC_PARSER_VERSION);
-    if(data32 != 0x5a5a55aa) { print_scratch_error(26); return; } 
-
-#if 0
-    // test Parser Reset
-    WRITE_VREG(DOS_SW_RESET3, 
-      (1<<14) | // reset iqit to start mem init again 
-      (1<<3)    // reset_whole parser
-      );
-    WRITE_VREG(DOS_SW_RESET3, 0);      // clear reset_whole parser
-    data32 = READ_VREG(HEVC_PARSER_VERSION);
-    if(data32 != 0x00010001) { 
-        printk("Test Parser Fatal Error\n"); 
-        while(1){};
-    }
-#endif
-
-    WRITE_VREG(DOS_SW_RESET3, 
-      (1<<14)  // reset iqit to start mem init again 
-      );
-    CLEAR_VREG_MASK(HEVC_CABAC_CONTROL, 1);
-    CLEAR_VREG_MASK(HEVC_PARSER_CORE_CONTROL, 1);
-
-#endif
-
-    if(debug&H265_DEBUG_BUFMGR) 
-        printk("[test.c] Enable BitStream Fetch\n");
-    data32 = READ_VREG(HEVC_STREAM_CONTROL);
-    data32 = data32 | 
-             (1 << 0) // stream_fetch_enable
-             ;
-    WRITE_VREG(HEVC_STREAM_CONTROL, data32);
-
-    data32 = READ_VREG(HEVC_SHIFT_STARTCODE);
-    if(data32 != 0x00000100) { print_scratch_error(29); return; } 
-    data32 = READ_VREG(HEVC_SHIFT_EMULATECODE);
-    if(data32 != 0x00000300) { print_scratch_error(30); return; } 
-    WRITE_VREG(HEVC_SHIFT_STARTCODE, 0x12345678);
-    WRITE_VREG(HEVC_SHIFT_EMULATECODE, 0x9abcdef0);
-    data32 = READ_VREG(HEVC_SHIFT_STARTCODE);
-    if(data32 != 0x12345678) { print_scratch_error(31); return; } 
-    data32 = READ_VREG(HEVC_SHIFT_EMULATECODE);
-    if(data32 != 0x9abcdef0) { print_scratch_error(32); return; } 
-    WRITE_VREG(HEVC_SHIFT_STARTCODE, 0x00000100);
-    WRITE_VREG(HEVC_SHIFT_EMULATECODE, 0x00000300);
-
-    if(debug&H265_DEBUG_BUFMGR) 
-        printk("[test.c] Enable HEVC Parser Interrupt\n");
-    data32 = READ_VREG(HEVC_PARSER_INT_CONTROL);
-    data32 = data32 | 
-             (1 << 24) |  // stream_buffer_empty_int_amrisc_enable
-             (1 << 22) |  // stream_fifo_empty_int_amrisc_enable
-             (1 << 7) |  // dec_done_int_cpu_enable
-             (1 << 4) |  // startcode_found_int_cpu_enable
-             (0 << 3) |  // startcode_found_int_amrisc_enable
-             (1 << 0)    // parser_int_enable
-             ;
-    WRITE_VREG(HEVC_PARSER_INT_CONTROL, data32);
-
-    if(debug&H265_DEBUG_BUFMGR) 
-        printk("[test.c] Enable HEVC Parser Shift\n");
-
-    data32 = READ_VREG(HEVC_SHIFT_STATUS);
-    data32 = data32 | 
-             (1 << 1) |  // emulation_check_on
-             (1 << 0)    // startcode_check_on
-             ;
-    WRITE_VREG(HEVC_SHIFT_STATUS, data32);
-
-    WRITE_VREG(HEVC_SHIFT_CONTROL, 
-              (3 << 6) | // sft_valid_wr_position
-              (2 << 4) | // emulate_code_length_sub_1
-              (2 << 1) | // start_code_length_sub_1
-              (1 << 0)   // stream_shift_enable
-            );
-
-    WRITE_VREG(HEVC_CABAC_CONTROL, 
-              (1 << 0)   // cabac_enable
-            );
-
-    WRITE_VREG(HEVC_PARSER_CORE_CONTROL, 
-              (1 << 0)   // hevc_parser_core_clk_en
-            );
-
-
-    WRITE_VREG(HEVC_DEC_STATUS_REG, 0);
-
-    // Initial IQIT_SCALELUT memory -- just to avoid X in simulation
-    if(debug&H265_DEBUG_BUFMGR) 
-        printk("[test.c] Initial IQIT_SCALELUT memory -- just to avoid X in simulation...\n");
-    WRITE_VREG(HEVC_IQIT_SCALELUT_WR_ADDR, 0); // cfg_p_addr
-    for(i=0; i<1024; i++) WRITE_VREG(HEVC_IQIT_SCALELUT_DATA, 0);
-
-
-#ifdef ENABLE_SWAP_TEST
-    WRITE_VREG(HEVC_STREAM_SWAP_TEST, 100);
-#else
-    WRITE_VREG(HEVC_STREAM_SWAP_TEST, 0);
-#endif
-
-    WRITE_VREG(HEVC_DECODE_PIC_BEGIN_REG, 0);
-    WRITE_VREG(HEVC_DECODE_PIC_NUM_REG, 0xffffffff);
-
-    // Send parser_cmd
-    if(debug) printk("[test.c] SEND Parser Command ...\n");
-    WRITE_VREG(HEVC_PARSER_CMD_WRITE, (1<<16) | (0<<0));
-    for(i=0; i<PARSER_CMD_NUMBER; i++){
-      WRITE_VREG(HEVC_PARSER_CMD_WRITE, parser_cmd[i]);
-    }
-
-    WRITE_VREG(HEVC_PARSER_CMD_SKIP_0, PARSER_CMD_SKIP_CFG_0);
-    WRITE_VREG(HEVC_PARSER_CMD_SKIP_1, PARSER_CMD_SKIP_CFG_1);
-    WRITE_VREG(HEVC_PARSER_CMD_SKIP_2, PARSER_CMD_SKIP_CFG_2);
-
-    WRITE_VREG(HEVC_PARSER_IF_CONTROL, 
-            //  (1 << 8) | // sao_sw_pred_enable
-              (1 << 5) | // parser_sao_if_en
-              (1 << 2) | // parser_mpred_if_en
-              (1 << 0) // parser_scaler_if_en
-            );
-
-    // Changed to Start MPRED in microcode
-    /*
-    printk("[test.c] Start MPRED\n");
-    WRITE_VREG(HEVC_MPRED_INT_STATUS,
-            (1<<31)
-        ); 
-    */
-
-    if(debug) printk("[test.c] Reset IPP\n");
-    WRITE_VREG(HEVCD_IPP_TOP_CNTL, 
-              (0 << 1) | // enable ipp
-              (1 << 0)   // software reset ipp and mpp
-            );
-    WRITE_VREG(HEVCD_IPP_TOP_CNTL, 
-              (1 << 1) | // enable ipp
-              (0 << 0)   // software reset ipp and mpp
-            );
-}
-
-static void decoder_hw_reset(void)
-{
-    int i;
-    unsigned int data32;
-    WRITE_VREG(DOS_SW_RESET3, 
-      (1<<14)  // reset iqit to start mem init again 
-      );
-    CLEAR_VREG_MASK(HEVC_CABAC_CONTROL, 1);
-    CLEAR_VREG_MASK(HEVC_PARSER_CORE_CONTROL, 1);
-
-
-    data32 = READ_VREG(HEVC_STREAM_CONTROL);
-    data32 = data32 | 
-             (1 << 0) // stream_fetch_enable
-             ;
-    WRITE_VREG(HEVC_STREAM_CONTROL, data32);
-
-    data32 = READ_VREG(HEVC_SHIFT_STARTCODE);
-    if(data32 != 0x00000100) { print_scratch_error(29); return; } 
-    data32 = READ_VREG(HEVC_SHIFT_EMULATECODE);
-    if(data32 != 0x00000300) { print_scratch_error(30); return; } 
-    WRITE_VREG(HEVC_SHIFT_STARTCODE, 0x12345678);
-    WRITE_VREG(HEVC_SHIFT_EMULATECODE, 0x9abcdef0);
-    data32 = READ_VREG(HEVC_SHIFT_STARTCODE);
-    if(data32 != 0x12345678) { print_scratch_error(31); return; } 
-    data32 = READ_VREG(HEVC_SHIFT_EMULATECODE);
-    if(data32 != 0x9abcdef0) { print_scratch_error(32); return; } 
-    WRITE_VREG(HEVC_SHIFT_STARTCODE, 0x00000100);
-    WRITE_VREG(HEVC_SHIFT_EMULATECODE, 0x00000300);
-
-    data32 = READ_VREG(HEVC_PARSER_INT_CONTROL);
-    data32 = data32 | 
-             (1 << 24) |  // stream_buffer_empty_int_amrisc_enable
-             (1 << 22) |  // stream_fifo_empty_int_amrisc_enable
-             (1 << 7) |  // dec_done_int_cpu_enable
-             (1 << 4) |  // startcode_found_int_cpu_enable
-             (0 << 3) |  // startcode_found_int_amrisc_enable
-             (1 << 0)    // parser_int_enable
-             ;
-    WRITE_VREG(HEVC_PARSER_INT_CONTROL, data32);
-
-    data32 = READ_VREG(HEVC_SHIFT_STATUS);
-    data32 = data32 | 
-             (1 << 1) |  // emulation_check_on
-             (1 << 0)    // startcode_check_on
-             ;
-    WRITE_VREG(HEVC_SHIFT_STATUS, data32);
-
-    WRITE_VREG(HEVC_SHIFT_CONTROL, 
-              (3 << 6) | // sft_valid_wr_position
-              (2 << 4) | // emulate_code_length_sub_1
-              (2 << 1) | // start_code_length_sub_1
-              (1 << 0)   // stream_shift_enable
-            );
-
-    WRITE_VREG(HEVC_CABAC_CONTROL, 
-              (1 << 0)   // cabac_enable
-            );
-
-    WRITE_VREG(HEVC_PARSER_CORE_CONTROL, 
-              (1 << 0)   // hevc_parser_core_clk_en
-            );
-
-
-    // Initial IQIT_SCALELUT memory -- just to avoid X in simulation
-    WRITE_VREG(HEVC_IQIT_SCALELUT_WR_ADDR, 0); // cfg_p_addr
-    for(i=0; i<1024; i++) WRITE_VREG(HEVC_IQIT_SCALELUT_DATA, 0);
-
-
-    // Send parser_cmd
-    WRITE_VREG(HEVC_PARSER_CMD_WRITE, (1<<16) | (0<<0));
-    for(i=0; i<PARSER_CMD_NUMBER; i++){
-      WRITE_VREG(HEVC_PARSER_CMD_WRITE, parser_cmd[i]);
-    }
-
-    WRITE_VREG(HEVC_PARSER_CMD_SKIP_0, PARSER_CMD_SKIP_CFG_0);
-    WRITE_VREG(HEVC_PARSER_CMD_SKIP_1, PARSER_CMD_SKIP_CFG_1);
-    WRITE_VREG(HEVC_PARSER_CMD_SKIP_2, PARSER_CMD_SKIP_CFG_2);
-
-    WRITE_VREG(HEVC_PARSER_IF_CONTROL, 
-            //  (1 << 8) | // sao_sw_pred_enable
-              (1 << 5) | // parser_sao_if_en
-              (1 << 2) | // parser_mpred_if_en
-              (1 << 0) // parser_scaler_if_en
-            );
-
-    WRITE_VREG(HEVCD_IPP_TOP_CNTL, 
-              (0 << 1) | // enable ipp
-              (1 << 0)   // software reset ipp and mpp
-            );
-    WRITE_VREG(HEVCD_IPP_TOP_CNTL, 
-              (1 << 1) | // enable ipp
-              (0 << 0)   // software reset ipp and mpp
-            );
-}
-
-#ifdef CONFIG_HEVC_CLK_FORCED_ON
-static void config_hevc_clk_forced_on ()
-{
-    unsigned int rdata32;
-    // IQIT
-    rdata32 = READ_VREG(HEVC_IQIT_CLK_RST_CTRL);
-    WRITE_VREG(HEVC_IQIT_CLK_RST_CTRL, rdata32 | (0x1<<2));
-
-    // DBLK
-    rdata32 = READ_VREG(HEVC_DBLK_CFG0);
-    WRITE_VREG(HEVC_DBLK_CFG0, rdata32 | (0x1<<2));
-
-    // SAO
-    rdata32 = READ_VREG(HEVC_SAO_CTRL1);
-    WRITE_VREG(HEVC_SAO_CTRL1, rdata32 | (0x1<<2));
-
-    // MPRED
-    rdata32 = READ_VREG(HEVC_MPRED_CTRL1);
-    WRITE_VREG(HEVC_MPRED_CTRL1, rdata32 | (0x1<<24));
-
-    // PARSER
-    rdata32 = READ_VREG(HEVC_STREAM_CONTROL);
-    WRITE_VREG(HEVC_STREAM_CONTROL, rdata32 | (0x1<<15));
-    rdata32 = READ_VREG(HEVC_SHIFT_CONTROL);
-    WRITE_VREG(HEVC_SHIFT_CONTROL, rdata32 | (0x1<<15));
-    rdata32 = READ_VREG(HEVC_CABAC_CONTROL);
-    WRITE_VREG(HEVC_CABAC_CONTROL, rdata32 | (0x1<<13));
-    rdata32 = READ_VREG(HEVC_PARSER_CORE_CONTROL);
-    WRITE_VREG(HEVC_PARSER_CORE_CONTROL, rdata32 | (0x1<<15));
-    rdata32 = READ_VREG(HEVC_PARSER_INT_CONTROL);
-    WRITE_VREG(HEVC_PARSER_INT_CONTROL, rdata32 | (0x1<<15));
-    rdata32 = READ_VREG(HEVC_PARSER_IF_CONTROL);
-    WRITE_VREG(HEVC_PARSER_IF_CONTROL, rdata32 | (0x3<<5) | (0x3<<2) | (0x3<<0));
-
-    // IPP
-    rdata32 = READ_VREG(HEVCD_IPP_DYNCLKGATE_CONFIG);
-    WRITE_VREG(HEVCD_IPP_DYNCLKGATE_CONFIG, rdata32 | 0xffffffff);
-
-    // MCRCC
-    rdata32 = READ_VREG(HEVCD_MCRCC_CTL1);
-    WRITE_VREG(HEVCD_MCRCC_CTL1, rdata32 | (0x1<<3));
-}
-#endif
-
-#ifdef MCRCC_ENABLE
-static void  config_mcrcc_axi_hw (int slice_type)
-{
-    unsigned int rdata32;
-    unsigned int rdata32_2;
-
-    WRITE_VREG(HEVCD_MCRCC_CTL1, 0x2); // reset mcrcc
-    
-    if ( slice_type  == 2 ) { // I-PIC
-        WRITE_VREG(HEVCD_MCRCC_CTL1, 0x0); // remove reset -- disables clock 
-        return;
-    }
-
-    if ( slice_type == 0 ) {  // B-PIC
-        // Programme canvas0 
-        WRITE_VREG(HEVCD_MPP_ANC_CANVAS_ACCCONFIG_ADDR, (0 << 8) | (0<<1) | 0);
-        rdata32 = READ_VREG(HEVCD_MPP_ANC_CANVAS_DATA_ADDR);
-        rdata32 = rdata32 & 0xffff;
-        rdata32 = rdata32 | ( rdata32 << 16);
-        WRITE_VREG(HEVCD_MCRCC_CTL2, rdata32);
-   
-        // Programme canvas1 
-        WRITE_VREG(HEVCD_MPP_ANC_CANVAS_ACCCONFIG_ADDR, (16 << 8) | (1<<1) | 0);
-        rdata32_2 = READ_VREG(HEVCD_MPP_ANC_CANVAS_DATA_ADDR);
-        rdata32_2 = rdata32_2 & 0xffff;
-        rdata32_2 = rdata32_2 | ( rdata32_2 << 16);
-        if( rdata32 == rdata32_2 ) {
-            rdata32_2 = READ_VREG(HEVCD_MPP_ANC_CANVAS_DATA_ADDR);
-            rdata32_2 = rdata32_2 & 0xffff;
-            rdata32_2 = rdata32_2 | ( rdata32_2 << 16);
-        }
-        WRITE_VREG(HEVCD_MCRCC_CTL3, rdata32_2);
-    } else { // P-PIC 
-        WRITE_VREG(HEVCD_MPP_ANC_CANVAS_ACCCONFIG_ADDR, (0 << 8) | (1<<1) | 0);
-        rdata32 = READ_VREG(HEVCD_MPP_ANC_CANVAS_DATA_ADDR);
-        rdata32 = rdata32 & 0xffff;
-        rdata32 = rdata32 | ( rdata32 << 16);
-        WRITE_VREG(HEVCD_MCRCC_CTL2, rdata32);
-   
-        // Programme canvas1 
-        rdata32 = READ_VREG(HEVCD_MPP_ANC_CANVAS_DATA_ADDR);
-        rdata32 = rdata32 & 0xffff;
-        rdata32 = rdata32 | ( rdata32 << 16);
-        WRITE_VREG(HEVCD_MCRCC_CTL3, rdata32);
-    }
-
-    WRITE_VREG(HEVCD_MCRCC_CTL1, 0xff0); // enable mcrcc progressive-mode 
-    return;
-}
-#endif
-
-
-static void  config_title_hw(hevc_stru_t* hevc, int sao_vb_size, int sao_mem_unit)
-{
-	WRITE_VREG(HEVC_sao_mem_unit, sao_mem_unit);
-	WRITE_VREG(HEVC_SAO_ABV, hevc->work_space_buf->sao_abv.buf_start);
-	WRITE_VREG(HEVC_sao_vb_size, sao_vb_size);
-	WRITE_VREG(HEVC_SAO_VB, hevc->work_space_buf->sao_vb.buf_start);
-}
-
-static void config_mpred_hw(hevc_stru_t* hevc)
-{
-    int i;
-    unsigned int data32;
-    PIC_t* cur_pic = hevc->cur_pic;
-    PIC_t* col_pic = hevc->col_pic;
-    int     AMVP_MAX_NUM_CANDS_MEM=3;
-    int     AMVP_MAX_NUM_CANDS=2;
-    int     NUM_CHROMA_MODE=5;
-    int     DM_CHROMA_IDX=36;
-    int     above_ptr_ctrl =0;
-    int     buffer_linear =1;
-    int     cu_size_log2 =3;
-
-    int     mpred_mv_rd_start_addr ;
-    int     mpred_curr_lcu_x;
-    int     mpred_curr_lcu_y;
-    int     mpred_above_buf_start ;
-    int     mpred_mv_rd_ptr ;
-    int     mpred_mv_rd_ptr_p1 ;
-    int     mpred_mv_rd_end_addr;
-    int     MV_MEM_UNIT;
-    int     mpred_mv_wr_ptr ;
-    int     *ref_poc_L0, *ref_poc_L1;
-
-    int     above_en;
-    int     mv_wr_en;
-    int     mv_rd_en;
-    int     col_isIntra;
-    if(hevc->slice_type!=2)
-    {
-        above_en=1;
-        mv_wr_en=1;
-        mv_rd_en=1;
-        col_isIntra=0;
-    }
-    else 
-    {
-        above_en=1;
-        mv_wr_en=1;
-        mv_rd_en=0;
-        col_isIntra=0;
-    }
-
-    mpred_mv_rd_start_addr=col_pic->mpred_mv_wr_start_addr;
-    data32 = READ_VREG(HEVC_MPRED_CURR_LCU);
-    mpred_curr_lcu_x   =data32 & 0xffff;
-    mpred_curr_lcu_y   =(data32>>16) & 0xffff;
-    
-    MV_MEM_UNIT=hevc->lcu_size_log2==6 ? 0x200 : hevc->lcu_size_log2==5 ? 0x80 : 0x20;
-    mpred_mv_rd_ptr = mpred_mv_rd_start_addr  + (hevc->slice_addr*MV_MEM_UNIT);
-    
-    mpred_mv_rd_ptr_p1  =mpred_mv_rd_ptr+MV_MEM_UNIT;
-    mpred_mv_rd_end_addr=mpred_mv_rd_start_addr + ((hevc->lcu_x_num*hevc->lcu_y_num)*MV_MEM_UNIT);
-    
-    mpred_above_buf_start = hevc->work_space_buf->mpred_above.buf_start;
-    
-    mpred_mv_wr_ptr = cur_pic->mpred_mv_wr_start_addr  + (hevc->slice_addr*MV_MEM_UNIT);
-    
-    if(debug&H265_DEBUG_BUFMGR) 
-        printk("cur pic index %d  col pic index %d\n", cur_pic->index, col_pic->index);
-    
-    WRITE_VREG(HEVC_MPRED_MV_WR_START_ADDR,cur_pic->mpred_mv_wr_start_addr);
-    WRITE_VREG(HEVC_MPRED_MV_RD_START_ADDR,mpred_mv_rd_start_addr);
-    
-    data32 = ((hevc->lcu_x_num - hevc->tile_width_lcu)*MV_MEM_UNIT);
-    WRITE_VREG(HEVC_MPRED_MV_WR_ROW_JUMP,data32);
-    WRITE_VREG(HEVC_MPRED_MV_RD_ROW_JUMP,data32);
-    
-    data32 = READ_VREG(HEVC_MPRED_CTRL0);
-    data32  =   ( 
-        hevc->slice_type | 
-        hevc->new_pic<<2 |
-        hevc->new_tile<<3|
-        hevc->isNextSliceSegment<<4|
-        hevc->TMVPFlag<<5|
-        hevc->LDCFlag<<6|
-        hevc->ColFromL0Flag<<7|
-        above_ptr_ctrl<<8 |  
-        above_en<<9|
-        mv_wr_en<<10|
-        mv_rd_en<<11|
-        col_isIntra<<12|
-        buffer_linear<<13|
-        hevc->LongTerm_Curr<<14|
-        hevc->LongTerm_Col<<15|
-        hevc->lcu_size_log2<<16|
-        cu_size_log2<<20|
-        hevc->plevel<<24 
-        );
-    WRITE_VREG(HEVC_MPRED_CTRL0,data32);
-    
-    data32 = READ_VREG(HEVC_MPRED_CTRL1);
-    data32  =   ( 
-#if 0
-//no set in m8baby test1902
-       (data32 & (0x1<<24)) |  // Don't override clk_forced_on , 
-#endif       
-        hevc->MaxNumMergeCand | 
-        AMVP_MAX_NUM_CANDS<<4 |
-        AMVP_MAX_NUM_CANDS_MEM<<8|
-        NUM_CHROMA_MODE<<12|
-        DM_CHROMA_IDX<<16
-        );
-    WRITE_VREG(HEVC_MPRED_CTRL1,data32);
-    
-    data32  =   (
-          hevc->pic_w|
-          hevc->pic_h<<16   
-          );
-    WRITE_VREG(HEVC_MPRED_PIC_SIZE,data32);
-    
-    data32  =   (
-          (hevc->lcu_x_num-1)   |
-          (hevc->lcu_y_num-1)<<16
-          );
-    WRITE_VREG(HEVC_MPRED_PIC_SIZE_LCU,data32);
-    
-    data32  =   (
-          hevc->tile_start_lcu_x   |
-          hevc->tile_start_lcu_y<<16
-          );
-    WRITE_VREG(HEVC_MPRED_TILE_START,data32);
-    
-    data32  =   (
-          hevc->tile_width_lcu   |
-          hevc->tile_height_lcu<<16
-          );
-    WRITE_VREG(HEVC_MPRED_TILE_SIZE_LCU,data32);
-    
-    data32  =   (
-          hevc->RefNum_L0   |
-          hevc->RefNum_L1<<8|
-          0
-          //col_RefNum_L0<<16|
-          //col_RefNum_L1<<24
-          );
-    WRITE_VREG(HEVC_MPRED_REF_NUM,data32);
-    
-    data32  =   (
-          hevc->LongTerm_Ref   
-          );
-    WRITE_VREG(HEVC_MPRED_LT_REF,data32);
-    
-    
-    data32=0;
-    for(i=0;i<hevc->RefNum_L0;i++)data32=data32|(1<<i);
-    WRITE_VREG(HEVC_MPRED_REF_EN_L0,data32);
-    
-    data32=0;
-    for(i=0;i<hevc->RefNum_L1;i++)data32=data32|(1<<i);
-    WRITE_VREG(HEVC_MPRED_REF_EN_L1,data32);
-    
-    
-    WRITE_VREG(HEVC_MPRED_CUR_POC,hevc->curr_POC);
-    WRITE_VREG(HEVC_MPRED_COL_POC,hevc->Col_POC);
-    
-    //below MPRED Ref_POC_xx_Lx registers must follow Ref_POC_xx_L0 -> Ref_POC_xx_L1 in pair write order!!!
-    ref_poc_L0      = &(cur_pic->m_aiRefPOCList0[cur_pic->slice_idx][0]);
-    ref_poc_L1      = &(cur_pic->m_aiRefPOCList1[cur_pic->slice_idx][0]);
-
-    WRITE_VREG(HEVC_MPRED_L0_REF00_POC,ref_poc_L0[0]);
-    WRITE_VREG(HEVC_MPRED_L1_REF00_POC,ref_poc_L1[0]);
-    
-    WRITE_VREG(HEVC_MPRED_L0_REF01_POC,ref_poc_L0[1]);
-    WRITE_VREG(HEVC_MPRED_L1_REF01_POC,ref_poc_L1[1]);
-    
-    WRITE_VREG(HEVC_MPRED_L0_REF02_POC,ref_poc_L0[2]);
-    WRITE_VREG(HEVC_MPRED_L1_REF02_POC,ref_poc_L1[2]);
-    
-    WRITE_VREG(HEVC_MPRED_L0_REF03_POC,ref_poc_L0[3]);
-    WRITE_VREG(HEVC_MPRED_L1_REF03_POC,ref_poc_L1[3]);
-    
-    WRITE_VREG(HEVC_MPRED_L0_REF04_POC,ref_poc_L0[4]);
-    WRITE_VREG(HEVC_MPRED_L1_REF04_POC,ref_poc_L1[4]);
-    
-    WRITE_VREG(HEVC_MPRED_L0_REF05_POC,ref_poc_L0[5]);
-    WRITE_VREG(HEVC_MPRED_L1_REF05_POC,ref_poc_L1[5]);
-    
-    WRITE_VREG(HEVC_MPRED_L0_REF06_POC,ref_poc_L0[6]);
-    WRITE_VREG(HEVC_MPRED_L1_REF06_POC,ref_poc_L1[6]);
-    
-    WRITE_VREG(HEVC_MPRED_L0_REF07_POC,ref_poc_L0[7]);
-    WRITE_VREG(HEVC_MPRED_L1_REF07_POC,ref_poc_L1[7]);
-    
-    WRITE_VREG(HEVC_MPRED_L0_REF08_POC,ref_poc_L0[8]);
-    WRITE_VREG(HEVC_MPRED_L1_REF08_POC,ref_poc_L1[8]);
-    
-    WRITE_VREG(HEVC_MPRED_L0_REF09_POC,ref_poc_L0[9]);
-    WRITE_VREG(HEVC_MPRED_L1_REF09_POC,ref_poc_L1[9]);
-    
-    WRITE_VREG(HEVC_MPRED_L0_REF10_POC,ref_poc_L0[10]);
-    WRITE_VREG(HEVC_MPRED_L1_REF10_POC,ref_poc_L1[10]);
-    
-    WRITE_VREG(HEVC_MPRED_L0_REF11_POC,ref_poc_L0[11]);
-    WRITE_VREG(HEVC_MPRED_L1_REF11_POC,ref_poc_L1[11]);
-    
-    WRITE_VREG(HEVC_MPRED_L0_REF12_POC,ref_poc_L0[12]);
-    WRITE_VREG(HEVC_MPRED_L1_REF12_POC,ref_poc_L1[12]);
-    
-    WRITE_VREG(HEVC_MPRED_L0_REF13_POC,ref_poc_L0[13]);
-    WRITE_VREG(HEVC_MPRED_L1_REF13_POC,ref_poc_L1[13]);
-    
-    WRITE_VREG(HEVC_MPRED_L0_REF14_POC,ref_poc_L0[14]);
-    WRITE_VREG(HEVC_MPRED_L1_REF14_POC,ref_poc_L1[14]);
-    
-    WRITE_VREG(HEVC_MPRED_L0_REF15_POC,ref_poc_L0[15]);
-    WRITE_VREG(HEVC_MPRED_L1_REF15_POC,ref_poc_L1[15]);
-    
-    
-    if(hevc->new_pic)
-    {
-        WRITE_VREG(HEVC_MPRED_ABV_START_ADDR,mpred_above_buf_start);
-        WRITE_VREG(HEVC_MPRED_MV_WPTR,mpred_mv_wr_ptr);
-        //WRITE_VREG(HEVC_MPRED_MV_RPTR,mpred_mv_rd_ptr);
-        WRITE_VREG(HEVC_MPRED_MV_RPTR,mpred_mv_rd_start_addr);
-    }
-    else if(!hevc->isNextSliceSegment)
-    {
-        //WRITE_VREG(HEVC_MPRED_MV_RPTR,mpred_mv_rd_ptr_p1);
-        WRITE_VREG(HEVC_MPRED_MV_RPTR,mpred_mv_rd_ptr);
-    }
-    
-    WRITE_VREG(HEVC_MPRED_MV_RD_END_ADDR,mpred_mv_rd_end_addr);
-}
-
-static void config_sao_hw(hevc_stru_t* hevc, param_t* params)
-{
-    unsigned int data32, data32_2;
-    int misc_flag0 = hevc->misc_flag0; 
-    int slice_deblocking_filter_disabled_flag = 0;
-               
-    int mc_buffer_size_u_v = hevc->lcu_total*hevc->lcu_size*hevc->lcu_size/2;
-    int mc_buffer_size_u_v_h = (mc_buffer_size_u_v + 0xffff)>>16;
-    PIC_t* cur_pic = hevc->cur_pic;
-            
-    data32 = READ_VREG(HEVC_SAO_CTRL0);	
-    data32 &= (~0xf);
-    data32 |= hevc->lcu_size_log2;
-    WRITE_VREG(HEVC_SAO_CTRL0, data32);
-
-    data32  =   (
-            hevc->pic_w|
-            hevc->pic_h<<16   
-            );
-    WRITE_VREG(HEVC_SAO_PIC_SIZE , data32);
-
-    data32  =   (
-            (hevc->lcu_x_num-1)   |
-            (hevc->lcu_y_num-1)<<16
-            );
-    WRITE_VREG(HEVC_SAO_PIC_SIZE_LCU , data32);
-    
-    if(hevc->new_pic) WRITE_VREG(HEVC_SAO_Y_START_ADDR,0xffffffff);
-    data32 = cur_pic->mc_y_adr;
-    WRITE_VREG(HEVC_SAO_Y_START_ADDR,data32);
-    
-    data32 = (mc_buffer_size_u_v_h<<16)<<1;
-    //printk("data32 = %x, mc_buffer_size_u_v_h = %x, lcu_total = %x, lcu_size = %x\n", data32, mc_buffer_size_u_v_h, lcu_total, lcu_size);
-    WRITE_VREG(HEVC_SAO_Y_LENGTH ,data32);
-
-    data32 = cur_pic->mc_u_v_adr;
-    WRITE_VREG(HEVC_SAO_C_START_ADDR,data32);
-
-    data32 = (mc_buffer_size_u_v_h<<16);
-    WRITE_VREG(HEVC_SAO_C_LENGTH  ,data32);
-
-    /* multi tile to do... */
-    data32 = cur_pic->mc_y_adr;
-    WRITE_VREG(HEVC_SAO_Y_WPTR ,data32);
-
-    data32 = cur_pic->mc_u_v_adr;
-    WRITE_VREG(HEVC_SAO_C_WPTR ,data32);
-    
-    // DBLK CONFIG HERE
-    if(hevc->new_pic){
-        data32  =   (
-            hevc->pic_w|
-            hevc->pic_h<<16   
-        );
-        WRITE_VREG( HEVC_DBLK_CFG2, data32);
-        
-        if((misc_flag0>>PCM_ENABLE_FLAG_BIT)&0x1)
-            data32 = ((misc_flag0>>PCM_LOOP_FILTER_DISABLED_FLAG_BIT)&0x1)<<3;
-        else data32 = 0;
-        data32 |= (((params->p.pps_cb_qp_offset&0x1f)<<4)|((params->p.pps_cr_qp_offset&0x1f)<<9));
-        data32 |= (hevc->lcu_size==64)?0:((hevc->lcu_size==32)?1:2);
-        
-        WRITE_VREG( HEVC_DBLK_CFG1, data32);
-    }
-
-#if 0
-    data32 = READ_VREG( HEVC_SAO_CTRL1);
-    data32 &= (~0x3000);
-    data32 |= (MEM_MAP_MODE << 12); // [13:12] axi_aformat, 0-Linear, 1-32x32, 2-64x32
-    WRITE_VREG( HEVC_SAO_CTRL1, data32);
-    
-    data32 = READ_VREG( HEVCD_IPP_AXIIF_CONFIG);
-    data32 &= (~0x30);
-    data32 |= (MEM_MAP_MODE << 4); // [5:4]    -- address_format 00:linear 01:32x32 10:64x32
-    WRITE_VREG( HEVCD_IPP_AXIIF_CONFIG, data32);
-#else
-// m8baby test1902
-   data32 = READ_VREG( HEVC_SAO_CTRL1);
-	data32 &= (~0x3000);
-	data32 |= (MEM_MAP_MODE << 12); // [13:12] axi_aformat, 0-Linear, 1-32x32, 2-64x32
-    data32 &= (~0xff0);
-    //data32 |= 0x670;  // Big-Endian per 64-bit
-    data32 |= 0x880;  // Big-Endian per 64-bit
-    WRITE_VREG( HEVC_SAO_CTRL1, data32);
-
-    data32 = READ_VREG( HEVCD_IPP_AXIIF_CONFIG);
-	data32 &= (~0x30);
-	data32 |= (MEM_MAP_MODE << 4); // [5:4]    -- address_format 00:linear 01:32x32 10:64x32
-	data32 &= (~0xF);
-    data32 |= 0x8;    // Big-Endian per 64-bit
-    WRITE_VREG( HEVCD_IPP_AXIIF_CONFIG, data32);
-#endif    
-    data32 = 0;	
-    data32_2 = READ_VREG( HEVC_SAO_CTRL0);
-    data32_2 &= (~0x300);
-    //slice_deblocking_filter_disabled_flag = 0; //ucode has handle it , so read it from ucode directly
-    //printk("\nconfig dblk HEVC_DBLK_CFG9: misc_flag0 %x tile_enabled %x; data32 is:", misc_flag0, tile_enabled);
-    if(hevc->tile_enabled) {
-        data32 |= ((misc_flag0>>LOOP_FILER_ACROSS_TILES_ENABLED_FLAG_BIT)&0x1)<<0;
-        data32_2 |= ((misc_flag0>>LOOP_FILER_ACROSS_TILES_ENABLED_FLAG_BIT)&0x1)<<8;
-    }
-    slice_deblocking_filter_disabled_flag =	(misc_flag0>>SLICE_DEBLOCKING_FILTER_DISABLED_FLAG_BIT)&0x1;	//ucode has handle it , so read it from ucode directly
-    if((misc_flag0&(1<<DEBLOCKING_FILTER_OVERRIDE_ENABLED_FLAG_BIT))
-        &&(misc_flag0&(1<<DEBLOCKING_FILTER_OVERRIDE_FLAG_BIT))){
-        //slice_deblocking_filter_disabled_flag =	(misc_flag0>>SLICE_DEBLOCKING_FILTER_DISABLED_FLAG_BIT)&0x1;	//ucode has handle it , so read it from ucode directly
-        data32 |= slice_deblocking_filter_disabled_flag<<2;
-        if(debug&H265_DEBUG_BUFMGR) printk("(1,%x)", data32);
-        if(!slice_deblocking_filter_disabled_flag){
-            data32 |= (params->p.slice_beta_offset_div2&0xf)<<3;
-            data32 |= (params->p.slice_tc_offset_div2&0xf)<<7;
-            if(debug&H265_DEBUG_BUFMGR) printk("(2,%x)", data32);
-        }
-    }
-    else{
-        data32 |= ((misc_flag0>>PPS_DEBLOCKING_FILTER_DISABLED_FLAG_BIT)&0x1)<<2;
-        if(debug&H265_DEBUG_BUFMGR) printk("(3,%x)", data32);
-        if(((misc_flag0>>PPS_DEBLOCKING_FILTER_DISABLED_FLAG_BIT)&0x1)==0){
-            data32 |= (params->p.pps_beta_offset_div2&0xf)<<3;
-            data32 |= (params->p.pps_tc_offset_div2&0xf)<<7;
-            if(debug&H265_DEBUG_BUFMGR) printk("(4,%x)", data32);
-        }
-    }
-    if((misc_flag0&(1<<PPS_LOOP_FILTER_ACROSS_SLICES_ENABLED_FLAG_BIT))&&
-       ((misc_flag0&(1<<SLICE_SAO_LUMA_FLAG_BIT))||(misc_flag0&(1<<SLICE_SAO_CHROMA_FLAG_BIT))||(!slice_deblocking_filter_disabled_flag))) {
-        data32 |= ((misc_flag0>>SLICE_LOOP_FILTER_ACROSS_SLICES_ENABLED_FLAG_BIT)&0x1)<<1;
-        data32_2 |= ((misc_flag0>>SLICE_LOOP_FILTER_ACROSS_SLICES_ENABLED_FLAG_BIT)&0x1)<<9;
-        if(debug&H265_DEBUG_BUFMGR) printk("(5,%x)\n", data32);
-    }
-    else{
-        data32 |= ((misc_flag0>>PPS_LOOP_FILTER_ACROSS_SLICES_ENABLED_FLAG_BIT)&0x1)<<1;
-        data32_2 |= ((misc_flag0>>PPS_LOOP_FILTER_ACROSS_SLICES_ENABLED_FLAG_BIT)&0x1)<<9;
-        if(debug&H265_DEBUG_BUFMGR) printk("(6,%x)\n", data32);
-    }
-    WRITE_VREG( HEVC_DBLK_CFG9, data32);
-    WRITE_VREG( HEVC_SAO_CTRL0, data32_2);
-}                
-
-static PIC_t* get_new_pic(hevc_stru_t* hevc, param_t* rpm_param)
-{
-    PIC_t* new_pic;
-    PIC_t* pic;
-    new_pic = out_q(&hevc->free_pic_list);
-    if(new_pic == NULL){
-        /* recycle un-used pic */
-        int ii = 0;
-      
-        while(1){
-            pic = get_pic_by_IDX(hevc, ii++);
-            if(pic == NULL)
-                break;
-            if(pic->output_mark == 0 && pic->referenced == 0
-                    && pic->output_ready == 0
-                ){
-                if(new_pic){
-                    if(pic->POC < new_pic->POC)
-                        new_pic = pic;
-                }
-                else{
-                    new_pic = pic;
-                }
-            }
-        }
-        if(new_pic == NULL){
-            //printk("Error: Buffer management, no free buffer\n");
-            return NULL;
-        }
-    }
-    else{
-        in_q(&hevc->decode_pic_list, new_pic);
-    }
-    new_pic->decode_idx = hevc->decode_idx;
-    new_pic->slice_idx = 0;
-    new_pic->referenced = 1;
-    new_pic->output_mark = 0;
-    new_pic->recon_mark = 0;
-    new_pic->error_mark = 0;
-    //new_pic->output_ready = 0;
-    new_pic->num_reorder_pic = rpm_param->p.sps_num_reorder_pics_0;
-    new_pic->POC = hevc->curr_POC;
-    return new_pic;
-}
-
-static int get_display_pic_num(hevc_stru_t* hevc)
-{
-    int ii = 0;
-    PIC_t* pic;
-    int num = 0;      
-    while(1){
-        pic = get_pic_by_IDX(hevc, ii++);
-        if(pic == NULL)
-            break;
-        if(pic->output_ready == 1){
-            num++;
-        }
-    }
-    return num;
-}
-
-static int hevc_slice_segment_header_process(hevc_stru_t* hevc, param_t* rpm_param, int decode_pic_begin)
-{
-    int i;
-    int     lcu_x_num_div;
-    int     lcu_y_num_div;
-    int     Col_ref         ;
-    if(hevc->wait_buf == 0){
-        hevc->m_temporalId = rpm_param->p.m_temporalId;
-        hevc->m_nalUnitType = rpm_param->p.m_nalUnitType;
-        if(hevc->m_nalUnitType == NAL_UNIT_EOS){ 
-            hevc->m_pocRandomAccess = MAX_INT; //add to fix RAP_B_Bossen_1
-        }
-        hevc->misc_flag0 = rpm_param->p.misc_flag0;
-        if(rpm_param->p.first_slice_segment_in_pic_flag==0){
-            hevc->slice_segment_addr = rpm_param->p.slice_segment_address;
-            if(!rpm_param->p.dependent_slice_segment_flag){
-                hevc->slice_addr = hevc->slice_segment_addr;
-            }
-        }
-        else{
-            hevc->slice_segment_addr = 0;
-            hevc->slice_addr = 0;
-        }
-    
-        hevc->iPrevPOC = hevc->curr_POC;
-        hevc->slice_type =      (rpm_param->p.slice_type == I_SLICE ) ? 2 :
-                          (rpm_param->p.slice_type == P_SLICE ) ? 1 :
-                          (rpm_param->p.slice_type == B_SLICE ) ? 0 : 3;
-        //hevc->curr_predFlag_L0=(hevc->slice_type==2) ? 0:1;
-        //hevc->curr_predFlag_L1=(hevc->slice_type==0) ? 1:0;
-        hevc->TMVPFlag	= rpm_param->p.slice_temporal_mvp_enable_flag;
-        hevc->isNextSliceSegment=rpm_param->p.dependent_slice_segment_flag?1:0;
-        
-        hevc->pic_w           =rpm_param->p.pic_width_in_luma_samples;
-        hevc->pic_h           =rpm_param->p.pic_height_in_luma_samples;
-        if(hevc->pic_w == 0 || hevc->pic_h == 0 ){ //it will cause divide 0 error
-            if(debug) printk("Fatal Error, pic_w = %d, pic_h = %d\n", hevc->pic_w, hevc->pic_h);
-            return 3;
-        }
-        hevc->lcu_size        = 1<<(rpm_param->p.log2_min_coding_block_size_minus3+3+rpm_param->p.log2_diff_max_min_coding_block_size);
-        if(hevc->lcu_size == 0){
-            printk("Error, lcu_size = 0 (%d,%d)\n",rpm_param->p.log2_min_coding_block_size_minus3, rpm_param->p.log2_diff_max_min_coding_block_size);
-            return 3;
-        }
-        hevc->lcu_size_log2   =log2i(hevc->lcu_size);
-        lcu_x_num_div   =(hevc->pic_w/ hevc->lcu_size);
-        lcu_y_num_div   =(hevc->pic_h/ hevc->lcu_size);
-        hevc->lcu_x_num       =((hevc->pic_w% hevc->lcu_size) == 0) ? lcu_x_num_div : lcu_x_num_div+1;
-        hevc->lcu_y_num       =((hevc->pic_h% hevc->lcu_size) == 0) ? lcu_y_num_div : lcu_y_num_div+1;
-        hevc->lcu_total       =hevc->lcu_x_num*hevc->lcu_y_num;
-    
-    
-        if(hevc->m_nalUnitType == NAL_UNIT_CODED_SLICE_IDR || hevc->m_nalUnitType == NAL_UNIT_CODED_SLICE_IDR_N_LP){
-            hevc->curr_POC = 0;
-            if((hevc->m_temporalId - 1) == 0){
-                hevc->iPrevTid0POC = hevc->curr_POC;
-            }
-        }
-        else{
-            int iMaxPOClsb = 1<<(rpm_param->p.log2_max_pic_order_cnt_lsb_minus4+4);
-            int iPrevPOClsb;
-            int iPrevPOCmsb;
-            int iPOCmsb;
-            int iPOClsb = rpm_param->p.POClsb;
-            if(iMaxPOClsb==0){
-                printk("error iMaxPOClsb is 0\n");    
-                return 3;
-            }        
-            
-            iPrevPOClsb = hevc->iPrevTid0POC%iMaxPOClsb;
-            iPrevPOCmsb = hevc->iPrevTid0POC-iPrevPOClsb;
-            
-            if( ( iPOClsb  <  iPrevPOClsb ) && ( ( iPrevPOClsb - iPOClsb )  >=  ( iMaxPOClsb / 2 ) ) )
-            {
-                iPOCmsb = iPrevPOCmsb + iMaxPOClsb;
-            }
-            else if( (iPOClsb  >  iPrevPOClsb )  && ( (iPOClsb - iPrevPOClsb )  >  ( iMaxPOClsb / 2 ) ) ) 
-            {
-                iPOCmsb = iPrevPOCmsb - iMaxPOClsb;
-            }
-            else
-            {
-                iPOCmsb = iPrevPOCmsb;
-            }
-            if(debug&H265_DEBUG_BUFMGR){
-                printk("iPrePOC  %d iMaxPOClsb %d iPOCmsb %d iPOClsb %d\n", hevc->iPrevTid0POC, iMaxPOClsb, iPOCmsb, iPOClsb);
-            }
-            if ( hevc->m_nalUnitType == NAL_UNIT_CODED_SLICE_BLA
-                || hevc->m_nalUnitType == NAL_UNIT_CODED_SLICE_BLANT
-                || hevc->m_nalUnitType == NAL_UNIT_CODED_SLICE_BLA_N_LP )
-            {
-                // For BLA picture types, POCmsb is set to 0.
-                iPOCmsb = 0;
-            }
-            hevc->curr_POC  =  (iPOCmsb+iPOClsb);
-            if((hevc->m_temporalId - 1) == 0){
-                hevc->iPrevTid0POC = hevc->curr_POC;
-            }
-            else{
-                if(debug&H265_DEBUG_BUFMGR){
-                    printk("m_temporalID is %d\n", hevc->m_temporalId); 		
-                }
-            }
-        }
-        hevc->RefNum_L0       =rpm_param->p.num_ref_idx_l0_active;
-        hevc->RefNum_L1       =rpm_param->p.num_ref_idx_l1_active;
-        
-        //if(curr_POC==0x10) dump_lmem();
-        
-        /* skip RASL pictures after CRA/BLA pictures */
-        if(hevc->m_pocRandomAccess == MAX_INT){ //first picture
-            if (   hevc->m_nalUnitType == NAL_UNIT_CODED_SLICE_CRA || 
-                hevc->m_nalUnitType == NAL_UNIT_CODED_SLICE_BLA || hevc->m_nalUnitType == NAL_UNIT_CODED_SLICE_BLANT || hevc->m_nalUnitType == NAL_UNIT_CODED_SLICE_BLA_N_LP )
-            {
-                hevc->m_pocRandomAccess = hevc->curr_POC;
-            }
-            else{
-                hevc->m_pocRandomAccess = - MAX_INT;
-            }
-        }
-        else if (hevc->m_nalUnitType == NAL_UNIT_CODED_SLICE_BLA || hevc->m_nalUnitType == NAL_UNIT_CODED_SLICE_BLANT || hevc->m_nalUnitType == NAL_UNIT_CODED_SLICE_BLA_N_LP )
-        {
-            hevc->m_pocRandomAccess = hevc->curr_POC;
-        }
-        else if((hevc->curr_POC<hevc->m_pocRandomAccess)&&(hevc->m_nalUnitType == NAL_UNIT_CODED_SLICE_RASL_N || hevc->m_nalUnitType == NAL_UNIT_CODED_SLICE_TFD)){ //skip
-            if(debug) printk("RASL picture with POC %d < %d (RandomAccess point POC), skip it\n", hevc->curr_POC, hevc->m_pocRandomAccess);
-            return 1;
-        }
-    
-        WRITE_VREG(HEVC_WAIT_FLAG, READ_VREG(HEVC_WAIT_FLAG)|0x2);            
-        hevc->skip_flag = 0;
-        /**/
-        
-        //	if((iPrevPOC != curr_POC)){
-        if(rpm_param->p.slice_segment_address == 0){
-            PIC_t* pic;
-            hevc->new_pic=1;
-            /**/
-            if(use_cma == 0){
-                if(hevc->pic_list_init_flag == 0){
-                    init_pic_list(hevc);
-                    init_buf_spec(hevc);
-                    hevc->pic_list_init_flag = 3;
-                }
-            }
-            
-            if(debug&H265_DEBUG_BUFMGR_MORE) dump_pic_list(hevc);
-            /* prev pic */
-            if(hevc->curr_POC!=0){
-                PIC_t* pic_display;
-                pic = get_pic_by_POC(hevc, hevc->iPrevPOC);
-                if(pic){
-                    /*PB skip control*/
-                    if(pic->error_mark==0 && hevc->PB_skip_mode==1){
-                        hevc->ignore_bufmgr_error|=0x1;  //start decoding after first I
-                    }
-                    if(hevc->ignore_bufmgr_error&1){
-                        if(hevc->PB_skip_count_after_decoding>0){
-                            hevc->PB_skip_count_after_decoding--;
-                        }
-                        else{
-                            hevc->ignore_bufmgr_error|=0x2; //start displaying
-                        }
-                    }
-                    /**/
-                    pic->output_mark = 1;
-                    pic->recon_mark = 1;
-                }
-                do{			
-                    pic_display = output_pic(hevc, 0);
-
-                    if(pic_display){
-                        if((pic_display->error_mark && ((hevc->ignore_bufmgr_error&0x2)==0))
-                            ||(debug&H265_DEBUG_DISPLAY_CUR_FRAME)||(debug&H265_DEBUG_NO_DISPLAY)){
-                            pic_display->output_ready = 0;
-                            if(debug&H265_DEBUG_BUFMGR) printk("[Buffer Management] Display: POC %d, decoding index %d ==> Debug mode or error, recycle it\n", pic_display->POC, pic_display->decode_idx);
-                        }
-                        else{                    
-                            prepare_display_buf(hevc, pic_display->index, pic_display->stream_offset, pic_display->slice_type);
-                            if(debug&H265_DEBUG_BUFMGR) printk("[Buffer Management] Display: POC %d, decoding index %d\n", pic_display->POC, pic_display->decode_idx);
-                        }
-                    }
-                }while(pic_display);
-            }
-            else if(hevc->iPrevPOC!=0){ /* flush */
-                PIC_t* pic_display;
-                if(debug&H265_DEBUG_BUFMGR){
-                    printk("[Buffer Management] current pic is IDR, clear referenced flag of all buffers\n");
-                }
-                if(debug&H265_DEBUG_BUFMGR){
-                    dump_pic_list(hevc);
-                }
-                pic = get_pic_by_POC(hevc, hevc->iPrevPOC);
-                if(pic){
-                    /*PB skip control*/
-                    if(pic->error_mark==0 && hevc->PB_skip_mode==1){
-                        hevc->ignore_bufmgr_error|=0x1;  //start decoding after first I
-                    }
-                    if(hevc->ignore_bufmgr_error&1){
-                        if(hevc->PB_skip_count_after_decoding>0){
-                            hevc->PB_skip_count_after_decoding--;
-                        }
-                        else{
-                            hevc->ignore_bufmgr_error|=0x2; //start displaying
-                        }
-                    }
-                    /**/
-                    pic->output_mark = 1;
-                    pic->recon_mark = 1;
-                }
-                do{			
-                    pic_display = output_pic(hevc, 1);
-    
-                    if(pic_display){
-                        pic_display->referenced = 0;
-                        if((pic_display->error_mark && ((hevc->ignore_bufmgr_error&0x2)==0))
-                            ||(debug&H265_DEBUG_DISPLAY_CUR_FRAME)||(debug&H265_DEBUG_NO_DISPLAY)){
-                       			 pic_display->output_ready = 0;
-                             if(debug&H265_DEBUG_BUFMGR) printk("[Buffer Management] Display: POC %d, decoding index %d ==> Debug mode or error, recycle it\n", pic_display->POC, pic_display->decode_idx);
-                        }
-                        else{
-                            prepare_display_buf(hevc, pic_display->index, pic_display->stream_offset, pic_display->slice_type);
-                            if(debug&H265_DEBUG_BUFMGR) printk("[Buffer Management] Display: POC %d, decoding index %d\n", pic_display->POC, pic_display->decode_idx);
-                        }
-                    }
-                }while(pic_display);
-            }
-            
-            apply_ref_pic_set(hevc, hevc->curr_POC, rpm_param); //update referenced of old pictures (cur_pic->referenced is 1 and not updated)
-            /* new pic */
-            hevc->cur_pic = get_new_pic(hevc, rpm_param);
-            if(hevc->cur_pic == NULL){
-                if(debug&H265_DEBUG_BUFMGR){
-                    dump_pic_list(hevc);
-                }
-                hevc->wait_buf = 1;
-                return -1;
-            }            
-            if(debug&H265_DEBUG_DISPLAY_CUR_FRAME){
-                hevc->cur_pic->output_ready = 1;
-                prepare_display_buf(hevc, hevc->cur_pic->index, READ_VREG(HEVC_SHIFT_BYTE_COUNT), hevc->cur_pic->slice_type);    
-                hevc->wait_buf = 2;
-                return -1;
-            }        
-        }
-        else{
-            if(hevc->pic_list_init_flag!=3 || hevc->cur_pic==NULL){
-                return 3; //make it decode from the first slice segment    
-            }
-            hevc->cur_pic->slice_idx++;
-            hevc->new_pic =0;
-        }
-    }
-    else{
-        if(hevc->wait_buf == 1){
-            hevc->cur_pic = get_new_pic(hevc, rpm_param);
-            if(hevc->cur_pic == NULL){
-                return -1;
-            }
-            hevc->wait_buf = 0;            
-        }
-        else if(hevc->wait_buf == 2){ // for case: debug&H265_DEBUG_DISPLAY_CUR_FRAME
-            if(get_display_pic_num(hevc)>1){ //start decoding only when video is displaying cur buf
-                return -1;
-            }
-            hevc->wait_buf = 0;    
-        }
-        if(debug&H265_DEBUG_BUFMGR_MORE) dump_pic_list(hevc);
-    }
-        
-    if(hevc->new_pic){
-        int sao_mem_unit = ((hevc->lcu_size/8)*2 + 4 )<<4;
-        int pic_height_cu = (hevc->pic_h+hevc->lcu_size-1)/hevc->lcu_size;
-        int pic_width_cu = (hevc->pic_w+hevc->lcu_size-1)/hevc->lcu_size;
-		    int sao_vb_size = (sao_mem_unit+(2<<4))*pic_height_cu;
-		    //int sao_abv_size = sao_mem_unit*pic_width_cu;
-        if(debug&H265_DEBUG_BUFMGR){
-            printk("=========>%s decode index %d\n", __func__, hevc->decode_idx);
-        }
-        hevc->decode_idx++;
-        update_tile_info(hevc, pic_width_cu , pic_height_cu , sao_mem_unit, rpm_param);
-
-        config_title_hw(hevc, sao_vb_size, sao_mem_unit);
-    }
-    
-    if(hevc->iPrevPOC != hevc->curr_POC){
-        hevc->new_tile = 1;
-        hevc->tile_x = 0;
-        hevc->tile_y = 0;
-        hevc->tile_y_x = 0;
-        if(debug&H265_DEBUG_BUFMGR){
-            printk("new_tile (new_pic) tile_x=%d, tile_y=%d\n", hevc->tile_x, hevc->tile_y);
-        }
-    }
-    else if(hevc->tile_enabled){
-        if(debug&H265_DEBUG_BUFMGR){
-            printk("slice_segment_address is %d\n", rpm_param->p.slice_segment_address);
-        }
-        hevc->tile_y_x = get_tile_index(hevc, rpm_param->p.slice_segment_address, (hevc->pic_w+hevc->lcu_size-1)/hevc->lcu_size);
-        if(hevc->tile_y_x != (hevc->tile_x|(hevc->tile_y<<8))){
-            hevc->new_tile = 1;
-            hevc->tile_x = hevc->tile_y_x&0xff;
-            hevc->tile_y = (hevc->tile_y_x>>8)&0xff;
-            if(debug&H265_DEBUG_BUFMGR){
-                printk("new_tile segment_adr %d tile_x=%d, tile_y=%d\n", rpm_param->p.slice_segment_address, hevc->tile_x, hevc->tile_y);
-            }
-        }
-        else{
-            hevc->new_tile = 0;
-        }	
-    }
-    else{
-        hevc->new_tile = 0;
-    }
-    
-    if(hevc->new_tile){
-        hevc->tile_start_lcu_x = m_tile[hevc->tile_y][hevc->tile_x].start_cu_x;
-        hevc->tile_start_lcu_y = m_tile[hevc->tile_y][hevc->tile_x].start_cu_y;
-        hevc->tile_width_lcu  = m_tile[hevc->tile_y][hevc->tile_x].width;
-        hevc->tile_height_lcu = m_tile[hevc->tile_y][hevc->tile_x].height;
-    }
-    
-    set_ref_pic_list(hevc->cur_pic, rpm_param);
-    
-    
-    Col_ref=rpm_param->p.collocated_ref_idx;
-    
-    hevc->LDCFlag = 0;        
-    if(rpm_param->p.slice_type != I_SLICE){
-        hevc->LDCFlag = 1;
-        for(i=0; (i<hevc->RefNum_L0) && hevc->LDCFlag; i++){
-            if(hevc->cur_pic->m_aiRefPOCList0[hevc->cur_pic->slice_idx][i]>hevc->curr_POC){
-                hevc->LDCFlag = 0;			
-            }
-        }
-        if(rpm_param->p.slice_type == B_SLICE){
-            for(i=0; (i<hevc->RefNum_L1) && hevc->LDCFlag; i++){
-                if(hevc->cur_pic->m_aiRefPOCList1[hevc->cur_pic->slice_idx][i]>hevc->curr_POC){
-                    hevc->LDCFlag = 0;			
-                }
-            }
-        }
-    }
-    
-    hevc->ColFromL0Flag   =rpm_param->p.collocated_from_l0_flag;
-    
-    hevc->plevel          = rpm_param->p.log2_parallel_merge_level; //rpm_param->p.log2_parallel_merge_level>=2?rpm_param->p.log2_parallel_merge_level-2:0;
-    hevc->MaxNumMergeCand = 5 - rpm_param->p.five_minus_max_num_merge_cand;
-    
-    hevc->LongTerm_Curr   =0; /* to do ... */
-    hevc->LongTerm_Col    =0; /* to do ... */
-    
-    hevc->list_no = 0;	
-    if(rpm_param->p.slice_type == B_SLICE ){
-        hevc->list_no = 1-hevc->ColFromL0Flag;	
-    }
-    if(hevc->list_no==0){
-        if(Col_ref<hevc->RefNum_L0)
-            hevc->Col_POC = hevc->cur_pic->m_aiRefPOCList0[hevc->cur_pic->slice_idx][Col_ref];			
-        else
-            hevc->Col_POC = INVALID_POC;
-    }
-    else{
-        if(Col_ref<hevc->RefNum_L1)
-            hevc->Col_POC = hevc->cur_pic->m_aiRefPOCList1[hevc->cur_pic->slice_idx][Col_ref];			
-        else
-            hevc->Col_POC = INVALID_POC;
-    }
-    
-    hevc->LongTerm_Ref    = 0; /* to do ... */
-
-    if(hevc->slice_type!=2)
-    {
-        if(hevc->Col_POC != INVALID_POC){
-            hevc->col_pic = get_ref_pic_by_POC(hevc, hevc->Col_POC);
-            if(hevc->col_pic == NULL){
-                hevc->cur_pic->error_mark = 1;
-                if(debug) printk("WRONG, fail to get the picture of Col_POC\n");
-            }
-            else if(hevc->col_pic->error_mark){
-                hevc->cur_pic->error_mark = 1;
-                if(debug) printk("WRONG, Col_POC error_mark is 1\n");
-            }
-
-            if(hevc->cur_pic->error_mark && ((hevc->ignore_bufmgr_error&0x1)==0)){
-                if(debug) printk("Discard this picture\n");
-                return 2;    
-            }
-        }
-        else{
-            hevc->col_pic = hevc->cur_pic;
-        }
-    }//
-    if(hevc->col_pic == NULL) hevc->col_pic = hevc->cur_pic;     
-
-#ifdef BUFFER_MGR_ONLY
-     return 0xf;
-#else
-     if(decode_pic_begin>0 && hevc->decode_idx<=decode_pic_begin)
-          return 0xf;
-#endif
-
-    config_mc_buffer(hevc, hevc->cur_pic);
-
-    if(hevc->cur_pic->error_mark && ((hevc->ignore_bufmgr_error&0x1)==0)){
-        if(debug) printk("Discard this picture\n");
-        return 2;    
-    }
-#ifdef MCRCC_ENABLE
-    config_mcrcc_axi_hw(hevc->cur_pic->slice_type);
-#endif
-    config_mpred_hw(hevc);
-
-    config_sao_hw(hevc, rpm_param);
-    return 0;
-}    
-
-/**************************************************
-
-h265 buffer management end
-
-***************************************************/
-static buff_t mc_buf_spec;
-
-static hevc_stru_t gHevc;
-    
-static param_t  rpm_param;
-
-static void hevc_local_uninit(void)
-{
-    if(gHevc.rpm_ptr){
-        iounmap(gHevc.rpm_ptr);
-        gHevc.rpm_ptr = NULL;
-    }
-    if(gHevc.lmem_ptr){
-        iounmap(gHevc.lmem_ptr);
-        gHevc.lmem_ptr = NULL;
-    }
-    if(gHevc.debug_ptr){
-        iounmap(gHevc.debug_ptr);
-        gHevc.debug_ptr = NULL;
-    }
-}
-
-static int hevc_local_init(void)
-{
-    int ret = -1;
-    BuffInfo_t* cur_buf_info = NULL;
-    memset(&rpm_param, 0, sizeof(rpm_param));
-    
-    if (frame_width <= 1920 &&  frame_height <= 1088) {
-        cur_buf_info = &amvh265_workbuff_spec[0]; //1080p work space
-    }
-    else{
-        cur_buf_info = &amvh265_workbuff_spec[1]; //4k2k work space
-    }
- 
-    init_buff_spec(cur_buf_info);
-
-    mc_buf_spec.buf_start = (cur_buf_info->end_adr + 0xffff)&(~0xffff);
-    mc_buf_spec.buf_size  = (mc_buf_spec.buf_end - mc_buf_spec.buf_start);
-    
-    hevc_init_stru(&gHevc, cur_buf_info, &mc_buf_spec);
-    
-    bit_depth_luma = 8;
-    bit_depth_chroma = 8;
-    
-    if((debug&H265_DEBUG_SEND_PARAM_WITH_REG)==0){
-        if(gHevc.rpm_ptr){
-            iounmap(gHevc.rpm_ptr);
-            gHevc.rpm_ptr = NULL;
-        }
-        
-        gHevc.rpm_ptr = (unsigned short*)ioremap_nocache(cur_buf_info->rpm.buf_start, cur_buf_info->rpm.buf_size);
-        if (!gHevc.rpm_ptr) {
-                printk("%s: failed to remap rpm.buf_start\n", __func__);
-                return ret;
-        }
-    }    
-
-    if(debug&H265_DEBUG_UCODE){
-        if(gHevc.lmem_ptr){
-            iounmap(gHevc.lmem_ptr);
-            gHevc.lmem_ptr = NULL;
-        }
-        if(gHevc.debug_ptr){
-            iounmap(gHevc.debug_ptr);
-            gHevc.debug_ptr = NULL;
-        }
-        
-        gHevc.lmem_ptr = (unsigned short*)ioremap_nocache(cur_buf_info->lmem.buf_start, cur_buf_info->lmem.buf_size);
-        if (!gHevc.lmem_ptr) {
-                printk("%s: failed to remap lmem.buf_start\n", __func__);
-                return ret;
-        }
-        
-        gHevc.debug_ptr_size = 0x60; //cur_buf_info->pps.buf_size;
-        gHevc.debug_ptr = (unsigned short*)ioremap_nocache(cur_buf_info->pps.buf_start, cur_buf_info->pps.buf_size);
-        if (!gHevc.debug_ptr) {
-                printk("%s: failed to remap lmem.buf_start\n", __func__);
-                return ret;
-        }
-        
-    }  
-    ret = 0;  
-    return ret;
-}
-
-/********************************************
- *  Mailbox command
- ********************************************/
-#define CMD_FINISHED               0
-#define CMD_ALLOC_VIEW             1
-#define CMD_FRAME_DISPLAY          3
-#define CMD_DEBUG                  10
-
-static unsigned reserved_buffer;
-
-#define DECODE_BUFFER_NUM_MAX    32
-#define DISPLAY_BUFFER_NUM       6
-
-#define video_domain_addr(adr) (adr&0x7fffffff)
-#define DECODER_WORK_SPACE_SIZE 0x800000
-
-typedef struct {
-    unsigned int y_addr;
-    unsigned int uv_addr;
-
-    int y_canvas_index;
-    int uv_canvas_index;
-} buffer_spec_t;
-
-static buffer_spec_t buffer_spec[DECODE_BUFFER_NUM_MAX+DISPLAY_BUFFER_NUM];
-
-#define spec2canvas(x)  \
-    (((x)->uv_canvas_index << 16) | \
-     ((x)->uv_canvas_index << 8)  | \
-     ((x)->y_canvas_index << 0))
-
-#define VF_POOL_SIZE        32
-
-static DECLARE_KFIFO(newframe_q, vframe_t *, VF_POOL_SIZE);
-static DECLARE_KFIFO(display_q, vframe_t *, VF_POOL_SIZE);
-
-static s32 vfbuf_use[DECODE_BUFFER_NUM_MAX];
-static vframe_t vfpool[VF_POOL_SIZE];
-
-static int init_buf_spec(hevc_stru_t* hevc)
-{
-    int i;
-    int pic_width = hevc->pic_w;
-    int pic_height = hevc->pic_h;
-
-    //printk("%s1: %d %d\n", __func__, hevc->pic_w, hevc->pic_h);
-    printk("%s2 %d %d \n", __func__, pic_width, pic_height);
-    //pic_width = hevc->pic_w;
-    //pic_height = hevc->pic_h;
-    for(i=0; i<MAX_REF_PIC_NUM; i++) { 
-        if (m_PIC[i].index == -1) {
-            break;
-        }
-
-        buffer_spec[i].y_addr = m_PIC[i].mc_y_adr;
-        buffer_spec[i].uv_addr = m_PIC[i].mc_u_v_adr;
-
-        buffer_spec[i].y_canvas_index = 128 + i * 2;
-        buffer_spec[i].uv_canvas_index = 128 + i * 2 + 1;
-
-        canvas_config(128 + i * 2, buffer_spec[i].y_addr, ALIGN(pic_width, 64), ALIGN(pic_height, 32),
-                      CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_64X32);
-        canvas_config(128 + i * 2 + 1, buffer_spec[i].uv_addr, ALIGN(pic_width, 64), ALIGN(pic_height>>1, 32),
-                      CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_64X32);
-    }
-
-    if(frame_width == 0 || frame_height == 0){
-        frame_width = pic_width;
-        frame_height = pic_height;   
-        
-    }
-
-    return 0;
-}
-
-static void set_frame_info(vframe_t *vf)
-{
-    unsigned int ar;
-
-    vf->width = frame_width;
-    vf->height = frame_height;
-    vf->duration = frame_dur;
-    vf->duration_pulldown = 0;
-    vf->flag = 0;
-
-    ar = min(frame_ar, (u32)DISP_RATIO_ASPECT_RATIO_MAX);
-    vf->ratio_control = (ar << DISP_RATIO_ASPECT_RATIO_BIT);
-
-    return;
-}
-
-static int vh265_vf_states(vframe_states_t *states, void* op_arg)
-{
-    unsigned long flags;
-    spin_lock_irqsave(&lock, flags);
-
-    states->vf_pool_size = VF_POOL_SIZE;
-    states->buf_free_num = kfifo_len(&newframe_q);
-    states->buf_avail_num = kfifo_len(&display_q);
-
-    if(step == 2){
-        states->buf_avail_num = 0;
-    }
-    spin_unlock_irqrestore(&lock, flags);
-    return 0;
-}
-
-static vframe_t *vh265_vf_peek(void* op_arg)
-{
-    vframe_t *vf;
-    if(step == 2){
-        return NULL;
-    }
-
-    if (kfifo_peek(&display_q, &vf)) {
-        return vf;
-    }
-
-    return NULL;
-}
-
-static vframe_t *vh265_vf_get(void* op_arg)
-{
-    vframe_t *vf;
-
-    if(step == 2){
-        return NULL;
-    }
-    else if(step == 1){
-        step = 2;
-    }
-
-    if (kfifo_get(&display_q, &vf)) {
-        return vf;
-    }
-
-    return NULL;
-}
-
-static void vh265_vf_put(vframe_t *vf, void* op_arg)
-{
-    m_PIC[vf->index].output_ready = 0;
-    kfifo_put(&newframe_q, (const vframe_t **)&vf);
-    if(gHevc.wait_buf!=0){
-        WRITE_VREG(HEVC_ASSIST_MBOX1_IRQ_REG, 0x1); 
-    }
-}
-
-static int vh265_event_cb(int type, void *data, void *private_data)
-{
-    if(type & VFRAME_EVENT_RECEIVER_RESET){
-#if 0
-        unsigned long flags;
-        amhevc_stop();
-#ifndef CONFIG_POST_PROCESS_MANAGER
-        vf_light_unreg_provider(&vh265_vf_prov);
-#endif
-        spin_lock_irqsave(&lock, flags);
-        vh265_local_init();
-        vh265_prot_init();
-        spin_unlock_irqrestore(&lock, flags);
-#ifndef CONFIG_POST_PROCESS_MANAGER
-        vf_reg_provider(&vh265_vf_prov);
-#endif
-        amhevc_start();
-#endif        
-    }
-
-    return 0;
-}
-
-static int prepare_display_buf(hevc_stru_t* hevc, int display_buff_id, int stream_offset, unsigned short slice_type)
-{
-    vframe_t *vf = NULL;
-    if (kfifo_get(&newframe_q, &vf) == 0) {
-        printk("fatal error, no available buffer slot.");
-        return -1;
-    }
-    
-    if (vf) {
-        /*
-        vfbuf_use[display_buff_id]++;
-         */
-        //if (pts_lookup_offset(PTS_TYPE_VIDEO, stream_offset, &vf->pts, 0) != 0) {
-        if (pts_lookup_offset_us64(PTS_TYPE_VIDEO, stream_offset, &vf->pts, 0, &vf->pts_us64)!= 0){
-#ifdef DEBUG_PTS
-            pts_missed++;
-#endif
-            vf->pts = 0;
-            vf->pts_us64 = 0;
-        }
-#ifdef DEBUG_PTS
-        else {
-            pts_hit++;
-        }
-#endif
-
-        if ((hevc->pts_mode == PTS_NORMAL) && (vf->pts != 0) && get_frame_dur) {
-            int pts_diff = (int)vf->pts - hevc->last_lookup_pts;
-
-            if (pts_diff < 0) {
-               hevc->pts_mode_switching_count++;
-               hevc->pts_mode_recovery_count = 0;
-
-               if (hevc->pts_mode_switching_count >= PTS_MODE_SWITCHING_THRESHOLD) {
-                   hevc->pts_mode = PTS_NONE_REF_USE_DURATION;
-                   printk("HEVC: pts lookup switch to none_ref_use_duration mode.\n");
-               }
-
-            } else {
-               hevc->pts_mode_recovery_count++;
-               if (hevc->pts_mode_recovery_count > PTS_MODE_SWITCHING_RECOVERY_THREASHOLD) {
-                   hevc->pts_mode_switching_count = 0;
-                   hevc->pts_mode_recovery_count = 0;
-               }
-            }
-        }
-
-        if (vf->pts != 0) {
-            hevc->last_lookup_pts = vf->pts;
-        }
-
-        if ((hevc->pts_mode == PTS_NONE_REF_USE_DURATION) && (slice_type != 2)) {
-            vf->pts = hevc->last_pts + DUR2PTS(frame_dur);
-        }
-        hevc->last_pts = vf->pts;
-
-        if (vf->pts_us64 != 0) {
-            hevc->last_lookup_pts_us64 = vf->pts_us64;
-        }
-
-        if ((hevc->pts_mode == PTS_NONE_REF_USE_DURATION) && (slice_type != 2)) {
-            vf->pts_us64 = hevc->last_pts_us64 + (DUR2PTS(frame_dur)*100/9);
-        }
-        hevc->last_pts_us64 = vf->pts_us64;
-        if((debug&H265_DEBUG_OUT_PTS)!=0){
-            printk("H265 decoder out pts: vf->pts=%d, vf->pts_us64 = %lld\n", vf->pts, vf->pts_us64);
-        }
-
-        vf->index = display_buff_id;
-        vf->type = VIDTYPE_PROGRESSIVE | VIDTYPE_VIU_FIELD;
-        vf->type |= VIDTYPE_VIU_NV21;
-        vf->canvas0Addr = vf->canvas1Addr = spec2canvas(&buffer_spec[display_buff_id]);
-        set_frame_info(vf);
-
-        kfifo_put(&display_q, (const vframe_t **)&vf);
-
-        vf_notify_receiver(PROVIDER_NAME,VFRAME_EVENT_PROVIDER_VFRAME_READY, NULL);
-    }
-
-    return 0;
-}
-
-static int vh265_stop(void);
-static s32 vh265_init(void);
-
-static void hevc_recover(hevc_stru_t* hevc)
-{
-
-        u32 rem;
-        unsigned hevc_shift_byte_count ;
-        unsigned hevc_stream_start_addr;
-        unsigned hevc_stream_end_addr ;
-        unsigned hevc_stream_rd_ptr ;
-        unsigned hevc_stream_wr_ptr ;
-        unsigned hevc_stream_control;
-        unsigned hevc_stream_fifo_ctl;
-        unsigned hevc_stream_buf_size;
-#if 0
-            for(i=0; i<(hevc->debug_ptr_size/2); i+=4){
-                int ii;
-                for(ii=0; ii<4; ii++){
-                    printk("%04x ", hevc->debug_ptr[i+3-ii]);
-                }
-                if(((i+ii)&0xf)==0)
-                    printk("\n");
-            }
-#endif
-#define ES_VID_MAN_RD_PTR            (1<<0)
-
-        amhevc_stop();
-
-        //reset
-        WRITE_MPEG_REG(PARSER_VIDEO_RP, READ_VREG(HEVC_STREAM_RD_PTR));
-        SET_MPEG_REG_MASK(PARSER_ES_CONTROL, ES_VID_MAN_RD_PTR);
-
-        hevc_stream_start_addr = READ_VREG(HEVC_STREAM_START_ADDR);
-        hevc_stream_end_addr = READ_VREG(HEVC_STREAM_END_ADDR);
-        hevc_stream_rd_ptr = READ_VREG(HEVC_STREAM_RD_PTR);
-        hevc_stream_wr_ptr = READ_VREG(HEVC_STREAM_WR_PTR);
-        hevc_stream_control = READ_VREG(HEVC_STREAM_CONTROL);
-        hevc_stream_fifo_ctl = READ_VREG(HEVC_STREAM_FIFO_CTL);
-        hevc_stream_buf_size = hevc_stream_end_addr - hevc_stream_start_addr;
-
-        // HEVC streaming buffer will reset and restart from current hevc_stream_rd_ptr position
-        // calculate HEVC_SHIFT_BYTE_COUNT value with the new position.
-        hevc_shift_byte_count = READ_VREG(HEVC_SHIFT_BYTE_COUNT);
-        if ((hevc->shift_byte_count_lo & (1<<31)) && ((hevc_shift_byte_count & (1<<31)) == 0)) {
-            hevc->shift_byte_count += 0x100000000ULL;
-        }
-        div_u64_rem(hevc->shift_byte_count, hevc_stream_buf_size, &rem);
-        hevc->shift_byte_count -= rem;
-        hevc->shift_byte_count += hevc_stream_rd_ptr - hevc_stream_start_addr;
-        if (rem > (hevc_stream_rd_ptr - hevc_stream_start_addr)) {
-            hevc->shift_byte_count += hevc_stream_buf_size;
-        }
-        hevc->shift_byte_count_lo = (u32)hevc->shift_byte_count;
-
-        WRITE_VREG(DOS_SW_RESET3, 
-            //(1<<2)|
-            (1<<3)|(1<<4)|(1<<8)|(1<<11)|(1<<12)|(1<<14)|(1<<15)|(1<<17)|(1<<18)|(1<<19));
-        WRITE_VREG(DOS_SW_RESET3, 0);
-
-        WRITE_VREG(HEVC_STREAM_START_ADDR, hevc_stream_start_addr);
-        WRITE_VREG(HEVC_STREAM_END_ADDR, hevc_stream_end_addr);
-        WRITE_VREG(HEVC_STREAM_RD_PTR, hevc_stream_rd_ptr);
-        WRITE_VREG(HEVC_STREAM_WR_PTR, hevc_stream_wr_ptr);
-        WRITE_VREG(HEVC_STREAM_CONTROL, hevc_stream_control);
-        WRITE_VREG(HEVC_SHIFT_BYTE_COUNT, hevc->shift_byte_count_lo);
-        WRITE_VREG(HEVC_STREAM_FIFO_CTL, hevc_stream_fifo_ctl);
-
-        hevc_config_work_space_hw(&gHevc);
-        decoder_hw_reset();
-
-        gHevc.have_vps = 0;
-        gHevc.have_sps = 0;
-        gHevc.have_pps = 0;
-
-        gHevc.have_valid_start_slice = 0;
-        WRITE_VREG(HEVC_WAIT_FLAG, 1);
-        /* clear mailbox interrupt */
-        WRITE_VREG(HEVC_ASSIST_MBOX1_CLR_REG, 1);
-        /* enable mailbox interrupt */
-        WRITE_VREG(HEVC_ASSIST_MBOX1_MASK, 1);
-        /* disable PSCALE for hardware sharing */
-        WRITE_VREG(HEVC_PSCALE_CTRL, 0);
-
-        CLEAR_MPEG_REG_MASK(PARSER_ES_CONTROL, ES_VID_MAN_RD_PTR);
-
-    if(debug&H265_DEBUG_UCODE){
-        WRITE_VREG(DEBUG_REG1, 0x1);
-    }
-    else{
-        WRITE_VREG(DEBUG_REG1, 0x0);
-    }
-    
-    WRITE_VREG(NAL_SEARCH_CTL, 0x1); //manual parser NAL
-        
-    WRITE_VREG(DECODE_STOP_POS, decode_stop_pos);
-
-        //if (amhevc_loadmc(vh265_mc) < 0) {
-        //    amhevc_disable();
-        //    return -EBUSY;
-        //}
-#if 0        
-            for(i=0; i<(hevc->debug_ptr_size/2); i+=4){
-                int ii;
-                for(ii=0; ii<4; ii++){
-                    //hevc->debug_ptr[i+3-ii]=ttt++;
-                    printk("%04x ", hevc->debug_ptr[i+3-ii]);
-                }
-                if(((i+ii)&0xf)==0)
-                    printk("\n");
-            }
-#endif            
-        init_pic_list_hw();
-        
-        printk("%s HEVC_SHIFT_BYTE_COUNT=%x\n", __func__, READ_VREG(HEVC_SHIFT_BYTE_COUNT));
-
-        amhevc_start();
-
-        //skip, search next start code
-        WRITE_VREG(HEVC_WAIT_FLAG, READ_VREG(HEVC_WAIT_FLAG)&(~0x2));            
-        hevc->skip_flag = 1;
-#ifdef ERROR_HANDLE_DEBUG
-        if(dbg_nal_skip_count&0x20000){
-            dbg_nal_skip_count &= ~0x20000;
-            return;
-        }
-#endif
-        WRITE_VREG(HEVC_DEC_STATUS_REG, HEVC_ACTION_DONE);
-        // Interrupt Amrisc to excute 
-        WRITE_VREG(HEVC_MCPU_INTR_REQ, AMRISC_MAIN_REQ);
-}
-
-static irqreturn_t vh265_isr(int irq, void *dev_id)
-{
-    int ret;
-    int i;
-    unsigned int dec_status;
-    hevc_stru_t* hevc = &gHevc;
-    dec_status = READ_VREG(HEVC_DEC_STATUS_REG);
-
-    if(init_flag == 0){
-   	    return IRQ_HANDLED;
-    }
-    
-    if(debug&H265_DEBUG_BUFMGR){
-        printk("265 isr dec status = %d\n", dec_status);
-    }
-
-   if(debug&H265_DEBUG_UCODE){
-       if(READ_HREG(DEBUG_REG1)&0x10000){
-#if 0
-            printk("PPS \r\n");
-            for(i=0; i<(hevc->debug_ptr_size/2); i+=4){
-                int ii;
-                for(ii=0; ii<4; ii++){
-                    printk("%04x ", hevc->debug_ptr[i+3-ii]);
-                }
-                if(((i+ii)&0xf)==0)
-                    printk("\n");
-            }
-
-#endif
-            printk("LMEM<tag %x>:\n", READ_HREG(DEBUG_REG1));
-            for(i=0; i<0x400; i+=4){
-                int ii;
-                if((i&0xf)==0)
-                    printk("%03x: ",i);
-                for(ii=0; ii<4; ii++){
-                    printk("%04x ", hevc->lmem_ptr[i+3-ii]);
-                }
-                if(((i+ii)&0xf)==0)
-                    printk("\n");
-            }
-            WRITE_HREG(DEBUG_REG1, 0);
-       }
-       else if(READ_HREG(DEBUG_REG1)!=0){
-            printk("dbg%x: %x\n",  READ_HREG(DEBUG_REG1), READ_HREG(DEBUG_REG2));
-            WRITE_HREG(DEBUG_REG1, 0);
-            	return IRQ_HANDLED;
-       }
-       
-   }
-
-    if(hevc->pic_list_init_flag == 1){
-        return IRQ_HANDLED;
-    }
-    
-    if(hevc->error_flag==1){
-        hevc->error_skip_nal_count = error_skip_nal_count;
-        WRITE_VREG(NAL_SEARCH_CTL, 0x1); //manual parser NAL
-        WRITE_VREG(HEVC_DEC_STATUS_REG, HEVC_ACTION_DONE); //search new nal
-
-        //printk("%s: error handle\n", __func__);
-        hevc->error_flag = 2;
-    }
-    else if(hevc->error_flag==3){
-        printk("error_flag=3, hevc_recover");
-        hevc_recover(hevc);
-        hevc->error_flag = 0;
-        if((error_handle_policy&0x1)==0){
-            hevc->have_vps = 1;
-            hevc->have_sps = 1;
-            hevc->have_pps = 1;
-        }
-    }
-    
-    i = READ_VREG(HEVC_SHIFT_BYTE_COUNT);
-    if ((hevc->shift_byte_count_lo & (1<<31)) && ((i & (1<<31)) == 0)) {
-        hevc->shift_byte_count_hi++;
-    }
-    hevc->shift_byte_count_lo = i;
-
-    if(dec_status == HEVC_NAL_SEARCH_DONE){
-        int naltype = READ_HREG(CUR_NAL_UNIT_TYPE);
-        int parse_type = HEVC_DISCARD_NAL;
-        error_watchdog_count = 0;
-        error_skip_nal_watchdog_count = 0;
-        if(slice_parse_begin>0 && debug&H265_DEBUG_DISCARD_NAL){
-            printk("nal type %d, discard %d\n", naltype, slice_parse_begin);
-            if(naltype<= NAL_UNIT_CODED_SLICE_CRA){
-                slice_parse_begin--;
-            }
-        }
-        if(hevc->error_skip_nal_count > 0){
-            printk("nal type %d, discard %d\n", naltype, hevc->error_skip_nal_count);
-            hevc->error_skip_nal_count--;
-            if(hevc->error_skip_nal_count==0){
-                hevc_recover(hevc);
-                hevc->error_flag = 0;
-                if((error_handle_policy&0x1)==0){
-                    hevc->have_vps = 1;
-                    hevc->have_sps = 1;
-                    hevc->have_pps = 1;
-                }
-            }
-        }
-        else if(naltype == NAL_UNIT_VPS){
-            parse_type = HEVC_NAL_UNIT_VPS;
-            hevc->have_vps = 1;
-#ifdef ERROR_HANDLE_DEBUG
-            if(dbg_nal_skip_flag&1){
-                parse_type = HEVC_DISCARD_NAL;
-            }
-#endif            
-        }
-        else if(hevc->have_vps){
-            if(naltype == NAL_UNIT_SPS){
-                parse_type = HEVC_NAL_UNIT_SPS;
-                hevc->have_sps = 1;
-#ifdef ERROR_HANDLE_DEBUG
-                if(dbg_nal_skip_flag&2){
-                    parse_type = HEVC_DISCARD_NAL;
-                }
-#endif            
-            }
-            else if(naltype == NAL_UNIT_PPS){
-                parse_type = HEVC_NAL_UNIT_PPS;
-                hevc->have_pps = 1;
-#ifdef ERROR_HANDLE_DEBUG
-                if(dbg_nal_skip_flag&4){
-                    parse_type = HEVC_DISCARD_NAL;
-                }
-#endif            
-            }
-            else if(hevc->have_sps && hevc->have_pps){
-                if(
-                    (naltype == NAL_UNIT_CODED_SLICE_IDR) ||
-                    (naltype == NAL_UNIT_CODED_SLICE_IDR_N_LP)||
-                    ( naltype == NAL_UNIT_CODED_SLICE_CRA) ||
-                    ( naltype == NAL_UNIT_CODED_SLICE_BLA) || 
-                    ( naltype == NAL_UNIT_CODED_SLICE_BLANT) ||
-                    (naltype == NAL_UNIT_CODED_SLICE_BLA_N_LP )
-                 ){
-                    if(slice_parse_begin>0){
-                        printk("discard %d, for debugging\n", slice_parse_begin);
-                        slice_parse_begin--;
-                    }
-                    else{
-                        parse_type = HEVC_NAL_UNIT_CODED_SLICE_SEGMENT;
-                    }
-                    hevc->have_valid_start_slice = 1;
-                }
-                else if(naltype<= NAL_UNIT_CODED_SLICE_CRA){
-                    if(hevc->have_valid_start_slice || (hevc->PB_skip_mode!=3)){
-                        if(slice_parse_begin>0){
-                            printk("discard %d, for debugging\n", slice_parse_begin);
-                            slice_parse_begin--;
-                        }
-                        else{
-                            parse_type = HEVC_NAL_UNIT_CODED_SLICE_SEGMENT;
-                        }
-                    }
-                }
-            }
-        }
-        if(hevc->have_vps && hevc->have_sps && hevc->have_pps && hevc->have_valid_start_slice
-            && hevc->error_flag==0 ){
-            if((debug&H265_DEBUG_MAN_SEARCH_NAL)==0)
-                WRITE_VREG(NAL_SEARCH_CTL, 0x2); //auot parser NAL; do not check vps/sps/pps/idr
-        }
-        
-        if(debug&H265_DEBUG_BUFMGR){
-            printk("naltype = %d  parse_type %d\n %d %d %d %d \n", naltype, parse_type,
-                hevc->have_vps ,hevc->have_sps, hevc->have_pps ,hevc->have_valid_start_slice);
-        }
-
-        WRITE_VREG(HEVC_DEC_STATUS_REG, parse_type);
-        // Interrupt Amrisc to excute 
-        WRITE_VREG(HEVC_MCPU_INTR_REQ, AMRISC_MAIN_REQ);
-            
-    
-    }
-    else if(dec_status == HEVC_SLICE_SEGMENT_DONE){
-        error_watchdog_count = 0;
-        if(hevc->pic_list_init_flag == 2){
-            hevc->pic_list_init_flag = 3;
-            printk("set pic_list_init_flag to 3\n");
-        }
-        else if(hevc->wait_buf == 0){
-            u32 vui_time_scale;
-            u32 vui_num_units_in_tick;
-
-            if(debug&H265_DEBUG_SEND_PARAM_WITH_REG){
-                get_rpm_param(&rpm_param);      
-            }
-            else{
-                for(i=0; i<(RPM_END-RPM_BEGIN); i+=4){
-                    int ii;
-                    for(ii=0; ii<4; ii++){
-                        rpm_param.l.data[i+ii]=hevc->rpm_ptr[i+3-ii];
-                    } 
-                }
-            }
-            if(debug&H265_DEBUG_BUFMGR){
-                printk("rpm_param: (%d)\n", hevc->slice_idx);
-                hevc->slice_idx++;
-                for(i=0; i<(RPM_END-RPM_BEGIN); i++){
-                    printk("%04x ", rpm_param.l.data[i]);
-                    if(((i+1)&0xf)==0)
-                        printk("\n");
-                } 
-                
-                printk("vui_timing_info: %x, %x, %x, %x\r\n",         rpm_param.p.vui_num_units_in_tick_hi,
-                            rpm_param.p.vui_num_units_in_tick_lo,
-                            rpm_param.p.vui_time_scale_hi,
-                            rpm_param.p.vui_time_scale_lo);
-            }
-
-            vui_time_scale = (u32)(rpm_param.p.vui_time_scale_hi << 16) | rpm_param.p.vui_time_scale_lo;
-            vui_num_units_in_tick = (u32)(rpm_param.p.vui_num_units_in_tick_hi << 16) | rpm_param.p.vui_num_units_in_tick_lo;
-            if(bit_depth_luma!=((rpm_param.p.bit_depth&0xf)+8)){
-                printk("Bit depth luma = %d\n", (rpm_param.p.bit_depth&0xf)+8);    
-            }
-            if(bit_depth_chroma!=(((rpm_param.p.bit_depth>>4)&0xf)+8)){
-                printk("Bit depth chroma = %d\n",  ((rpm_param.p.bit_depth>>4)&0xf) + 8);    
-            }
-            bit_depth_luma = (rpm_param.p.bit_depth&0xf) + 8;
-            bit_depth_chroma = ((rpm_param.p.bit_depth>>4)&0xf) + 8;
-            if ((vui_time_scale != 0) && (vui_num_units_in_tick != 0)) {
-                frame_dur = div_u64(96000ULL * vui_num_units_in_tick, vui_time_scale);
-                get_frame_dur = true;
-            }
-
-            if(use_cma&&(rpm_param.p.slice_segment_address == 0)&&(hevc->pic_list_init_flag == 0)){
-                hevc->pic_w = rpm_param.p.pic_width_in_luma_samples;
-                hevc->pic_h = rpm_param.p.pic_height_in_luma_samples;
-                hevc->lcu_size        = 1<<(rpm_param.p.log2_min_coding_block_size_minus3+3+rpm_param.p.log2_diff_max_min_coding_block_size);
-                hevc->lcu_size_log2   =log2i(hevc->lcu_size);
-	              if(hevc->pic_w==0 || hevc->pic_h==0 || hevc->lcu_size ==0){
-                    //skip, search next start code
-                    WRITE_VREG(HEVC_WAIT_FLAG, READ_VREG(HEVC_WAIT_FLAG)&(~0x2));            
-                    hevc->skip_flag = 1;
-                    WRITE_VREG(HEVC_DEC_STATUS_REG, HEVC_ACTION_DONE);
-                    // Interrupt Amrisc to excute 
-                    WRITE_VREG(HEVC_MCPU_INTR_REQ, AMRISC_MAIN_REQ);
-	                
-	              }
-                else{                
-                    hevc->pic_list_init_flag = 1;
-                    up(&h265_sema);
-                    printk("set pic_list_init_flag to 1\n");
-                }
-                return IRQ_HANDLED;
-            }
-
-        }    
-        ret = hevc_slice_segment_header_process(hevc, &rpm_param, decode_pic_begin);
-        if(ret<0){
-
-        }
-        else if(ret == 0){
-            if ((hevc->new_pic) && (hevc->cur_pic)) {
-                hevc->cur_pic->stream_offset = READ_VREG(HEVC_SHIFT_BYTE_COUNT);
-            }
-
-            WRITE_VREG(HEVC_DEC_STATUS_REG, HEVC_CODED_SLICE_SEGMENT_DAT);
-            // Interrupt Amrisc to excute 
-            WRITE_VREG(HEVC_MCPU_INTR_REQ, AMRISC_MAIN_REQ);
-        }
-        else{
-            //skip, search next start code
-            WRITE_VREG(HEVC_WAIT_FLAG, READ_VREG(HEVC_WAIT_FLAG)&(~0x2));            
-            hevc->skip_flag = 1;
-            WRITE_VREG(HEVC_DEC_STATUS_REG, HEVC_ACTION_DONE);
-            // Interrupt Amrisc to excute 
-            WRITE_VREG(HEVC_MCPU_INTR_REQ, AMRISC_MAIN_REQ);
-        }
-        
-    }
-
-    return IRQ_HANDLED;
-}
-
-static void vh265_put_timer_func(unsigned long arg)
-{
-    struct timer_list *timer = (struct timer_list *)arg;
-    unsigned char empty_flag;
+/*
+ * AMLOGIC Audio/Video streaming port driver.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the named License,
+ * or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/semaphore.h>
+#include <linux/delay.h>
+#include <linux/timer.h>
+#include <linux/kfifo.h>
+#include <linux/kthread.h>
+#include <linux/platform_device.h>
+#include <linux/amlogic/amports/vframe.h>
+#include <linux/amlogic/amports/amstream.h>
+#include <linux/amlogic/amports/vformat.h>
+#include <linux/amlogic/amports/ptsserv.h>
+#include <linux/amlogic/amports/canvas.h>
+#include <linux/amlogic/amports/vframe.h>
+#include <linux/amlogic/amports/vframe_provider.h>
+#include <linux/amlogic/amports/vframe_receiver.h>
+#include <linux/dma-mapping.h>
+#include <linux/dma-contiguous.h>
+#include <linux/slab.h>
+#include "amports_priv.h"
+
+#include <mach/am_regs.h>
+#include "vdec_reg.h"
+
+#include "vdec.h"
+#include "amvdec.h"
+#include "vh265_mc.h"
+
+#undef HEVC_PIC_STRUCT_SUPPORT
+#define MIX_STREAM_SUPPORT
+
+//#define ERROR_HANDLE_DEBUG
+#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B
+#undef SUPPORT_4K2K
+#else
+#define SUPPORT_4K2K
+#endif
+
+#ifndef STAT_KTHREAD
+#define STAT_KTHREAD 0x40
+#endif
+
+#define DRIVER_NAME "amvdec_h265"
+#define MODULE_NAME "amvdec_h265"
+
+#define PUT_INTERVAL        (HZ/100)
+#define ERROR_SYSTEM_RESET_COUNT   200
+
+#define PTS_NORMAL                0
+#define PTS_NONE_REF_USE_DURATION 1
+
+#define PTS_MODE_SWITCHING_THRESHOLD           3
+#define PTS_MODE_SWITCHING_RECOVERY_THREASHOLD 3
+
+#define DUR2PTS(x) ((x)*90/96)
+
+extern u32 get_blackout_policy(void);
+
+static int  vh265_vf_states(vframe_states_t *states, void*);
+static vframe_t *vh265_vf_peek(void*);
+static vframe_t *vh265_vf_get(void*);
+static void vh265_vf_put(vframe_t *, void*);
+static int vh265_event_cb(int type, void *data, void *private_data);
+
+static void vh265_prot_init(void);
+static int vh265_local_init(void);
+static void vh265_put_timer_func(unsigned long arg);
+
+static const char vh265_dec_id[] = "vh265-dev";
+
+#define PROVIDER_NAME   "decoder.h265"
+
+static const struct vframe_operations_s vh265_vf_provider = {
+    .peek      = vh265_vf_peek,
+    .get       = vh265_vf_get,
+    .put       = vh265_vf_put,
+    .event_cb  = vh265_event_cb,
+    .vf_states = vh265_vf_states,
+};
+static struct vframe_provider_s vh265_vf_prov;
+
+static u32 frame_width, frame_height, frame_dur, frame_ar;
+static bool get_frame_dur;
+static struct timer_list recycle_timer;
+static u32 stat;
+static u32 bit_depth_luma;
+static u32 bit_depth_chroma;
+static u32 error_watchdog_count;
+static u32 error_skip_nal_watchdog_count;
+static u32 error_system_watchdog_count;
+
+#define H265_DEBUG_BUFMGR                   0x01
+#define H265_DEBUG_BUFMGR_MORE              0x02
+#define H265_DEBUG_UCODE                    0x04
+#define H265_DEBUG_REG                      0x08
+#define H265_DEBUG_MAN_SEARCH_NAL           0x10
+#define H265_DEBUG_MAN_SKIP_NAL             0x20
+#define H265_DEBUG_DISPLAY_CUR_FRAME        0x40
+#define H265_DEBUG_FORCE_CLK                0x80
+#define H265_DEBUG_SEND_PARAM_WITH_REG      0x100
+#define H265_DEBUG_NO_DISPLAY               0x200
+#define H265_DEBUG_DISCARD_NAL              0x400
+#define H265_DEBUG_OUT_PTS					0x800
+#define H265_DEBUG_PRINT_DECODE_STATUS      0x1000
+#define H265_DEBUG_DIS_LOC_ERROR_PROC       0x10000
+#define H265_DEBUG_DIS_SYS_ERROR_PROC   0x20000
+#define H265_DEBUG_DUMP_PIC_LIST       0x40000
+#define H265_DEBUG_TRIG_SLICE_SEGMENT_PROC 0x80000
+#define H265_DEBUG_HW_RESET               0x100000
+#define H265_DEBUG_LOAD_UCODE_FROM_FILE   0x200000
+#define H265_DEBUG_ERROR_TRIG             0x400000
+#define H265_DEBUG_NO_EOS_SEARCH_DONE     0x800000
+
+extern const u32 h265_ucode_v;
+const u32 h265_version = 201508241;
+static u32 debug = 0;
+#ifdef ERROR_HANDLE_DEBUG
+static u32 dbg_nal_skip_flag = 0;   //bit[0], skip vps; bit[1], skip sps; bit[2], skip pps
+static u32 dbg_nal_skip_count = 0;
+#endif
+/*for debug*/
+static u32 decode_stop_pos = 0;
+static u32 decode_stop_pos_pre = 0;
+static u32 decode_pic_begin = 0;
+static uint slice_parse_begin=0;
+static u32 step = 0;
+#ifdef MIX_STREAM_SUPPORT
+#ifdef SUPPORT_4K2K
+static u32 buf_alloc_width = 4096;
+static u32 buf_alloc_height = 2304;
+#else
+static u32 buf_alloc_width = 1920;
+static u32 buf_alloc_height = 1088;
+#endif
+static u32 dynamic_buf_num_margin;
+#else
+static u32 buf_alloc_width;
+static u32 buf_alloc_height;
+static u32 dynamic_buf_num_margin = 7;
+#endif
+static u32 buf_alloc_size = 0;
+/*
+bit[0]: 0,
+    bit[1]: 0, always release cma buffer when stop
+    bit[1]: 1, never release cma buffer when stop
+bit[0]: 1, when stop, release cma buffer if blackout is 1; do not release cma buffer is blackout is not 1
+
+bit[2]: 0, when start decoding, check current displayed buffer (only for buffer decoded by h265) if blackout is 0
+        1, do not check current displayed buffer
+
+bit[3]: 1, if blackout is not 1, do not release current displayed cma buffer always.
+
+*/
+static u32 buffer_mode = 1; /* set to 1 for fast play; set to 8 for other case of "keep last frame" */
+/**/
+/*
+bit[1:0]PB_skip_mode: 0, start decoding at begin; 1, start decoding after first I;  2, only decode and display none error picture; 3, start decoding and display after IDR,etc
+bit[31:16] PB_skip_count_after_decoding (decoding but not display),  only for mode 0 and 1.
+ */
+static u32 nal_skip_policy = 2;
+
+/*
+bit 0, 1: only display I picture;
+bit 1, 1: only decode I picture;
+bit 2, 1: display by decoding order
+*/
+static u32 i_only_flag = 0;
+
+static u32 use_cma = 1;
+static unsigned char init_flag = 0;
+static unsigned char uninit_list = 0;
+
+static struct semaphore  h265_sema;
+struct task_struct *h265_task = NULL;
+
+/*
+error handling
+*/
+/*error_handle_policy:
+     bit 0: 0, auto skip error_skip_nal_count nals before error recovery;   1, skip error_skip_nal_count nals before error recovery;
+     bit 1 (valid only when bit0 == 1): 1, wait vps/sps/pps after error recovery; 
+     bit 2 (valid only when bit0 == 0): 0, auto search after error recovery (hevc_recover() called); 
+                                        1, manual search after error recovery (change to auto search after get IDR: WRITE_VREG(NAL_SEARCH_CTL, 0x2))
+
+     bit 4: 0, set error_mark after reset/recover
+            1, do not set error_mark after reset/recover
+     bit 5: 0, check total lcu for every picture
+            1, do not check total lcu
+
+*/
+static u32 error_handle_policy = 0;  
+static u32 error_skip_nal_count = 6;
+static u32 error_handle_threshold = 30;
+static u32 error_handle_nal_skip_threshold = 10;
+static u32 error_handle_system_threshold = 30;
+
+static u32 interlace_enable = 1;
+
+#define DEBUG_REG
+#ifdef DEBUG_REG
+void WRITE_VREG_DBG(unsigned adr, unsigned val)
+{
+    if(debug&H265_DEBUG_REG)
+        printk("%s(%x, %x)\n", __func__, adr, val); 
+    WRITE_VREG(adr, val);   
+}    
+#undef WRITE_VREG
+#define WRITE_VREG WRITE_VREG_DBG
+#endif
+#ifdef DEBUG_PTS
+static unsigned long pts_missed, pts_hit;
+#endif
+
+static struct dec_sysinfo vh265_amstream_dec_info;
+extern u32 trickmode_i;
+
+static DEFINE_SPINLOCK(lock);
+static int fatal_error;
+
+static DEFINE_MUTEX(vh265_mutex);
+
+static struct device *cma_dev;
+
+/**************************************************
+
+h265 buffer management include
+
+***************************************************/
+enum NalUnitType
+{
+  NAL_UNIT_CODED_SLICE_TRAIL_N = 0,   // 0
+  NAL_UNIT_CODED_SLICE_TRAIL_R,   // 1
+  
+  NAL_UNIT_CODED_SLICE_TSA_N,     // 2
+  NAL_UNIT_CODED_SLICE_TLA,       // 3   // Current name in the spec: TSA_R
+  
+  NAL_UNIT_CODED_SLICE_STSA_N,    // 4
+  NAL_UNIT_CODED_SLICE_STSA_R,    // 5
+
+  NAL_UNIT_CODED_SLICE_RADL_N,    // 6
+  NAL_UNIT_CODED_SLICE_DLP,       // 7 // Current name in the spec: RADL_R
+  
+  NAL_UNIT_CODED_SLICE_RASL_N,    // 8
+  NAL_UNIT_CODED_SLICE_TFD,       // 9 // Current name in the spec: RASL_R
+
+  NAL_UNIT_RESERVED_10,
+  NAL_UNIT_RESERVED_11,
+  NAL_UNIT_RESERVED_12,
+  NAL_UNIT_RESERVED_13,
+  NAL_UNIT_RESERVED_14,
+  NAL_UNIT_RESERVED_15,
+
+  NAL_UNIT_CODED_SLICE_BLA,       // 16   // Current name in the spec: BLA_W_LP
+  NAL_UNIT_CODED_SLICE_BLANT,     // 17   // Current name in the spec: BLA_W_DLP
+  NAL_UNIT_CODED_SLICE_BLA_N_LP,  // 18
+  NAL_UNIT_CODED_SLICE_IDR,       // 19  // Current name in the spec: IDR_W_DLP
+  NAL_UNIT_CODED_SLICE_IDR_N_LP,  // 20
+  NAL_UNIT_CODED_SLICE_CRA,       // 21
+  NAL_UNIT_RESERVED_22,
+  NAL_UNIT_RESERVED_23,
+
+  NAL_UNIT_RESERVED_24,
+  NAL_UNIT_RESERVED_25,
+  NAL_UNIT_RESERVED_26,
+  NAL_UNIT_RESERVED_27,
+  NAL_UNIT_RESERVED_28,
+  NAL_UNIT_RESERVED_29,
+  NAL_UNIT_RESERVED_30,
+  NAL_UNIT_RESERVED_31,
+
+  NAL_UNIT_VPS,                   // 32
+  NAL_UNIT_SPS,                   // 33
+  NAL_UNIT_PPS,                   // 34
+  NAL_UNIT_ACCESS_UNIT_DELIMITER, // 35
+  NAL_UNIT_EOS,                   // 36
+  NAL_UNIT_EOB,                   // 37
+  NAL_UNIT_FILLER_DATA,           // 38
+  NAL_UNIT_SEI,                   // 39 Prefix SEI
+  NAL_UNIT_SEI_SUFFIX,            // 40 Suffix SEI
+  NAL_UNIT_RESERVED_41,
+  NAL_UNIT_RESERVED_42,
+  NAL_UNIT_RESERVED_43,
+  NAL_UNIT_RESERVED_44,
+  NAL_UNIT_RESERVED_45,
+  NAL_UNIT_RESERVED_46,
+  NAL_UNIT_RESERVED_47,
+  NAL_UNIT_UNSPECIFIED_48,
+  NAL_UNIT_UNSPECIFIED_49,
+  NAL_UNIT_UNSPECIFIED_50,
+  NAL_UNIT_UNSPECIFIED_51,
+  NAL_UNIT_UNSPECIFIED_52,
+  NAL_UNIT_UNSPECIFIED_53,
+  NAL_UNIT_UNSPECIFIED_54,
+  NAL_UNIT_UNSPECIFIED_55,
+  NAL_UNIT_UNSPECIFIED_56,
+  NAL_UNIT_UNSPECIFIED_57,
+  NAL_UNIT_UNSPECIFIED_58,
+  NAL_UNIT_UNSPECIFIED_59,
+  NAL_UNIT_UNSPECIFIED_60,
+  NAL_UNIT_UNSPECIFIED_61,
+  NAL_UNIT_UNSPECIFIED_62,
+  NAL_UNIT_UNSPECIFIED_63,
+  NAL_UNIT_INVALID,
+};
+
+
+//---------------------------------------------------
+// Amrisc Software Interrupt 
+//---------------------------------------------------
+#define AMRISC_STREAM_EMPTY_REQ 0x01
+#define AMRISC_PARSER_REQ       0x02
+#define AMRISC_MAIN_REQ         0x04
+
+//---------------------------------------------------
+// HEVC_DEC_STATUS define
+//---------------------------------------------------
+#define HEVC_DEC_IDLE                        0
+#define HEVC_NAL_UNIT_VPS                    1
+#define HEVC_NAL_UNIT_SPS                    2
+#define HEVC_NAL_UNIT_PPS                    3
+#define HEVC_NAL_UNIT_CODED_SLICE_SEGMENT    4
+#define HEVC_CODED_SLICE_SEGMENT_DAT         5
+#define HEVC_DUMP_LMEM				7
+#define HEVC_SLICE_SEGMENT_DONE  		8
+#define HEVC_NAL_SEARCH_DONE			9
+#define HEVC_NAL_SLICE_DATA_DONE        0xa
+#define HEVC_NAL_SLICE_DATA_ERROR       0xb
+
+#define HEVC_DISCARD_NAL         0xf0
+#define HEVC_ACTION_ERROR        0xfe
+#define HEVC_ACTION_DONE         0xff
+
+
+
+//---------------------------------------------------
+// Include "parser_cmd.h"
+//---------------------------------------------------
+#define PARSER_CMD_SKIP_CFG_0 0x0000090b
+
+#define PARSER_CMD_SKIP_CFG_1 0x1b14140f
+
+#define PARSER_CMD_SKIP_CFG_2 0x001b1910
+
+#define PARSER_CMD_NUMBER 37
+
+static unsigned short parser_cmd[PARSER_CMD_NUMBER] = {
+0x0401,
+0x8401,
+0x0800,
+0x0402,
+0x9002,
+0x1423,
+0x8CC3,
+0x1423,
+0x8804,
+0x9825,
+0x0800,
+0x04FE,
+0x8406,
+0x8411,
+0x1800,
+0x8408,
+0x8409,
+0x8C2A,
+0x9C2B,
+0x1C00,
+0x840F,
+0x8407,
+0x8000,
+0x8408,
+0x2000,
+0xA800,
+0x8410,
+0x04DE,
+0x840C,
+0x840D,
+0xAC00,
+0xA000,
+0x08C0,
+0x08E0,
+0xA40E,
+0xFC00,
+0x7C00
+};
+
+/**************************************************
+
+h265 buffer management
+
+***************************************************/
+//#define BUFFER_MGR_ONLY
+//#define CONFIG_HEVC_CLK_FORCED_ON
+//#define ENABLE_SWAP_TEST
+#define   MCRCC_ENABLE
+#define MEM_MAP_MODE 2  // 0:linear 1:32x32 2:64x32 ; m8baby test1902
+#define INVALID_POC 0x80000000
+
+
+#define HEVC_DEC_STATUS_REG       HEVC_ASSIST_SCRATCH_0
+#define HEVC_RPM_BUFFER           HEVC_ASSIST_SCRATCH_1
+#define HEVC_SHORT_TERM_RPS       HEVC_ASSIST_SCRATCH_2
+#define HEVC_VPS_BUFFER           HEVC_ASSIST_SCRATCH_3
+#define HEVC_SPS_BUFFER           HEVC_ASSIST_SCRATCH_4
+#define HEVC_PPS_BUFFER           HEVC_ASSIST_SCRATCH_5
+#define HEVC_SAO_UP               HEVC_ASSIST_SCRATCH_6
+#define HEVC_STREAM_SWAP_BUFFER   HEVC_ASSIST_SCRATCH_7
+#define HEVC_STREAM_SWAP_BUFFER2  HEVC_ASSIST_SCRATCH_8
+#define HEVC_sao_mem_unit         HEVC_ASSIST_SCRATCH_9
+#define HEVC_SAO_ABV              HEVC_ASSIST_SCRATCH_A
+#define HEVC_sao_vb_size          HEVC_ASSIST_SCRATCH_B
+#define HEVC_SAO_VB               HEVC_ASSIST_SCRATCH_C
+#define HEVC_SCALELUT             HEVC_ASSIST_SCRATCH_D
+#define HEVC_WAIT_FLAG	          HEVC_ASSIST_SCRATCH_E
+#define RPM_CMD_REG               HEVC_ASSIST_SCRATCH_F
+#define LMEM_DUMP_ADR		          HEVC_ASSIST_SCRATCH_F
+#define HEVC_STREAM_SWAP_TEST     HEVC_ASSIST_SCRATCH_L
+#define HEVC_DECODE_PIC_BEGIN_REG HEVC_ASSIST_SCRATCH_M
+#define HEVC_DECODE_PIC_NUM_REG   HEVC_ASSIST_SCRATCH_N
+
+#define DEBUG_REG1              HEVC_ASSIST_SCRATCH_G
+#define DEBUG_REG2              HEVC_ASSIST_SCRATCH_H
+/* 
+ucode parser/search control
+bit 0:  0, header auto parse; 1, header manual parse
+bit 1:  0, auto skip for noneseamless stream; 1, no skip
+bit [3:2]: valid when bit1==0;  
+0, auto skip nal before first vps/sps/pps/idr; 
+1, auto skip nal before first vps/sps/pps
+2, auto skip nal before first  vps/sps/pps, and not decode until the first I slice (with slice address of 0)
+
+3, auto skip before first I slice (nal_type >=16 && nal_type<=21)
+bit [15:4] nal skip count (valid when bit0 == 1 (manual mode) )
+bit [16]: for NAL_UNIT_EOS when bit0 is 0: 
+        0, send SEARCH_DONE to arm ;  1, do not send SEARCH_DONE to arm
+bit [31:20]: used by ucode for debug purpose
+*/
+#define NAL_SEARCH_CTL		      HEVC_ASSIST_SCRATCH_I
+#define CUR_NAL_UNIT_TYPE       HEVC_ASSIST_SCRATCH_J
+#define DECODE_STOP_POS         HEVC_ASSIST_SCRATCH_K
+
+#define MAX_INT 0x7FFFFFFF
+
+#define RPM_BEGIN                                              0x100
+#define modification_list_cur                                  0x140
+#define RPM_END                                                0x180
+
+#define RPS_USED_BIT  		14
+//MISC_FLAG0
+#define PCM_LOOP_FILTER_DISABLED_FLAG_BIT		0
+#define PCM_ENABLE_FLAG_BIT				1
+#define LOOP_FILER_ACROSS_TILES_ENABLED_FLAG_BIT	2
+#define PPS_LOOP_FILTER_ACROSS_SLICES_ENABLED_FLAG_BIT	3
+#define DEBLOCKING_FILTER_OVERRIDE_ENABLED_FLAG_BIT	4
+#define PPS_DEBLOCKING_FILTER_DISABLED_FLAG_BIT		5
+#define DEBLOCKING_FILTER_OVERRIDE_FLAG_BIT		6
+#define SLICE_DEBLOCKING_FILTER_DISABLED_FLAG_BIT	7
+#define SLICE_SAO_LUMA_FLAG_BIT				8
+#define SLICE_SAO_CHROMA_FLAG_BIT			9
+#define SLICE_LOOP_FILTER_ACROSS_SLICES_ENABLED_FLAG_BIT 10
+
+typedef union PARAM_{
+    struct{
+        unsigned short data[RPM_END-RPM_BEGIN];
+    }l;
+    struct{ 
+        /* from ucode lmem, do not change this struct */
+        unsigned short CUR_RPS[0x10];                             
+        unsigned short num_ref_idx_l0_active;                 
+        unsigned short num_ref_idx_l1_active;                 
+        unsigned short slice_type;                            
+        unsigned short slice_temporal_mvp_enable_flag;        
+        unsigned short dependent_slice_segment_flag;          
+        unsigned short slice_segment_address;                 
+        unsigned short num_title_rows_minus1;                 
+        unsigned short pic_width_in_luma_samples;             
+        unsigned short pic_height_in_luma_samples;            
+        unsigned short log2_min_coding_block_size_minus3;     
+        unsigned short log2_diff_max_min_coding_block_size;   
+        unsigned short log2_max_pic_order_cnt_lsb_minus4;     
+        unsigned short POClsb;                                
+        unsigned short collocated_from_l0_flag;               
+        unsigned short collocated_ref_idx;                    
+        unsigned short log2_parallel_merge_level;             
+        unsigned short five_minus_max_num_merge_cand;         
+        unsigned short sps_num_reorder_pics_0;                
+        unsigned short modification_flag;                     
+        unsigned short tiles_enabled_flag;                    
+        unsigned short num_tile_columns_minus1;               
+        unsigned short num_tile_rows_minus1;                  
+        unsigned short tile_width[4];                          
+        unsigned short tile_height[4];                         
+        unsigned short misc_flag0;                            
+        unsigned short pps_beta_offset_div2;                  
+        unsigned short pps_tc_offset_div2;                    
+        unsigned short slice_beta_offset_div2;                
+        unsigned short slice_tc_offset_div2;                  
+        unsigned short pps_cb_qp_offset;                      
+        unsigned short pps_cr_qp_offset;                      
+        unsigned short first_slice_segment_in_pic_flag;       
+        unsigned short m_temporalId;                          
+        unsigned short m_nalUnitType;  
+        
+        unsigned short vui_num_units_in_tick_hi;
+        unsigned short vui_num_units_in_tick_lo;
+        unsigned short vui_time_scale_hi;
+        unsigned short vui_time_scale_lo;
+        unsigned short bit_depth;
+        unsigned short profile_etc;
+          /* bit [6:3] pic_struct, bit[2:1] source_scan_type, bit[0] duplicate_flag */
+        unsigned short sei_frame_field_info;
+        unsigned short reserved[1];
+        
+        unsigned short modification_list[0x20];                      
+    }p;
+}param_t;
+
+#define RPM_BUF_SIZE  (0x80*2)
+
+typedef struct
+{
+    u32 buf_start;
+    u32 buf_size;
+    u32 buf_end;
+} buff_t;
+
+typedef struct
+{
+    u32 max_width;
+    u32 max_height;
+    u32 start_adr;
+    u32 end_adr;
+    buff_t ipp;
+    buff_t sao_abv;
+    buff_t sao_vb;
+    buff_t short_term_rps;
+    buff_t vps;
+    buff_t sps;
+    buff_t pps;
+    buff_t sao_up;
+    buff_t swap_buf;
+    buff_t swap_buf2;
+    buff_t scalelut;
+    buff_t dblk_para;
+    buff_t dblk_data;
+    buff_t mpred_above;
+    buff_t mpred_mv;
+    buff_t rpm;
+    buff_t lmem;
+} BuffInfo_t;
+#define WORK_BUF_SPEC_NUM 2
+static BuffInfo_t amvh265_workbuff_spec[WORK_BUF_SPEC_NUM]={
+    { //8M bytes
+        .max_width = 1920,
+        .max_height = 1088,
+        .ipp = {
+            // IPP work space calculation : 4096 * (Y+CbCr+Flags) = 12k, round to 16k
+            .buf_size = 0x4000,
+        },
+        .sao_abv = {
+            .buf_size = 0x30000,
+        },
+        .sao_vb = {
+            .buf_size = 0x30000,
+        },
+        .short_term_rps = {
+            // SHORT_TERM_RPS - Max 64 set, 16 entry every set, total 64x16x2 = 2048 bytes (0x800)
+            .buf_size = 0x800,
+        },
+        .vps = {
+            // VPS STORE AREA - Max 16 VPS, each has 0x80 bytes, total 0x0800 bytes
+            .buf_size = 0x800,
+        },
+        .sps = {
+            // SPS STORE AREA - Max 16 SPS, each has 0x80 bytes, total 0x0800 bytes
+            .buf_size = 0x800,
+        },
+        .pps = {
+            // PPS STORE AREA - Max 64 PPS, each has 0x80 bytes, total 0x2000 bytes
+            .buf_size = 0x2000,
+        },
+        .sao_up = {
+            // SAO UP STORE AREA - Max 640(10240/16) LCU, each has 16 bytes total 0x2800 bytes
+            .buf_size = 0x2800,
+        },
+        .swap_buf = {
+            // 256cyclex64bit = 2K bytes 0x800 (only 144 cycles valid)
+            .buf_size = 0x800,
+        },
+        .swap_buf2 = {
+            .buf_size = 0x800,
+        },
+        .scalelut = {
+            // support up to 32 SCALELUT 1024x32 = 32Kbytes (0x8000)
+            .buf_size = 0x8000,
+        },
+        .dblk_para = {
+            // DBLK -> Max 256(4096/16) LCU, each para 512bytes(total:0x20000), data 1024bytes(total:0x40000)
+            .buf_size = 0x20000,
+        },
+        .dblk_data = {
+            .buf_size = 0x40000,
+        },
+        .mpred_above = {
+            .buf_size = 0x8000,
+        },
+        .mpred_mv = {
+           .buf_size = 0x40000*16, //1080p, 0x40000 per buffer
+        },
+        .rpm = {
+           .buf_size = RPM_BUF_SIZE,
+        },
+        .lmem = {
+           .buf_size = 0x400*2,    
+        }
+    },
+    { 
+        .max_width = 4096,
+        .max_height = 2048,
+        .ipp = {
+            // IPP work space calculation : 4096 * (Y+CbCr+Flags) = 12k, round to 16k
+            .buf_size = 0x4000,
+        },
+        .sao_abv = {
+            .buf_size = 0x30000,
+        },
+        .sao_vb = {
+            .buf_size = 0x30000,
+        },
+        .short_term_rps = {
+            // SHORT_TERM_RPS - Max 64 set, 16 entry every set, total 64x16x2 = 2048 bytes (0x800)
+            .buf_size = 0x800,
+        },
+        .vps = {
+            // VPS STORE AREA - Max 16 VPS, each has 0x80 bytes, total 0x0800 bytes
+            .buf_size = 0x800,
+        },
+        .sps = {
+            // SPS STORE AREA - Max 16 SPS, each has 0x80 bytes, total 0x0800 bytes
+            .buf_size = 0x800,
+        },
+        .pps = {
+            // PPS STORE AREA - Max 64 PPS, each has 0x80 bytes, total 0x2000 bytes
+            .buf_size = 0x2000,
+        },
+        .sao_up = {
+            // SAO UP STORE AREA - Max 640(10240/16) LCU, each has 16 bytes total 0x2800 bytes
+            .buf_size = 0x2800,
+        },
+        .swap_buf = {
+            // 256cyclex64bit = 2K bytes 0x800 (only 144 cycles valid)
+            .buf_size = 0x800,
+        },
+        .swap_buf2 = {
+            .buf_size = 0x800,
+        },
+        .scalelut = {
+            // support up to 32 SCALELUT 1024x32 = 32Kbytes (0x8000)
+            .buf_size = 0x8000,
+        },
+        .dblk_para = {
+            // DBLK -> Max 256(4096/16) LCU, each para 512bytes(total:0x20000), data 1024bytes(total:0x40000)
+            .buf_size = 0x20000,
+        },
+        .dblk_data = {
+            .buf_size = 0x40000,
+        },
+        .mpred_above = {
+            .buf_size = 0x8000,
+        },
+        .mpred_mv = {
+           //.buf_size = 0x100000*16, //4k2k , 0x100000 per buffer
+          .buf_size = 0x120000*16, //4096x2304 , 0x120000 per buffer
+        },
+        .rpm = {
+           .buf_size = RPM_BUF_SIZE,
+        },
+        .lmem = {
+           .buf_size = 0x400*2,
+        }
+    }
+};
+
+static void init_buff_spec(BuffInfo_t* buf_spec)
+{
+    buf_spec->ipp.buf_start = buf_spec->start_adr;
+    buf_spec->sao_abv.buf_start = buf_spec->ipp.buf_start + buf_spec->ipp.buf_size;
+
+    buf_spec->sao_vb.buf_start   = buf_spec->sao_abv.buf_start + buf_spec->sao_abv.buf_size;
+    buf_spec->short_term_rps.buf_start    = buf_spec->sao_vb.buf_start + buf_spec->sao_vb.buf_size;
+    buf_spec->vps.buf_start     = buf_spec->short_term_rps.buf_start + buf_spec->short_term_rps.buf_size;
+    buf_spec->sps.buf_start     = buf_spec->vps.buf_start + buf_spec->vps.buf_size;
+    buf_spec->pps.buf_start     = buf_spec->sps.buf_start + buf_spec->sps.buf_size;
+    buf_spec->sao_up.buf_start  = buf_spec->pps.buf_start + buf_spec->pps.buf_size;
+    buf_spec->swap_buf.buf_start= buf_spec->sao_up.buf_start + buf_spec->sao_up.buf_size;
+    buf_spec->swap_buf2.buf_start  = buf_spec->swap_buf.buf_start + buf_spec->swap_buf.buf_size;
+    buf_spec->scalelut.buf_start= buf_spec->swap_buf2.buf_start + buf_spec->swap_buf2.buf_size;
+    buf_spec->dblk_para.buf_start = buf_spec->scalelut.buf_start + buf_spec->scalelut.buf_size;
+    buf_spec->dblk_data.buf_start = buf_spec->dblk_para.buf_start + buf_spec->dblk_para.buf_size;
+    buf_spec->mpred_above.buf_start = buf_spec->dblk_data.buf_start + buf_spec->dblk_data.buf_size;
+    buf_spec->mpred_mv.buf_start    = buf_spec->mpred_above.buf_start + buf_spec->mpred_above.buf_size;
+    if(debug&H265_DEBUG_SEND_PARAM_WITH_REG){
+        buf_spec->end_adr = buf_spec->mpred_mv.buf_start + buf_spec->mpred_mv.buf_size;
+    }
+    else{
+        buf_spec->rpm.buf_start         = buf_spec->mpred_mv.buf_start + buf_spec->mpred_mv.buf_size;
+        if(debug&H265_DEBUG_UCODE){
+            buf_spec->lmem.buf_start = buf_spec->rpm.buf_start + buf_spec->rpm.buf_size;
+            buf_spec->end_adr = buf_spec->lmem.buf_start + buf_spec->lmem.buf_size;
+        }
+        else{
+            buf_spec->end_adr = buf_spec->rpm.buf_start + buf_spec->rpm.buf_size;
+        }    
+    }
+
+    
+    if(debug)printk("%s workspace (%x %x) size = %x\n", __func__,buf_spec->start_adr, buf_spec->end_adr, buf_spec->end_adr-buf_spec->start_adr);
+    if(debug){
+        printk("ipp.buf_start             :%x\n"  , buf_spec->ipp.buf_start         );
+        printk("sao_abv.buf_start          :%x\n"  , buf_spec->sao_abv.buf_start         );
+        printk("sao_vb.buf_start          :%x\n"  , buf_spec->sao_vb.buf_start         );
+        printk("short_term_rps.buf_start  :%x\n"  , buf_spec->short_term_rps.buf_start );    
+        printk("vps.buf_start             :%x\n"  , buf_spec->vps.buf_start            );
+        printk("sps.buf_start             :%x\n"  , buf_spec->sps.buf_start            );
+        printk("pps.buf_start             :%x\n"  , buf_spec->pps.buf_start            );
+        printk("sao_up.buf_start          :%x\n"  , buf_spec->sao_up.buf_start         );
+        printk("swap_buf.buf_start        :%x\n"  , buf_spec->swap_buf.buf_start       );
+        printk("swap_buf2.buf_start       :%x\n"  , buf_spec->swap_buf2.buf_start      );
+        printk("scalelut.buf_start        :%x\n"  , buf_spec->scalelut.buf_start       );
+        printk("dblk_para.buf_start       :%x\n"  , buf_spec->dblk_para.buf_start      );
+        printk("dblk_data.buf_start       :%x\n"  , buf_spec->dblk_data.buf_start      );
+        printk("mpred_above.buf_start     :%x\n"  , buf_spec->mpred_above.buf_start    );
+        printk("mpred_mv.buf_start        :%x\n"  , buf_spec->mpred_mv.buf_start       );
+        if((debug&H265_DEBUG_SEND_PARAM_WITH_REG)==0){
+            printk("rpm.buf_start             :%x\n"  , buf_spec->rpm.buf_start            );
+        }
+    }
+    
+}
+
+
+enum SliceType
+{
+  B_SLICE,
+  P_SLICE,
+  I_SLICE
+};
+
+#define MAX_BUF_NUM 16
+typedef struct BUF_{
+  int index;
+  unsigned int alloc_flag;
+	/*buffer*/
+  unsigned int  cma_page_count;
+  struct page *alloc_pages;
+	unsigned long start_adr;
+	unsigned long size;
+	
+	unsigned long free_start_adr;
+}BUF_t;
+static BUF_t m_BUF[MAX_BUF_NUM];
+static u32 max_buf_num = MAX_BUF_NUM;
+static u32 used_buf_num;
+
+#define MAX_REF_PIC_NUM 16
+#define MAX_REF_ACTIVE  MAX_REF_PIC_NUM
+//level 6, 6.1 maximum slice number is 800; other is 200
+#define MAX_SLICE_NUM 800
+typedef struct PIC_{
+  int index;
+  int BUF_index;
+	int POC;
+	int decode_idx;
+	int slice_type;
+	int RefNum_L0;
+	int RefNum_L1;
+	int num_reorder_pic;
+        int stream_offset;
+	unsigned char referenced;
+	unsigned char output_mark;
+	unsigned char recon_mark;
+	unsigned char output_ready;
+	unsigned char error_mark;
+  unsigned char used_by_display; //for blackout_policy == 0, do not decode picture in the current displayed buffer
+	/**/
+	int slice_idx;
+	int m_aiRefPOCList0[MAX_SLICE_NUM][16];
+	int m_aiRefPOCList1[MAX_SLICE_NUM][16];
+	/*buffer*/
+  unsigned int  cma_page_count;
+  struct page *alloc_pages;
+	unsigned long mpred_mv_wr_start_addr;
+	unsigned long mc_y_adr;
+	unsigned long mc_u_v_adr;
+  unsigned int buf_size;
+	int mc_canvas_y;
+	int mc_canvas_u_v;
+	int width;
+	int height;
+ 
+  int y_canvas_index;
+  int uv_canvas_index;
+  unsigned char pic_struct;
+  int vf_ref;
+}PIC_t;
+static PIC_t m_PIC[MAX_REF_PIC_NUM ];
+PIC_t *pre_top_pic;
+PIC_t *pre_bot_pic;
+
+
+typedef struct hevc_state_{
+    BuffInfo_t* work_space_buf;
+    buff_t* mc_buf;
+    u32 rpm_page;
+    u32 rpm_phy_adr;
+    
+    unsigned int pic_list_init_flag;
+    unsigned int use_cma_flag;
+    
+    unsigned short* rpm_ptr;
+    unsigned short* lmem_ptr;
+    unsigned short* debug_ptr;
+    int debug_ptr_size;
+    int     pic_w           ;
+    int     pic_h           ;
+    int     lcu_x_num;
+    int     lcu_y_num;
+    int     lcu_total;
+    int     lcu_size        ;
+    int     lcu_size_log2   ;
+
+    int num_tile_col;
+    int num_tile_row;
+    int tile_enabled;
+    int     tile_x;
+    int     tile_y;
+    int     tile_y_x;
+    int     tile_start_lcu_x;
+    int     tile_start_lcu_y; 
+    int     tile_width_lcu  ;
+    int     tile_height_lcu ; 
+
+    int     slice_type      ;
+    int     slice_addr;
+    int     slice_segment_addr;
+
+    unsigned char interlace_flag;
+    unsigned char curr_pic_struct;
+
+    unsigned short sps_num_reorder_pics_0;
+    unsigned short misc_flag0;
+    int     m_temporalId;
+    int     m_nalUnitType;
+    int     TMVPFlag        ;
+    int     isNextSliceSegment;
+    int     LDCFlag         ;
+    int     m_pocRandomAccess;
+    int     plevel          ;
+    int     MaxNumMergeCand ;
+
+    int     new_pic;
+    int     new_tile;
+    int     curr_POC        ;
+    int     iPrevPOC;
+    int     iPrevTid0POC;
+    int     list_no;
+    int     RefNum_L0       ;
+    int     RefNum_L1       ;
+    int     ColFromL0Flag   ;
+    int     LongTerm_Curr   ;
+    int     LongTerm_Col    ;
+    int     Col_POC         ;
+    int     LongTerm_Ref    ;
+    
+    
+    PIC_t* cur_pic;
+    PIC_t* col_pic;
+    int skip_flag;
+    int decode_idx;
+    int slice_idx;    
+    unsigned char have_vps;
+    unsigned char have_sps;
+    unsigned char have_pps;
+    unsigned char have_valid_start_slice;
+    unsigned char wait_buf;
+    unsigned char error_flag;
+    unsigned int  error_skip_nal_count;
+
+    unsigned char ignore_bufmgr_error; /* bit 0, for decoding; bit 1, for displaying */
+    int PB_skip_mode;
+    int PB_skip_count_after_decoding;
+
+    int pts_mode;
+    int last_lookup_pts;
+    int last_pts;
+    u64 last_lookup_pts_us64;
+    u64 last_pts_us64;
+    u32 shift_byte_count_lo;
+    u32 shift_byte_count_hi;
+    int pts_mode_switching_count;
+    int pts_mode_recovery_count;
+    
+    int buf_num;
+    int pic_num;
+}hevc_stru_t;
+
+static void set_canvas(PIC_t* pic);
+
+static void hevc_init_stru(hevc_stru_t* hevc, BuffInfo_t* buf_spec_i, buff_t* mc_buf_i)
+{
+    int i;
+    hevc->work_space_buf = buf_spec_i;
+    hevc->mc_buf = mc_buf_i;
+    hevc->rpm_page = 0;
+
+    hevc->curr_POC = INVALID_POC;
+
+    hevc->pic_list_init_flag = 0;
+    hevc->use_cma_flag = 0;
+    hevc->decode_idx = 0;
+    hevc->slice_idx = 0;
+    hevc->new_pic=0;
+    hevc->new_tile=0;
+    hevc->iPrevPOC=0;
+    hevc->list_no=0;
+    //int m_uiMaxCUWidth = 1<<7;
+    //int m_uiMaxCUHeight = 1<<7;
+    hevc->m_pocRandomAccess = MAX_INT;
+    hevc->tile_enabled = 0;
+    hevc->tile_x = 0;
+    hevc->tile_y = 0;
+    hevc->iPrevTid0POC = 0;
+    hevc->slice_addr = 0;
+    hevc->slice_segment_addr = 0;
+    hevc->skip_flag = 0;
+    hevc->misc_flag0 = 0;
+        
+    hevc->cur_pic = NULL;
+    hevc->col_pic = NULL;
+    hevc->wait_buf = 0;
+    hevc->error_flag = 0;
+    hevc->error_skip_nal_count = 0;
+    hevc->have_vps = 0;
+    hevc->have_sps = 0;
+    hevc->have_pps = 0;
+    hevc->have_valid_start_slice = 0;
+
+    hevc->pts_mode = PTS_NORMAL;
+    hevc->last_pts = 0;
+    hevc->last_lookup_pts = 0;
+    hevc->last_pts_us64 = 0;
+    hevc->last_lookup_pts_us64 = 0;
+    hevc->shift_byte_count_lo = 0;
+    hevc->shift_byte_count_hi = 0;
+    hevc->pts_mode_switching_count = 0;
+    hevc->pts_mode_recovery_count = 0;
+
+    hevc->PB_skip_mode = nal_skip_policy&0x3;
+    hevc->PB_skip_count_after_decoding = (nal_skip_policy>>16)&0xffff;
+    if(hevc->PB_skip_mode==0){
+        hevc->ignore_bufmgr_error = 0x1;
+    }
+    else{
+        hevc->ignore_bufmgr_error = 0x0;
+    }
+
+    for(i=0; i<MAX_REF_PIC_NUM; i++){
+        m_PIC[i].index = -1;
+    }
+    hevc->buf_num = 0;
+    hevc->pic_num = 0;
+    pre_top_pic = NULL;
+    pre_bot_pic = NULL;
+}    
+
+static int prepare_display_buf(hevc_stru_t* hevc, PIC_t* pic);
+
+static void get_rpm_param(param_t* params)
+{
+	int i;
+	unsigned int data32;
+	for(i=0; i<128; i++){
+		do{
+			data32 = READ_VREG(RPM_CMD_REG);
+			//printk("%x\n", data32);
+		}while((data32&0x10000)==0);	
+		params->l.data[i] = data32&0xffff;
+		//printk("%x\n", data32);
+		WRITE_VREG(RPM_CMD_REG, 0);		
+	}
+}
+
+
+static PIC_t* get_pic_by_POC(hevc_stru_t* hevc, int POC)
+{
+  int i;
+	PIC_t* pic;
+	PIC_t* ret_pic = NULL;
+  if (POC != INVALID_POC) {
+	  for (i = 0; i < MAX_REF_PIC_NUM; i++) {
+	    pic = &m_PIC[i];
+	    if (pic->index == -1)
+	        continue;
+			if (pic->POC == POC) {
+				if (ret_pic == NULL) {
+					ret_pic = pic;
+				}
+				else {
+					if (pic->decode_idx > ret_pic->decode_idx)
+						ret_pic = pic;
+				}
+			}
+		}
+  }
+	return ret_pic;
+}
+
+static PIC_t* get_ref_pic_by_POC(hevc_stru_t* hevc, int POC)
+{
+	int i;
+	PIC_t* pic;
+	PIC_t* ret_pic = NULL;
+  for(i=0; i<MAX_REF_PIC_NUM; i++){
+    pic = &m_PIC[i];
+    if(pic->index == -1) 
+        continue;
+		if((pic->POC==POC)&&(pic->referenced)){
+			if(ret_pic==NULL){
+			    ret_pic = pic;
+		  }
+		  else{
+    	    if(pic->decode_idx > ret_pic->decode_idx)
+				    ret_pic = pic;			
+			}
+		}
+	}
+	
+	if(ret_pic==NULL){
+		if(debug) printk("Wrong, POC of %d is not in referenced list\n", POC);		
+		ret_pic = get_pic_by_POC(hevc, POC);
+	}
+	return ret_pic;
+}
+
+static unsigned int log2i (unsigned int val) {
+    unsigned int ret = -1;
+    while (val != 0) {
+        val >>= 1;
+        ret++;
+    }
+    return ret;
+}
+
+static int init_buf_spec(hevc_stru_t* hevc);
+
+
+static ulong previous_display_buf_adr = 0;
+static unsigned int previous_display_buf_size = 0;
+
+static void uninit_buf_list(hevc_stru_t* hevc)
+{
+	int i;
+  /*
+	0, do not relase cma buffer
+  1, relase all cam buffer
+  2, release current none displayed cma buffer
+  */
+	unsigned char release_cma_flag = 0;
+	if (buffer_mode & 1) {
+    	if (get_blackout_policy() == 1) {
+	        release_cma_flag = 1;
+    	}
+	}
+	else{
+		if (buffer_mode & 2) {
+	    }
+	    else{
+	        release_cma_flag = 1;
+	    }
+	}
+	    
+  if (get_blackout_policy() != 1) {
+      PIC_t* pic;
+      canvas_t cur_canvas;
+      if ((release_cma_flag == 1) && (buffer_mode & 8)) {
+        release_cma_flag = 2;
+      }
+      canvas_read((READ_VCBUS_REG(VD1_IF0_CANVAS0) & 0xff), &cur_canvas);
+      for (i = 0; i < MAX_REF_PIC_NUM; i++) {
+          pic = &m_PIC[i];
+          if (pic->index == -1)
+              continue;
+          if (cur_canvas.addr == pic->mc_y_adr) {
+              previous_display_buf_adr = pic->mc_y_adr;
+              previous_display_buf_size = pic->buf_size;
+              printk("%s, set  previous_display_buf_adr = %lx, previous_display_buf_size = %x\n", __func__, pic->mc_y_adr, pic->buf_size );
+              break;
+          }
+      }
+  }
+
+  if (release_cma_flag) {
+      for (i = 0; i < used_buf_num; i++) {
+        if (m_BUF[i].alloc_pages != NULL && m_BUF[i].cma_page_count > 0) {
+            if ((release_cma_flag == 2) && (previous_display_buf_adr >= m_BUF[i].start_adr)
+                && (previous_display_buf_adr < (m_BUF[i].start_adr + m_BUF[i].size)))
+              continue;
+            dma_release_from_contiguous(cma_dev, m_BUF[i].alloc_pages, m_BUF[i].cma_page_count);
+            printk("release cma buffer[%d] (%d %x)\n", i, m_BUF[i].cma_page_count, (unsigned)m_BUF[i].alloc_pages);
+            m_BUF[i].alloc_pages=NULL;
+            m_BUF[i].cma_page_count=0;
+        }
+      }
+  }
+
+  hevc->pic_list_init_flag = 0;
+  hevc->buf_num = 0;
+}
+
+static void init_buf_list(hevc_stru_t* hevc)
+{
+	int i;
+	int buf_size;
+	int mc_buffer_end = hevc->mc_buf->buf_start + hevc->mc_buf->buf_size;
+	
+	if (dynamic_buf_num_margin > 0)
+		used_buf_num = hevc->sps_num_reorder_pics_0
+		+ dynamic_buf_num_margin;
+	else
+		used_buf_num = max_buf_num;
+
+	if (used_buf_num > MAX_BUF_NUM)
+		used_buf_num = MAX_BUF_NUM;
+
+	if(buf_alloc_size>0){
+	    buf_size = buf_alloc_size;
+	    if(debug)printk("[Buffer Management] init_buf_list:\n");	
+	}
+	else{
+	    int pic_width = buf_alloc_width?buf_alloc_width:hevc->pic_w;
+	    int pic_height = buf_alloc_height?buf_alloc_height:hevc->pic_h;
+	    int pic_width_64 = (pic_width + 63) & (~0x3f);
+	    int pic_height_32 = (pic_height + 31) & (~0x1f);
+	    int lcu_size = hevc->lcu_size ;
+#if 1
+	    int pic_width_lcu  = (pic_width_64 % lcu_size) ? pic_width_64 / lcu_size  + 1 : pic_width_64 / lcu_size;
+	    int pic_height_lcu = (pic_height_32 % lcu_size) ? pic_height_32 / lcu_size + 1 : pic_height_32 / lcu_size;
+	    //int pic_height_lcu_2 = (pic_height_lcu + 1) & (~0x1);
+	    int pic_height_lcu_2 = (lcu_size == 32) ? (pic_height_lcu + 1) & (~0x1): ((lcu_size == 16) ? (pic_height_lcu + 3) & (~0x3) :
+	                             pic_height_lcu);
+	    int lcu_total       = pic_width_lcu * pic_height_lcu_2;
+#else
+	    int pic_width_lcu  = (pic_width % lcu_size) ? pic_width / lcu_size  + 1 : pic_width /lcu_size;
+	    int pic_height_lcu = (pic_height % lcu_size) ? pic_height / lcu_size + 1 : pic_height/lcu_size;
+	    int lcu_total       = pic_width_lcu * pic_height_lcu;
+#endif
+	    int mc_buffer_size_u_v = lcu_total*lcu_size*lcu_size/2;
+	    int mc_buffer_size_u_v_h = (mc_buffer_size_u_v + 0xffff)>>16; //64k alignment
+
+	    buf_size = (mc_buffer_size_u_v_h<<16)*3;
+	    if (debug) printk("[Buffer Management] init_buf_list num %d (width %d height %d):\n",
+	         used_buf_num, pic_width, pic_height);
+  }  
+
+	for (i = 0; i < used_buf_num; i++) {
+		if(((i+1)*buf_size) > hevc->mc_buf->buf_size){
+        if(use_cma){
+            hevc->use_cma_flag = 1;
+        }
+        else{
+            if(debug)printk("%s maximum buf size is used\n", __func__);
+              break;
+        }
+    }
+    m_BUF[i].alloc_flag = 0;
+    m_BUF[i].index = i;
+		
+		if(hevc->use_cma_flag){
+		    if((m_BUF[i].cma_page_count!=0) && (m_BUF[i].alloc_pages!=NULL) &&
+		        (m_BUF[i].size != buf_size)){
+            dma_release_from_contiguous(cma_dev, m_BUF[i].alloc_pages, m_BUF[i].cma_page_count);
+            printk("release cma buffer[%d] (%d %x)\n", i, m_BUF[i].cma_page_count, (unsigned)m_BUF[i].alloc_pages);
+            m_BUF[i].alloc_pages=NULL;
+            m_BUF[i].cma_page_count=0;		        
+		    }
+		    if(m_BUF[i].alloc_pages == NULL){
+    		    m_BUF[i].cma_page_count = PAGE_ALIGN(buf_size)/PAGE_SIZE;
+            m_BUF[i].alloc_pages = dma_alloc_from_contiguous(cma_dev, m_BUF[i].cma_page_count, 4);
+            if(m_BUF[i].alloc_pages == NULL){
+                printk("allocate cma buffer[%d] fail\n", i);
+                m_BUF[i].cma_page_count = 0;
+                break;
+            }
+            m_BUF[i].start_adr = page_to_phys(m_BUF[i].alloc_pages);
+            printk("allocate cma buffer[%d] (%d,%x,%x)\n", i, m_BUF[i].cma_page_count , (unsigned)m_BUF[i].alloc_pages, (unsigned)m_BUF[i].start_adr);
+        }
+        else{
+            printk("reuse cma buffer[%d] (%d,%x,%x)\n", i, m_BUF[i].cma_page_count , (unsigned)m_BUF[i].alloc_pages, (unsigned)m_BUF[i].start_adr);
+        }
+		}
+		else{
+		    m_BUF[i].cma_page_count = 0;
+		    m_BUF[i].alloc_pages = NULL;
+		    m_BUF[i].start_adr = hevc->mc_buf->buf_start + i*buf_size;
+    }		    
+    m_BUF[i].size = buf_size;
+    m_BUF[i].free_start_adr = m_BUF[i].start_adr;
+
+		if(((m_BUF[i].start_adr+buf_size) > mc_buffer_end) && (m_BUF[i].alloc_pages==NULL)){
+	    if(debug) printk("Max mc buffer or mpred_mv buffer is used\n");		
+			break;
+		}
+
+    if(debug){
+        printk("Buffer %d: start_adr %lx size %lx\n", i, m_BUF[i].start_adr, m_BUF[i].size);
+    }
+	}
+	
+	hevc->buf_num = i;
+
+}
+
+static int config_pic(hevc_stru_t* hevc, PIC_t* pic)
+{
+  int ret = -1;
+  int i;
+  int pic_width = hevc->pic_w;
+  int pic_height = hevc->pic_h;
+
+  int pic_width_64 = (pic_width + 63) & (~0x3f);
+  int pic_height_32 = (pic_height + 31) & (~0x1f);
+
+  int lcu_size = hevc->lcu_size ;
+#if 1
+  int pic_width_lcu  = (pic_width_64 % lcu_size) ? pic_width_64 / lcu_size  + 1 : pic_width_64 / lcu_size;
+  int pic_height_lcu = (pic_height_32 % lcu_size) ? pic_height_32/ lcu_size + 1 : pic_height_32/ lcu_size;
+  //int pic_height_lcu_2 = (pic_height_lcu + 1) & (~0x1);
+  int pic_height_lcu_2 = (lcu_size == 32) ? (pic_height_lcu + 1) & (~0x1): ((lcu_size == 16) ? (pic_height_lcu + 3) & (~0x3) : pic_height_lcu);
+  int lcu_total       =pic_width_lcu*pic_height_lcu_2;
+#else
+  int pic_width_lcu  = (pic_width % lcu_size) ? pic_width / lcu_size  + 1 : pic_width / lcu_size;
+  int pic_height_lcu = (pic_height % lcu_size) ? pic_height / lcu_size + 1 : pic_height / lcu_size;
+  int lcu_total       = pic_width_lcu*pic_height_lcu;
+#endif
+        int lcu_size_log2 = hevc->lcu_size_log2;
+  //int MV_MEM_UNIT=lcu_size_log2==6 ? 0x100 : lcu_size_log2==5 ? 0x40 : 0x10;
+  int MV_MEM_UNIT=lcu_size_log2==6 ? 0x200 : lcu_size_log2==5 ? 0x80 : 0x20;
+  int mc_buffer_size_u_v = lcu_total*lcu_size*lcu_size/2;
+  int mc_buffer_size_u_v_h = (mc_buffer_size_u_v + 0xffff)>>16; //64k alignment
+  int mpred_mv_end = hevc->work_space_buf->mpred_mv.buf_start + hevc->work_space_buf->mpred_mv.buf_size;
+  int y_adr = 0;
+  
+  if((hevc->work_space_buf->mpred_mv.buf_start + (((pic->index+1) * lcu_total)*MV_MEM_UNIT)) <= mpred_mv_end){
+      for(i=0; i<hevc->buf_num; i++){
+        y_adr = ((m_BUF[i].free_start_adr + 0xffff)>>16)<<16; //64k alignment
+        if ((y_adr + ((mc_buffer_size_u_v_h << 16) * 3)) <= (m_BUF[i].start_adr + m_BUF[i].size)) {
+            m_BUF[i].free_start_adr = y_adr+((mc_buffer_size_u_v_h<<16)*3);
+            break;
+        }
+      }
+      if(i<hevc->buf_num){
+        pic->POC = INVALID_POC; //ensure get_pic_by_POC() not get the buffer not decoded
+        pic->BUF_index = i;
+        pic->buf_size = (mc_buffer_size_u_v_h<<16)*3;
+        pic->mc_y_adr = y_adr;
+        pic->mc_u_v_adr = y_adr + ((mc_buffer_size_u_v_h<<16)<<1);
+        pic->mc_canvas_y = (pic->index<<1);
+        pic->mc_canvas_u_v = (pic->index<<1)+1;
+
+        pic->mpred_mv_wr_start_addr = hevc->work_space_buf->mpred_mv.buf_start + ((pic->index * lcu_total)*MV_MEM_UNIT);
+
+        if ((previous_display_buf_size != 0) && (buffer_mode&0x4) == 0) {
+            if ((pic->mc_y_adr >= (previous_display_buf_adr + previous_display_buf_size)) ||
+            ((pic->mc_y_adr + pic->buf_size) <= previous_display_buf_adr)){
+                pic->used_by_display = 0;
+            }
+            else{
+                pic->used_by_display = 1;
+                printk("%s, pic[%d] is displayed now, do not use it before it is not displayed\n", __func__, i);
+            }
+        }
+        else{
+            pic->used_by_display = 0;
+        }
+
+        if(debug){
+            printk("%s index %d BUF_index %d mc_y_adr %lx mc_u_v_adr %lx mpred_mv_wr_start_adr %lx\n", __func__,
+                pic->index, pic->BUF_index, pic->mc_y_adr, pic->mc_u_v_adr, pic->mpred_mv_wr_start_addr);
+        }
+        ret = 0;
+      }
+  }  
+  return ret;
+}
+
+/*
+free m_BUF[..] for all free m_PIC[..] with the different size of hevc->pic_w,hevc->pic_h
+*/
+static int recycle_buf(hevc_stru_t* hevc)
+{
+    int i,j;
+    for(i=0; i<MAX_REF_PIC_NUM; i++){
+        PIC_t* pic = &m_PIC[i];
+        if(pic->index == -1)
+            continue;
+        if(pic->width!=hevc->pic_w || pic->height!=hevc->pic_h){
+            if(pic->output_mark == 0 && pic->referenced == 0
+                    && pic->output_ready == 0
+                ){
+                pic->BUF_index = -1;
+                if(debug)
+                    printk("%s: %d\n", __func__, pic->index);
+            }
+        }        
+    }    
+    
+    for(i=0; i<hevc->buf_num; i++){
+        if(m_BUF[i].free_start_adr!=m_BUF[i].start_adr){
+            for(j=0; j<MAX_REF_PIC_NUM; j++){
+                PIC_t* pic = &m_PIC[j];
+                if(pic->index == -1) 
+                    continue;
+                if(pic->BUF_index == i)
+                    break;    
+            }
+            if(j==MAX_REF_PIC_NUM){
+                m_BUF[i].free_start_adr = m_BUF[i].start_adr;    
+            }
+        }
+    }
+    return 0;
+}
+
+static void init_pic_list(hevc_stru_t* hevc)
+{
+    int i;
+    for(i=0; i<MAX_REF_PIC_NUM; i++){
+        PIC_t* pic = &m_PIC[i];
+        memset(pic, 0, sizeof(PIC_t));
+        pic->index = i;
+        pic->BUF_index = -1;
+        if(config_pic(hevc, pic)<0){
+            if(debug)
+                printk("Config_pic %d fail\n", pic->index);
+            pic->index = -1;
+            break;
+        }
+        pic->width = hevc->pic_w;
+        pic->height = hevc->pic_h;
+        set_canvas(pic);
+    }    
+
+    for (; i < MAX_REF_PIC_NUM; i++) {
+      PIC_t *pic = &m_PIC[i];
+      memset(pic, 0, sizeof(PIC_t));
+      pic->index = -1;
+      pic->BUF_index = -1;
+    }
+
+    previous_display_buf_adr = 0;
+    previous_display_buf_size = 0;
+}
+
+static void init_pic_list_hw(void)
+{
+	int i;
+	int cur_pic_num = MAX_REF_PIC_NUM;
+	WRITE_VREG(HEVCD_MPP_ANC2AXI_TBL_CONF_ADDR, 0x0);
+	for(i=0; i<MAX_REF_PIC_NUM; i++){
+		if (m_PIC[i].index == -1) {
+			cur_pic_num = i;
+			break;
+		}
+		WRITE_VREG(HEVCD_MPP_ANC2AXI_TBL_CMD_ADDR, m_PIC[i].mc_y_adr|(m_PIC[i].mc_canvas_y<<8)|0x1);
+		WRITE_VREG(HEVCD_MPP_ANC2AXI_TBL_CMD_ADDR, m_PIC[i].mc_u_v_adr|(m_PIC[i].mc_canvas_u_v<<8)|0x1);
+	}
+	for (; i < MAX_REF_PIC_NUM; i++) {
+		WRITE_VREG(HEVCD_MPP_ANC2AXI_TBL_CMD_ADDR,
+			m_PIC[cur_pic_num-1].mc_y_adr|
+			(m_PIC[cur_pic_num-1].mc_canvas_y<<8)|0x1);
+		WRITE_VREG(HEVCD_MPP_ANC2AXI_TBL_CMD_ADDR,
+			m_PIC[cur_pic_num-1].mc_u_v_adr|
+			(m_PIC[cur_pic_num-1].mc_canvas_u_v<<8)|0x1);
+	}
+
+	WRITE_VREG(HEVCD_MPP_ANC2AXI_TBL_CONF_ADDR, 0x1);
+
+	// Zero out canvas registers in IPP -- avoid simulation X
+	WRITE_VREG(HEVCD_MPP_ANC_CANVAS_ACCCONFIG_ADDR, (0 << 8) | (0<<1) | 1);
+	for (i = 0; i < 32; i++) {
+		WRITE_VREG(HEVCD_MPP_ANC_CANVAS_DATA_ADDR, 0);
+	}
+
+}
+
+
+static void dump_pic_list(hevc_stru_t* hevc)
+{
+	int i;
+	PIC_t* pic;
+	printk("pic_list_init_flag is %d\r\n", hevc->pic_list_init_flag);
+  for(i=0; i<MAX_REF_PIC_NUM; i++){
+    pic = &m_PIC[i];
+    if(pic->index == -1) 
+        continue;
+    printk("index %d decode_idx:%d,	POC:%d,	referenced:%d,	num_reorder_pic:%d, output_mark:%d, output_ready:%d, mv_wr_start %lx vf_ref %d\n",
+      pic->index, pic->decode_idx, pic->POC, pic->referenced, pic->num_reorder_pic,
+      pic->output_mark, pic->output_ready, pic->mpred_mv_wr_start_addr, pic->vf_ref);
+	}
+}
+
+static PIC_t* output_pic(hevc_stru_t* hevc, unsigned char flush_flag)
+{
+  int num_pic_not_yet_display = 0;
+  int i;
+  PIC_t* pic;
+  PIC_t* pic_display = NULL;
+  if (i_only_flag & 0x4) {
+    for (i = 0; i < MAX_REF_PIC_NUM; i++) {
+      pic = &m_PIC[i];
+			if ((pic->index == -1) || (pic->POC == INVALID_POC))
+        continue;
+      if (pic->output_mark) {
+        if (pic_display) {
+          if (pic->decode_idx < pic_display->decode_idx) {
+            pic_display = pic;
+          }
+        }
+        else {
+          pic_display = pic;
+        }
+      }
+    }
+    if (pic_display) {
+      pic_display->output_mark = 0;
+      pic_display->recon_mark = 0;
+      pic_display->output_ready = 1;
+    }
+  }
+  else {
+    for (i = 0; i < MAX_REF_PIC_NUM; i++) {
+      pic = &m_PIC[i];
+			if ((pic->index == -1) || (pic->POC == INVALID_POC))
+        continue;
+      if (pic->output_mark) {
+        num_pic_not_yet_display++;
+      }
+    }
+
+    for (i = 0; i < MAX_REF_PIC_NUM; i++) {
+      pic = &m_PIC[i];
+			if ((pic->index == -1) || (pic->POC == INVALID_POC))
+          continue;
+      if (pic->output_mark) {
+        if (pic_display) {
+          if (pic->POC < pic_display->POC) {
+            pic_display = pic;
+          }
+          else if(pic->POC == pic_display->POC){
+              if (pic->decode_idx < pic_display->decode_idx) {
+                  pic_display = pic;
+              }
+          }
+        }
+        else{
+          pic_display = pic;
+        }
+      }
+    }
+    if (pic_display) {
+      if ((num_pic_not_yet_display > pic_display->num_reorder_pic) || flush_flag) {
+        pic_display->output_mark = 0;
+        pic_display->recon_mark = 0;
+        pic_display->output_ready = 1;
+      }
+      else {
+        pic_display = NULL;
+      }
+    }
+  }
+  return pic_display;
+}
+
+static int config_mc_buffer(hevc_stru_t* hevc, PIC_t* cur_pic)
+{
+	int i;	
+	PIC_t* pic;
+    if(debug&H265_DEBUG_BUFMGR) 
+        printk("config_mc_buffer entered .....\n");
+	if(cur_pic->slice_type != 2){ //P and B pic
+	    WRITE_VREG(HEVCD_MPP_ANC_CANVAS_ACCCONFIG_ADDR, (0 << 8) | (0<<1) | 1);
+		for(i=0; i<cur_pic->RefNum_L0; i++){
+			pic = get_ref_pic_by_POC(hevc, cur_pic->m_aiRefPOCList0[cur_pic->slice_idx][i]);
+			if(pic){
+				if(pic->error_mark){
+            cur_pic->error_mark = 1;
+				}
+				WRITE_VREG(HEVCD_MPP_ANC_CANVAS_DATA_ADDR, (pic->mc_canvas_u_v<<16)|(pic->mc_canvas_u_v<<8)|pic->mc_canvas_y);
+        if(debug&H265_DEBUG_BUFMGR) 
+            printk("refid %x mc_canvas_u_v %x mc_canvas_y %x\n", i,pic->mc_canvas_u_v,pic->mc_canvas_y);
+			}
+			else{
+				if(debug) printk("Error %s, %dth poc (%d) of RPS is not in the pic list0\n", __func__, i, cur_pic->m_aiRefPOCList0[cur_pic->slice_idx][i]);
+        cur_pic->error_mark = 1;
+				//dump_lmem();
+			}
+		}
+	}
+	if(cur_pic->slice_type == 0){ //B pic
+        if(debug&H265_DEBUG_BUFMGR) 
+            printk("config_mc_buffer RefNum_L1\n");
+	    WRITE_VREG(HEVCD_MPP_ANC_CANVAS_ACCCONFIG_ADDR, (16 << 8) | (0<<1) | 1);
+		for(i=0; i<cur_pic->RefNum_L1; i++){
+			pic = get_ref_pic_by_POC(hevc, cur_pic->m_aiRefPOCList1[cur_pic->slice_idx][i]);
+			if(pic){
+				if(pic->error_mark){
+            cur_pic->error_mark = 1;
+				}
+				WRITE_VREG(HEVCD_MPP_ANC_CANVAS_DATA_ADDR, (pic->mc_canvas_u_v<<16)|(pic->mc_canvas_u_v<<8)|pic->mc_canvas_y);
+                if(debug&H265_DEBUG_BUFMGR){
+                    printk("refid %x mc_canvas_u_v %x mc_canvas_y %x\n", i,pic->mc_canvas_u_v,pic->mc_canvas_y);
+                }
+			}
+			else{
+				if(debug) printk("Error %s, %dth poc (%d) of RPS is not in the pic list1\n", __func__, i, cur_pic->m_aiRefPOCList1[cur_pic->slice_idx][i]);
+        cur_pic->error_mark = 1;
+				//dump_lmem();
+			}
+		}
+	}
+	return 0;
+}
+
+static void apply_ref_pic_set(hevc_stru_t* hevc, int cur_poc, param_t* params)
+{
+	int ii,i;
+	int poc_tmp;
+	PIC_t* pic;
+	unsigned char is_referenced;
+	//printk("%s cur_poc %d\n", __func__, cur_poc);	
+  for(ii=0; ii<MAX_REF_PIC_NUM; ii++){
+    pic = &m_PIC[ii];
+    if(pic->index == -1) 
+        continue;
+
+		if((pic->referenced == 0 || pic->POC == cur_poc)){
+			continue;
+		}
+		is_referenced = 0;
+		for(i=0; i<16; i++){
+			int delt;
+			if(params->p.CUR_RPS[i]&0x8000)
+				break;		
+			delt = params->p.CUR_RPS[i]&((1<<(RPS_USED_BIT-1))-1);
+			if(params->p.CUR_RPS[i]&(1<<(RPS_USED_BIT-1))){
+				poc_tmp = cur_poc - ((1<<(RPS_USED_BIT-1))-delt) ;
+			}
+			else{
+				poc_tmp = cur_poc + delt;
+			}
+			if(poc_tmp == pic->POC){
+				is_referenced = 1;
+				//printk("i is %d\n", i);
+				break;
+			}
+		}
+		if(is_referenced == 0){
+			pic->referenced = 0;
+			//printk("set poc %d reference to 0\n", pic->POC);
+		}
+	}
+
+}
+
+static void set_ref_pic_list(PIC_t* pic,  param_t* params)
+{
+	int i, rIdx;
+	int num_neg = 0;
+	int num_pos = 0;
+	int total_num;
+	int num_ref_idx_l0_active = (params->p.num_ref_idx_l0_active>MAX_REF_ACTIVE)?MAX_REF_ACTIVE:params->p.num_ref_idx_l0_active;
+	int num_ref_idx_l1_active = (params->p.num_ref_idx_l1_active>MAX_REF_ACTIVE)?MAX_REF_ACTIVE:params->p.num_ref_idx_l1_active;
+
+	int RefPicSetStCurr0[16];
+	int RefPicSetStCurr1[16];
+	for(i=0;i<16;i++){
+		RefPicSetStCurr0[i]=0; RefPicSetStCurr1[i]=0;
+		pic->m_aiRefPOCList0[pic->slice_idx][i] = 0;
+		pic->m_aiRefPOCList1[pic->slice_idx][i] = 0;
+	}
+	for(i=0; i<16; i++){
+		if(params->p.CUR_RPS[i]&0x8000)
+			break;		
+		if((params->p.CUR_RPS[i]>>RPS_USED_BIT)&1){
+			int delt = params->p.CUR_RPS[i]&((1<<(RPS_USED_BIT-1))-1);
+			if((params->p.CUR_RPS[i]>>(RPS_USED_BIT-1))&1){
+				RefPicSetStCurr0[num_neg]=pic->POC - ((1<<(RPS_USED_BIT-1))-delt) ;
+				//printk("RefPicSetStCurr0 %x %x %x\n", RefPicSetStCurr0[num_neg], pic->POC, (0x800-(params[i]&0x7ff)));
+				num_neg++;
+			}
+			else{
+				RefPicSetStCurr1[num_pos]=pic->POC + delt;
+				//printk("RefPicSetStCurr1 %d\n", RefPicSetStCurr1[num_pos]);
+				num_pos++;
+			}
+		}	
+	}
+	total_num = num_neg + num_pos;
+	if(debug&H265_DEBUG_BUFMGR){
+	    printk("%s: curpoc %d slice_type %d, total %d num_neg %d num_list0 %d num_list1 %d\n", __func__,
+		        pic->POC, params->p.slice_type, total_num, num_neg,num_ref_idx_l0_active, num_ref_idx_l1_active);
+	}
+
+	if(debug&H265_DEBUG_BUFMGR){
+    printk("HEVC Stream buf start %x end %x wr %x rd %x lev %x ctl %x intctl %x\n",READ_VREG(HEVC_STREAM_START_ADDR), 
+                    READ_VREG(HEVC_STREAM_END_ADDR),
+                    READ_VREG(HEVC_STREAM_WR_PTR),
+                    READ_VREG(HEVC_STREAM_RD_PTR),
+                    READ_VREG(HEVC_STREAM_LEVEL),
+                    READ_VREG(HEVC_STREAM_FIFO_CTL),
+                    READ_VREG(HEVC_PARSER_INT_CONTROL));
+  }
+	
+	if(total_num>0){
+		if(params->p.modification_flag&0x1){
+			if(debug&H265_DEBUG_BUFMGR) 
+			    printk("ref0 POC (modification):");
+			for(rIdx=0; rIdx<num_ref_idx_l0_active; rIdx++){
+				int cIdx = params->p.modification_list[rIdx];
+				pic->m_aiRefPOCList0[pic->slice_idx][rIdx] = cIdx>=num_neg?RefPicSetStCurr1[cIdx-num_neg]:RefPicSetStCurr0[cIdx];	
+				if(debug&H265_DEBUG_BUFMGR) 
+				    printk("%d ", pic->m_aiRefPOCList0[pic->slice_idx][rIdx]);
+			}
+		}
+		else{
+			if(debug&H265_DEBUG_BUFMGR) 
+			    printk("ref0 POC:");
+			for(rIdx=0; rIdx<num_ref_idx_l0_active; rIdx++){
+				int cIdx = rIdx % total_num;		
+				pic->m_aiRefPOCList0[pic->slice_idx][rIdx] = cIdx>=num_neg?RefPicSetStCurr1[cIdx-num_neg]:RefPicSetStCurr0[cIdx];	
+				if(debug&H265_DEBUG_BUFMGR) 
+				    printk("%d ", pic->m_aiRefPOCList0[pic->slice_idx][rIdx]);
+			}
+		}
+		if(debug&H265_DEBUG_BUFMGR) 
+		    printk("\n");
+		if(params->p.slice_type == B_SLICE){
+			if(params->p.modification_flag&0x2){
+				if(debug&H265_DEBUG_BUFMGR) 
+				    printk("ref1 POC (modification):");
+				for(rIdx=0; rIdx<num_ref_idx_l1_active; rIdx++){
+					int cIdx;
+					if(params->p.modification_flag&0x1){
+					    cIdx = params->p.modification_list[num_ref_idx_l0_active+rIdx];
+					}
+					else{
+				            cIdx = params->p.modification_list[rIdx];
+					}
+					pic->m_aiRefPOCList1[pic->slice_idx][rIdx] = cIdx>=num_pos?RefPicSetStCurr0[cIdx-num_pos]:RefPicSetStCurr1[cIdx];
+					if(debug&H265_DEBUG_BUFMGR) 
+					    printk("%d ", pic->m_aiRefPOCList1[pic->slice_idx][rIdx]);
+				}
+			}
+			else{
+				if(debug&H265_DEBUG_BUFMGR) 
+				    printk("ref1 POC:");
+				for(rIdx=0; rIdx<num_ref_idx_l1_active; rIdx++){
+					int cIdx = rIdx % total_num;		
+					pic->m_aiRefPOCList1[pic->slice_idx][rIdx] = cIdx>=num_pos?RefPicSetStCurr0[cIdx-num_pos]:RefPicSetStCurr1[cIdx];
+					if(debug&H265_DEBUG_BUFMGR) 
+					    printk("%d ", pic->m_aiRefPOCList1[pic->slice_idx][rIdx]);
+				}
+			}
+			if(debug&H265_DEBUG_BUFMGR) 
+			    printk("\n");
+		}
+	}
+	/*set m_PIC */
+	pic->slice_type = (params->p.slice_type == I_SLICE ) ? 2 :
+                                (params->p.slice_type == P_SLICE ) ? 1 :
+                                (params->p.slice_type == B_SLICE ) ? 0 : 3;
+	pic->RefNum_L0 = num_ref_idx_l0_active;
+	pic->RefNum_L1 = num_ref_idx_l1_active;
+}
+
+#define MAX_TILE_COL_NUM	5
+#define MAX_TILE_ROW_NUM	5
+typedef struct{
+	int width;
+	int height;
+	int start_cu_x;
+	int start_cu_y;
+	
+	unsigned long sao_vb_start_addr;
+	unsigned long sao_abv_start_addr;
+}tile_t;
+tile_t m_tile[MAX_TILE_ROW_NUM][MAX_TILE_COL_NUM];
+
+static void update_tile_info(hevc_stru_t* hevc,  int pic_width_cu, int pic_height_cu, int sao_mem_unit, param_t* params)
+{
+	int i,j;	
+	int start_cu_x, start_cu_y;
+    int sao_vb_size = (sao_mem_unit+(2<<4))*pic_height_cu;
+    int sao_abv_size = sao_mem_unit*pic_width_cu;
+
+	hevc->tile_enabled = params->p.tiles_enabled_flag&1;
+	if(params->p.tiles_enabled_flag&1){
+		hevc->num_tile_col = params->p.num_tile_columns_minus1 + 1;
+		hevc->num_tile_row = params->p.num_tile_rows_minus1 + 1;
+		
+		if(hevc->num_tile_row > MAX_TILE_ROW_NUM  || hevc->num_tile_row <= 0){
+		    hevc->num_tile_row = 1;    
+		    printk("%s: num_tile_rows_minus1 (%d) error!!\n", __func__, params->p.num_tile_rows_minus1);
+		}
+		if(hevc->num_tile_col > MAX_TILE_COL_NUM  || hevc->num_tile_col <= 0){
+		    hevc->num_tile_col = 1;    
+		    printk("%s: num_tile_columns_minus1 (%d) error!!\n", __func__, params->p.num_tile_columns_minus1);
+		}
+		if(debug&H265_DEBUG_BUFMGR){
+		    printk("%s pic_w_cu %d pic_h_cu %d tile_enabled num_tile_col %d num_tile_row %d:\n", __func__, pic_width_cu, pic_height_cu, hevc->num_tile_col, hevc->num_tile_row);
+		}
+
+
+		if(params->p.tiles_enabled_flag&2){ //uniform flag
+			int w = pic_width_cu/hevc->num_tile_col;
+			int h = pic_height_cu/hevc->num_tile_row;
+			start_cu_y = 0;			
+			for(i=0; i<hevc->num_tile_row; i++){
+				start_cu_x = 0;
+				for(j=0; j<hevc->num_tile_col; j++){
+					if(j == (hevc->num_tile_col-1))
+						m_tile[i][j].width = pic_width_cu - start_cu_x;
+					else			
+						m_tile[i][j].width = w;
+					if(i == (hevc->num_tile_row-1))
+						m_tile[i][j].height = pic_height_cu - start_cu_y;
+					else			
+						m_tile[i][j].height = h;
+					m_tile[i][j].start_cu_x = start_cu_x;
+					m_tile[i][j].start_cu_y = start_cu_y;
+					m_tile[i][j].sao_vb_start_addr = hevc->work_space_buf->sao_vb.buf_start + j*sao_vb_size ;
+					m_tile[i][j].sao_abv_start_addr = hevc->work_space_buf->sao_abv.buf_start + i*sao_abv_size ;
+					if(debug&H265_DEBUG_BUFMGR){
+					    printk("{y=%d, x=%d w %d h %d start_x %d start_y %d sao_vb_start 0x%lx sao_abv_start 0x%lx}\n", 
+						    i,j,m_tile[i][j].width,m_tile[i][j].height, m_tile[i][j].start_cu_x, m_tile[i][j].start_cu_y,m_tile[i][j].sao_vb_start_addr, m_tile[i][j].sao_abv_start_addr);
+					}
+					start_cu_x += m_tile[i][j].width;
+					
+				}
+				start_cu_y += m_tile[i][0].height;
+			}			
+		}
+		else{
+			start_cu_y = 0;			
+			for(i=0; i<hevc->num_tile_row; i++){
+				start_cu_x = 0;
+				for(j=0; j<hevc->num_tile_col; j++){
+					if(j == (hevc->num_tile_col-1))
+						m_tile[i][j].width = pic_width_cu - start_cu_x;
+					else			
+						m_tile[i][j].width = params->p.tile_width[j];
+					if(i == (hevc->num_tile_row-1))
+						m_tile[i][j].height = pic_height_cu - start_cu_y;
+					else			
+						m_tile[i][j].height = params->p.tile_height[i];
+					m_tile[i][j].start_cu_x = start_cu_x;
+					m_tile[i][j].start_cu_y = start_cu_y;
+					m_tile[i][j].sao_vb_start_addr = hevc->work_space_buf->sao_vb.buf_start + j*sao_vb_size ;
+					m_tile[i][j].sao_abv_start_addr = hevc->work_space_buf->sao_abv.buf_start + i*sao_abv_size ;
+					if(debug&H265_DEBUG_BUFMGR){
+					    printk("{y=%d, x=%d w %d h %d start_x %d start_y %d sao_vb_start 0x%lx sao_abv_start 0x%lx}\n", 
+						    i,j,m_tile[i][j].width,m_tile[i][j].height, m_tile[i][j].start_cu_x, m_tile[i][j].start_cu_y,m_tile[i][j].sao_vb_start_addr, m_tile[i][j].sao_abv_start_addr);
+				  }
+					start_cu_x += m_tile[i][j].width;
+				}
+				start_cu_y += m_tile[i][0].height;
+			}			
+		}
+	}
+	else{
+		hevc->num_tile_col = 1;
+		hevc->num_tile_row = 1;
+		m_tile[0][0].width = pic_width_cu;
+		m_tile[0][0].height = pic_height_cu;
+		m_tile[0][0].start_cu_x = 0;
+		m_tile[0][0].start_cu_y = 0;
+		m_tile[0][0].sao_vb_start_addr = hevc->work_space_buf->sao_vb.buf_start;
+		m_tile[0][0].sao_abv_start_addr = hevc->work_space_buf->sao_abv.buf_start;
+	}
+}
+
+static int get_tile_index(hevc_stru_t* hevc, int cu_adr, int pic_width_lcu)
+{
+	int cu_x;
+	int cu_y;
+	int tile_x = 0;
+	int tile_y = 0;
+	int i;
+	if(pic_width_lcu == 0){
+	    if(debug) printk("%s Error, pic_width_lcu is 0, pic_w %d, pic_h %d\n", __func__, hevc->pic_w, hevc->pic_h);
+	    return -1;
+  }
+	cu_x = cu_adr%pic_width_lcu;
+	cu_y = cu_adr/pic_width_lcu;
+	if(hevc->tile_enabled){	
+		for(i=0;i<hevc->num_tile_col;i++){	
+			if(cu_x>=m_tile[0][i].start_cu_x){
+				tile_x = i;		
+			}
+			else{
+				break;
+			}
+		}
+		for(i=0;i<hevc->num_tile_row;i++){	
+			if(cu_y>=m_tile[i][0].start_cu_y){
+				tile_y = i;		
+			}
+			else{
+				break;
+			}
+		}
+	}
+	return (tile_x)|(tile_y<<8);
+}
+
+static void print_scratch_error(int error_num)
+{
+  if(debug) printk(" ERROR : HEVC_ASSIST_SCRATCH_TEST Error : %d\n", error_num);
+}
+
+static void hevc_config_work_space_hw(hevc_stru_t* hevc)
+{
+    BuffInfo_t* buf_spec = hevc->work_space_buf;
+    
+    if(debug) printk("%s %x %x %x %x %x %x %x %x %x %x %x %x\n", __func__,
+			buf_spec->ipp.buf_start,
+			buf_spec->start_adr,
+			buf_spec->short_term_rps.buf_start,
+			buf_spec->vps.buf_start,
+			buf_spec->sps.buf_start,
+                        buf_spec->pps.buf_start,
+                        buf_spec->sao_up.buf_start,
+                        buf_spec->swap_buf.buf_start,
+			buf_spec->swap_buf2.buf_start,
+			buf_spec->scalelut.buf_start,
+			buf_spec->dblk_para.buf_start,
+			buf_spec->dblk_data.buf_start);
+    WRITE_VREG(HEVCD_IPP_LINEBUFF_BASE,buf_spec->ipp.buf_start);
+    if((debug&H265_DEBUG_SEND_PARAM_WITH_REG)==0){
+        WRITE_VREG(HEVC_RPM_BUFFER, hevc->rpm_phy_adr);
+    }
+    WRITE_VREG(HEVC_SHORT_TERM_RPS, buf_spec->short_term_rps.buf_start);
+    WRITE_VREG(HEVC_VPS_BUFFER, buf_spec->vps.buf_start);
+    WRITE_VREG(HEVC_SPS_BUFFER, buf_spec->sps.buf_start);
+    WRITE_VREG(HEVC_PPS_BUFFER, buf_spec->pps.buf_start);
+    WRITE_VREG(HEVC_SAO_UP, buf_spec->sao_up.buf_start);
+    WRITE_VREG(HEVC_STREAM_SWAP_BUFFER, buf_spec->swap_buf.buf_start);
+    WRITE_VREG(HEVC_STREAM_SWAP_BUFFER2, buf_spec->swap_buf2.buf_start);
+    WRITE_VREG(HEVC_SCALELUT, buf_spec->scalelut.buf_start);
+
+    WRITE_VREG(HEVC_DBLK_CFG4, buf_spec->dblk_para.buf_start); // cfg_p_addr
+    WRITE_VREG(HEVC_DBLK_CFG5, buf_spec->dblk_data.buf_start); // cfg_d_addr
+    
+    if(debug&H265_DEBUG_UCODE){
+        WRITE_VREG(LMEM_DUMP_ADR, buf_spec->lmem.buf_start);
+    }
+    
+}    
+
+static void hevc_init_decoder_hw(int decode_pic_begin, int decode_pic_num)
+{
+    unsigned int data32;
+    int i;
+
+#if 1
+// m8baby test1902
+    if(debug&H265_DEBUG_BUFMGR) 
+        printk("[test.c] Test Parser Register Read/Write\n");
+    data32 = READ_VREG(HEVC_PARSER_VERSION);
+    if(data32 != 0x00010001) { print_scratch_error(25); return; } 
+    WRITE_VREG(HEVC_PARSER_VERSION, 0x5a5a55aa);
+    data32 = READ_VREG(HEVC_PARSER_VERSION);
+    if(data32 != 0x5a5a55aa) { print_scratch_error(26); return; } 
+
+#if 0
+    // test Parser Reset
+    WRITE_VREG(DOS_SW_RESET3, 
+      (1<<14) | // reset iqit to start mem init again 
+      (1<<3)    // reset_whole parser
+      );
+    WRITE_VREG(DOS_SW_RESET3, 0);      // clear reset_whole parser
+    data32 = READ_VREG(HEVC_PARSER_VERSION);
+    if(data32 != 0x00010001) { 
+        printk("Test Parser Fatal Error\n"); 
+        while(1){};
+    }
+#endif
+
+    WRITE_VREG(DOS_SW_RESET3, 
+      (1<<14)  // reset iqit to start mem init again 
+      );
+    CLEAR_VREG_MASK(HEVC_CABAC_CONTROL, 1);
+    CLEAR_VREG_MASK(HEVC_PARSER_CORE_CONTROL, 1);
+
+#endif
+
+    if(debug&H265_DEBUG_BUFMGR) 
+        printk("[test.c] Enable BitStream Fetch\n");
+    data32 = READ_VREG(HEVC_STREAM_CONTROL);
+    data32 = data32 | 
+             (1 << 0) // stream_fetch_enable
+             ;
+    WRITE_VREG(HEVC_STREAM_CONTROL, data32);
+
+    data32 = READ_VREG(HEVC_SHIFT_STARTCODE);
+    if(data32 != 0x00000100) { print_scratch_error(29); return; } 
+    data32 = READ_VREG(HEVC_SHIFT_EMULATECODE);
+    if(data32 != 0x00000300) { print_scratch_error(30); return; } 
+    WRITE_VREG(HEVC_SHIFT_STARTCODE, 0x12345678);
+    WRITE_VREG(HEVC_SHIFT_EMULATECODE, 0x9abcdef0);
+    data32 = READ_VREG(HEVC_SHIFT_STARTCODE);
+    if(data32 != 0x12345678) { print_scratch_error(31); return; } 
+    data32 = READ_VREG(HEVC_SHIFT_EMULATECODE);
+    if(data32 != 0x9abcdef0) { print_scratch_error(32); return; } 
+    WRITE_VREG(HEVC_SHIFT_STARTCODE, 0x00000100);
+    WRITE_VREG(HEVC_SHIFT_EMULATECODE, 0x00000300);
+
+    if(debug&H265_DEBUG_BUFMGR) 
+        printk("[test.c] Enable HEVC Parser Interrupt\n");
+    data32 = READ_VREG(HEVC_PARSER_INT_CONTROL);
+    data32 &=0x03ffffff;
+    data32 = data32 | 
+             (3<<29)|
+             (2<<26)|             
+             (1 << 24) |  // stream_buffer_empty_int_amrisc_enable
+             (1 << 22) |  // stream_fifo_empty_int_amrisc_enable
+             (1 << 7) |  // dec_done_int_cpu_enable
+             (1 << 4) |  // startcode_found_int_cpu_enable
+             (0 << 3) |  // startcode_found_int_amrisc_enable
+             (1 << 0)    // parser_int_enable
+             ;
+    WRITE_VREG(HEVC_PARSER_INT_CONTROL, data32);
+
+    if(debug&H265_DEBUG_BUFMGR) 
+        printk("[test.c] Enable HEVC Parser Shift\n");
+
+    data32 = READ_VREG(HEVC_SHIFT_STATUS);
+    data32 = data32 | 
+             (1 << 1) |  // emulation_check_on
+             (1 << 0)    // startcode_check_on
+             ;
+    WRITE_VREG(HEVC_SHIFT_STATUS, data32);
+
+    WRITE_VREG(HEVC_SHIFT_CONTROL, 
+              (3 << 6) | // sft_valid_wr_position
+              (2 << 4) | // emulate_code_length_sub_1
+              (2 << 1) | // start_code_length_sub_1
+              (1 << 0)   // stream_shift_enable
+            );
+
+    WRITE_VREG(HEVC_CABAC_CONTROL, 
+              (1 << 0)   // cabac_enable
+            );
+
+    WRITE_VREG(HEVC_PARSER_CORE_CONTROL, 
+              (1 << 0)   // hevc_parser_core_clk_en
+            );
+
+
+    WRITE_VREG(HEVC_DEC_STATUS_REG, 0);
+
+    // Initial IQIT_SCALELUT memory -- just to avoid X in simulation
+    if(debug&H265_DEBUG_BUFMGR) 
+        printk("[test.c] Initial IQIT_SCALELUT memory -- just to avoid X in simulation...\n");
+    WRITE_VREG(HEVC_IQIT_SCALELUT_WR_ADDR, 0); // cfg_p_addr
+    for(i=0; i<1024; i++) WRITE_VREG(HEVC_IQIT_SCALELUT_DATA, 0);
+
+
+#ifdef ENABLE_SWAP_TEST
+    WRITE_VREG(HEVC_STREAM_SWAP_TEST, 100);
+#else
+    WRITE_VREG(HEVC_STREAM_SWAP_TEST, 0);
+#endif
+
+    WRITE_VREG(HEVC_DECODE_PIC_BEGIN_REG, 0);
+    WRITE_VREG(HEVC_DECODE_PIC_NUM_REG, 0xffffffff);
+
+    // Send parser_cmd
+    if(debug) printk("[test.c] SEND Parser Command ...\n");
+    WRITE_VREG(HEVC_PARSER_CMD_WRITE, (1<<16) | (0<<0));
+    for(i=0; i<PARSER_CMD_NUMBER; i++){
+      WRITE_VREG(HEVC_PARSER_CMD_WRITE, parser_cmd[i]);
+    }
+
+    WRITE_VREG(HEVC_PARSER_CMD_SKIP_0, PARSER_CMD_SKIP_CFG_0);
+    WRITE_VREG(HEVC_PARSER_CMD_SKIP_1, PARSER_CMD_SKIP_CFG_1);
+    WRITE_VREG(HEVC_PARSER_CMD_SKIP_2, PARSER_CMD_SKIP_CFG_2);
+
+    WRITE_VREG(HEVC_PARSER_IF_CONTROL, 
+            //  (1 << 8) | // sao_sw_pred_enable
+              (1 << 5) | // parser_sao_if_en
+              (1 << 2) | // parser_mpred_if_en
+              (1 << 0) // parser_scaler_if_en
+            );
+
+    // Changed to Start MPRED in microcode
+    /*
+    printk("[test.c] Start MPRED\n");
+    WRITE_VREG(HEVC_MPRED_INT_STATUS,
+            (1<<31)
+        ); 
+    */
+
+    if(debug) printk("[test.c] Reset IPP\n");
+    WRITE_VREG(HEVCD_IPP_TOP_CNTL, 
+              (0 << 1) | // enable ipp
+              (1 << 0)   // software reset ipp and mpp
+            );
+    WRITE_VREG(HEVCD_IPP_TOP_CNTL, 
+              (1 << 1) | // enable ipp
+              (0 << 0)   // software reset ipp and mpp
+            );
+}
+
+static void decoder_hw_reset(void)
+{
+    int i;
+    unsigned int data32;
+    WRITE_VREG(DOS_SW_RESET3, 
+      (1<<14)  // reset iqit to start mem init again 
+      );
+    CLEAR_VREG_MASK(HEVC_CABAC_CONTROL, 1);
+    CLEAR_VREG_MASK(HEVC_PARSER_CORE_CONTROL, 1);
+
+
+    data32 = READ_VREG(HEVC_STREAM_CONTROL);
+    data32 = data32 | 
+             (1 << 0) // stream_fetch_enable
+             ;
+    WRITE_VREG(HEVC_STREAM_CONTROL, data32);
+
+    data32 = READ_VREG(HEVC_SHIFT_STARTCODE);
+    if(data32 != 0x00000100) { print_scratch_error(29); return; } 
+    data32 = READ_VREG(HEVC_SHIFT_EMULATECODE);
+    if(data32 != 0x00000300) { print_scratch_error(30); return; } 
+    WRITE_VREG(HEVC_SHIFT_STARTCODE, 0x12345678);
+    WRITE_VREG(HEVC_SHIFT_EMULATECODE, 0x9abcdef0);
+    data32 = READ_VREG(HEVC_SHIFT_STARTCODE);
+    if(data32 != 0x12345678) { print_scratch_error(31); return; } 
+    data32 = READ_VREG(HEVC_SHIFT_EMULATECODE);
+    if(data32 != 0x9abcdef0) { print_scratch_error(32); return; } 
+    WRITE_VREG(HEVC_SHIFT_STARTCODE, 0x00000100);
+    WRITE_VREG(HEVC_SHIFT_EMULATECODE, 0x00000300);
+
+    data32 = READ_VREG(HEVC_PARSER_INT_CONTROL);
+    data32 &=0x03ffffff;
+    data32 = data32 | 
+             (3<<29)|
+             (2<<26)|             
+             (1 << 24) |  // stream_buffer_empty_int_amrisc_enable
+             (1 << 22) |  // stream_fifo_empty_int_amrisc_enable
+             (1 << 7) |  // dec_done_int_cpu_enable
+             (1 << 4) |  // startcode_found_int_cpu_enable
+             (0 << 3) |  // startcode_found_int_amrisc_enable
+             (1 << 0)    // parser_int_enable
+             ;
+    WRITE_VREG(HEVC_PARSER_INT_CONTROL, data32);
+
+    data32 = READ_VREG(HEVC_SHIFT_STATUS);
+    data32 = data32 | 
+             (1 << 1) |  // emulation_check_on
+             (1 << 0)    // startcode_check_on
+             ;
+    WRITE_VREG(HEVC_SHIFT_STATUS, data32);
+
+    WRITE_VREG(HEVC_SHIFT_CONTROL, 
+              (3 << 6) | // sft_valid_wr_position
+              (2 << 4) | // emulate_code_length_sub_1
+              (2 << 1) | // start_code_length_sub_1
+              (1 << 0)   // stream_shift_enable
+            );
+
+    WRITE_VREG(HEVC_CABAC_CONTROL, 
+              (1 << 0)   // cabac_enable
+            );
+
+    WRITE_VREG(HEVC_PARSER_CORE_CONTROL, 
+              (1 << 0)   // hevc_parser_core_clk_en
+            );
+
+
+    // Initial IQIT_SCALELUT memory -- just to avoid X in simulation
+    WRITE_VREG(HEVC_IQIT_SCALELUT_WR_ADDR, 0); // cfg_p_addr
+    for(i=0; i<1024; i++) WRITE_VREG(HEVC_IQIT_SCALELUT_DATA, 0);
+
+
+    // Send parser_cmd
+    WRITE_VREG(HEVC_PARSER_CMD_WRITE, (1<<16) | (0<<0));
+    for(i=0; i<PARSER_CMD_NUMBER; i++){
+      WRITE_VREG(HEVC_PARSER_CMD_WRITE, parser_cmd[i]);
+    }
+
+    WRITE_VREG(HEVC_PARSER_CMD_SKIP_0, PARSER_CMD_SKIP_CFG_0);
+    WRITE_VREG(HEVC_PARSER_CMD_SKIP_1, PARSER_CMD_SKIP_CFG_1);
+    WRITE_VREG(HEVC_PARSER_CMD_SKIP_2, PARSER_CMD_SKIP_CFG_2);
+
+    WRITE_VREG(HEVC_PARSER_IF_CONTROL, 
+            //  (1 << 8) | // sao_sw_pred_enable
+              (1 << 5) | // parser_sao_if_en
+              (1 << 2) | // parser_mpred_if_en
+              (1 << 0) // parser_scaler_if_en
+            );
+
+    WRITE_VREG(HEVCD_IPP_TOP_CNTL, 
+              (0 << 1) | // enable ipp
+              (1 << 0)   // software reset ipp and mpp
+            );
+    WRITE_VREG(HEVCD_IPP_TOP_CNTL, 
+              (1 << 1) | // enable ipp
+              (0 << 0)   // software reset ipp and mpp
+            );
+}
+
+#ifdef CONFIG_HEVC_CLK_FORCED_ON
+static void config_hevc_clk_forced_on ()
+{
+    unsigned int rdata32;
+    // IQIT
+    rdata32 = READ_VREG(HEVC_IQIT_CLK_RST_CTRL);
+    WRITE_VREG(HEVC_IQIT_CLK_RST_CTRL, rdata32 | (0x1<<2));
+
+    // DBLK
+    rdata32 = READ_VREG(HEVC_DBLK_CFG0);
+    WRITE_VREG(HEVC_DBLK_CFG0, rdata32 | (0x1<<2));
+
+    // SAO
+    rdata32 = READ_VREG(HEVC_SAO_CTRL1);
+    WRITE_VREG(HEVC_SAO_CTRL1, rdata32 | (0x1<<2));
+
+    // MPRED
+    rdata32 = READ_VREG(HEVC_MPRED_CTRL1);
+    WRITE_VREG(HEVC_MPRED_CTRL1, rdata32 | (0x1<<24));
+
+    // PARSER
+    rdata32 = READ_VREG(HEVC_STREAM_CONTROL);
+    WRITE_VREG(HEVC_STREAM_CONTROL, rdata32 | (0x1<<15));
+    rdata32 = READ_VREG(HEVC_SHIFT_CONTROL);
+    WRITE_VREG(HEVC_SHIFT_CONTROL, rdata32 | (0x1<<15));
+    rdata32 = READ_VREG(HEVC_CABAC_CONTROL);
+    WRITE_VREG(HEVC_CABAC_CONTROL, rdata32 | (0x1<<13));
+    rdata32 = READ_VREG(HEVC_PARSER_CORE_CONTROL);
+    WRITE_VREG(HEVC_PARSER_CORE_CONTROL, rdata32 | (0x1<<15));
+    rdata32 = READ_VREG(HEVC_PARSER_INT_CONTROL);
+    WRITE_VREG(HEVC_PARSER_INT_CONTROL, rdata32 | (0x1<<15));
+    rdata32 = READ_VREG(HEVC_PARSER_IF_CONTROL);
+    WRITE_VREG(HEVC_PARSER_IF_CONTROL, rdata32 | (0x3<<5) | (0x3<<2) | (0x3<<0));
+
+    // IPP
+    rdata32 = READ_VREG(HEVCD_IPP_DYNCLKGATE_CONFIG);
+    WRITE_VREG(HEVCD_IPP_DYNCLKGATE_CONFIG, rdata32 | 0xffffffff);
+
+    // MCRCC
+    rdata32 = READ_VREG(HEVCD_MCRCC_CTL1);
+    WRITE_VREG(HEVCD_MCRCC_CTL1, rdata32 | (0x1<<3));
+}
+#endif
+
+#ifdef MCRCC_ENABLE
+static void  config_mcrcc_axi_hw (int slice_type)
+{
+    unsigned int rdata32;
+    unsigned int rdata32_2;
+
+    WRITE_VREG(HEVCD_MCRCC_CTL1, 0x2); // reset mcrcc
+    
+    if ( slice_type  == 2 ) { // I-PIC
+        WRITE_VREG(HEVCD_MCRCC_CTL1, 0x0); // remove reset -- disables clock 
+        return;
+    }
+
+    if ( slice_type == 0 ) {  // B-PIC
+        // Programme canvas0 
+        WRITE_VREG(HEVCD_MPP_ANC_CANVAS_ACCCONFIG_ADDR, (0 << 8) | (0<<1) | 0);
+        rdata32 = READ_VREG(HEVCD_MPP_ANC_CANVAS_DATA_ADDR);
+        rdata32 = rdata32 & 0xffff;
+        rdata32 = rdata32 | ( rdata32 << 16);
+        WRITE_VREG(HEVCD_MCRCC_CTL2, rdata32);
+   
+        // Programme canvas1 
+        WRITE_VREG(HEVCD_MPP_ANC_CANVAS_ACCCONFIG_ADDR, (16 << 8) | (1<<1) | 0);
+        rdata32_2 = READ_VREG(HEVCD_MPP_ANC_CANVAS_DATA_ADDR);
+        rdata32_2 = rdata32_2 & 0xffff;
+        rdata32_2 = rdata32_2 | ( rdata32_2 << 16);
+        if( rdata32 == rdata32_2 ) {
+            rdata32_2 = READ_VREG(HEVCD_MPP_ANC_CANVAS_DATA_ADDR);
+            rdata32_2 = rdata32_2 & 0xffff;
+            rdata32_2 = rdata32_2 | ( rdata32_2 << 16);
+        }
+        WRITE_VREG(HEVCD_MCRCC_CTL3, rdata32_2);
+    } else { // P-PIC 
+        WRITE_VREG(HEVCD_MPP_ANC_CANVAS_ACCCONFIG_ADDR, (0 << 8) | (1<<1) | 0);
+        rdata32 = READ_VREG(HEVCD_MPP_ANC_CANVAS_DATA_ADDR);
+        rdata32 = rdata32 & 0xffff;
+        rdata32 = rdata32 | ( rdata32 << 16);
+        WRITE_VREG(HEVCD_MCRCC_CTL2, rdata32);
+   
+        // Programme canvas1 
+        rdata32 = READ_VREG(HEVCD_MPP_ANC_CANVAS_DATA_ADDR);
+        rdata32 = rdata32 & 0xffff;
+        rdata32 = rdata32 | ( rdata32 << 16);
+        WRITE_VREG(HEVCD_MCRCC_CTL3, rdata32);
+    }
+
+    WRITE_VREG(HEVCD_MCRCC_CTL1, 0xff0); // enable mcrcc progressive-mode 
+    return;
+}
+#endif
+
+
+static void  config_title_hw(hevc_stru_t* hevc, int sao_vb_size, int sao_mem_unit)
+{
+	WRITE_VREG(HEVC_sao_mem_unit, sao_mem_unit);
+	WRITE_VREG(HEVC_SAO_ABV, hevc->work_space_buf->sao_abv.buf_start);
+	WRITE_VREG(HEVC_sao_vb_size, sao_vb_size);
+	WRITE_VREG(HEVC_SAO_VB, hevc->work_space_buf->sao_vb.buf_start);
+}
+
+static void config_mpred_hw(hevc_stru_t* hevc)
+{
+    int i;
+    unsigned int data32;
+    PIC_t* cur_pic = hevc->cur_pic;
+    PIC_t* col_pic = hevc->col_pic;
+    int     AMVP_MAX_NUM_CANDS_MEM=3;
+    int     AMVP_MAX_NUM_CANDS=2;
+    int     NUM_CHROMA_MODE=5;
+    int     DM_CHROMA_IDX=36;
+    int     above_ptr_ctrl =0;
+    int     buffer_linear =1;
+    int     cu_size_log2 =3;
+
+    int     mpred_mv_rd_start_addr ;
+    int     mpred_curr_lcu_x;
+    int     mpred_curr_lcu_y;
+    int     mpred_above_buf_start ;
+    int     mpred_mv_rd_ptr ;
+    int     mpred_mv_rd_ptr_p1 ;
+    int     mpred_mv_rd_end_addr;
+    int     MV_MEM_UNIT;
+    int     mpred_mv_wr_ptr ;
+    int     *ref_poc_L0, *ref_poc_L1;
+
+    int     above_en;
+    int     mv_wr_en;
+    int     mv_rd_en;
+    int     col_isIntra;
+    if(hevc->slice_type!=2)
+    {
+        above_en=1;
+        mv_wr_en=1;
+        mv_rd_en=1;
+        col_isIntra=0;
+    }
+    else 
+    {
+        above_en=1;
+        mv_wr_en=1;
+        mv_rd_en=0;
+        col_isIntra=0;
+    }
+
+    mpred_mv_rd_start_addr=col_pic->mpred_mv_wr_start_addr;
+    data32 = READ_VREG(HEVC_MPRED_CURR_LCU);
+    mpred_curr_lcu_x   =data32 & 0xffff;
+    mpred_curr_lcu_y   =(data32>>16) & 0xffff;
+    
+    MV_MEM_UNIT=hevc->lcu_size_log2==6 ? 0x200 : hevc->lcu_size_log2==5 ? 0x80 : 0x20;
+    mpred_mv_rd_ptr = mpred_mv_rd_start_addr  + (hevc->slice_addr*MV_MEM_UNIT);
+    
+    mpred_mv_rd_ptr_p1  =mpred_mv_rd_ptr+MV_MEM_UNIT;
+    mpred_mv_rd_end_addr=mpred_mv_rd_start_addr + ((hevc->lcu_x_num*hevc->lcu_y_num)*MV_MEM_UNIT);
+    
+    mpred_above_buf_start = hevc->work_space_buf->mpred_above.buf_start;
+    
+    mpred_mv_wr_ptr = cur_pic->mpred_mv_wr_start_addr  + (hevc->slice_addr*MV_MEM_UNIT);
+    
+    if(debug&H265_DEBUG_BUFMGR) 
+        printk("cur pic index %d  col pic index %d\n", cur_pic->index, col_pic->index);
+    
+    WRITE_VREG(HEVC_MPRED_MV_WR_START_ADDR,cur_pic->mpred_mv_wr_start_addr);
+    WRITE_VREG(HEVC_MPRED_MV_RD_START_ADDR,mpred_mv_rd_start_addr);
+    
+    data32 = ((hevc->lcu_x_num - hevc->tile_width_lcu)*MV_MEM_UNIT);
+    WRITE_VREG(HEVC_MPRED_MV_WR_ROW_JUMP,data32);
+    WRITE_VREG(HEVC_MPRED_MV_RD_ROW_JUMP,data32);
+    
+    data32 = READ_VREG(HEVC_MPRED_CTRL0);
+    data32  =   ( 
+        hevc->slice_type | 
+        hevc->new_pic<<2 |
+        hevc->new_tile<<3|
+        hevc->isNextSliceSegment<<4|
+        hevc->TMVPFlag<<5|
+        hevc->LDCFlag<<6|
+        hevc->ColFromL0Flag<<7|
+        above_ptr_ctrl<<8 |  
+        above_en<<9|
+        mv_wr_en<<10|
+        mv_rd_en<<11|
+        col_isIntra<<12|
+        buffer_linear<<13|
+        hevc->LongTerm_Curr<<14|
+        hevc->LongTerm_Col<<15|
+        hevc->lcu_size_log2<<16|
+        cu_size_log2<<20|
+        hevc->plevel<<24 
+        );
+    WRITE_VREG(HEVC_MPRED_CTRL0,data32);
+    
+    data32 = READ_VREG(HEVC_MPRED_CTRL1);
+    data32  =   ( 
+#if 0
+//no set in m8baby test1902
+       (data32 & (0x1<<24)) |  // Don't override clk_forced_on , 
+#endif       
+        hevc->MaxNumMergeCand | 
+        AMVP_MAX_NUM_CANDS<<4 |
+        AMVP_MAX_NUM_CANDS_MEM<<8|
+        NUM_CHROMA_MODE<<12|
+        DM_CHROMA_IDX<<16
+        );
+    WRITE_VREG(HEVC_MPRED_CTRL1,data32);
+    
+    data32  =   (
+          hevc->pic_w|
+          hevc->pic_h<<16   
+          );
+    WRITE_VREG(HEVC_MPRED_PIC_SIZE,data32);
+    
+    data32  =   (
+          (hevc->lcu_x_num-1)   |
+          (hevc->lcu_y_num-1)<<16
+          );
+    WRITE_VREG(HEVC_MPRED_PIC_SIZE_LCU,data32);
+    
+    data32  =   (
+          hevc->tile_start_lcu_x   |
+          hevc->tile_start_lcu_y<<16
+          );
+    WRITE_VREG(HEVC_MPRED_TILE_START,data32);
+    
+    data32  =   (
+          hevc->tile_width_lcu   |
+          hevc->tile_height_lcu<<16
+          );
+    WRITE_VREG(HEVC_MPRED_TILE_SIZE_LCU,data32);
+    
+    data32  =   (
+          hevc->RefNum_L0   |
+          hevc->RefNum_L1<<8|
+          0
+          //col_RefNum_L0<<16|
+          //col_RefNum_L1<<24
+          );
+    WRITE_VREG(HEVC_MPRED_REF_NUM,data32);
+    
+    data32  =   (
+          hevc->LongTerm_Ref   
+          );
+    WRITE_VREG(HEVC_MPRED_LT_REF,data32);
+    
+    
+    data32=0;
+    for(i=0;i<hevc->RefNum_L0;i++)data32=data32|(1<<i);
+    WRITE_VREG(HEVC_MPRED_REF_EN_L0,data32);
+    
+    data32=0;
+    for(i=0;i<hevc->RefNum_L1;i++)data32=data32|(1<<i);
+    WRITE_VREG(HEVC_MPRED_REF_EN_L1,data32);
+    
+    
+    WRITE_VREG(HEVC_MPRED_CUR_POC,hevc->curr_POC);
+    WRITE_VREG(HEVC_MPRED_COL_POC,hevc->Col_POC);
+    
+    //below MPRED Ref_POC_xx_Lx registers must follow Ref_POC_xx_L0 -> Ref_POC_xx_L1 in pair write order!!!
+    ref_poc_L0      = &(cur_pic->m_aiRefPOCList0[cur_pic->slice_idx][0]);
+    ref_poc_L1      = &(cur_pic->m_aiRefPOCList1[cur_pic->slice_idx][0]);
+
+    WRITE_VREG(HEVC_MPRED_L0_REF00_POC,ref_poc_L0[0]);
+    WRITE_VREG(HEVC_MPRED_L1_REF00_POC,ref_poc_L1[0]);
+    
+    WRITE_VREG(HEVC_MPRED_L0_REF01_POC,ref_poc_L0[1]);
+    WRITE_VREG(HEVC_MPRED_L1_REF01_POC,ref_poc_L1[1]);
+    
+    WRITE_VREG(HEVC_MPRED_L0_REF02_POC,ref_poc_L0[2]);
+    WRITE_VREG(HEVC_MPRED_L1_REF02_POC,ref_poc_L1[2]);
+    
+    WRITE_VREG(HEVC_MPRED_L0_REF03_POC,ref_poc_L0[3]);
+    WRITE_VREG(HEVC_MPRED_L1_REF03_POC,ref_poc_L1[3]);
+    
+    WRITE_VREG(HEVC_MPRED_L0_REF04_POC,ref_poc_L0[4]);
+    WRITE_VREG(HEVC_MPRED_L1_REF04_POC,ref_poc_L1[4]);
+    
+    WRITE_VREG(HEVC_MPRED_L0_REF05_POC,ref_poc_L0[5]);
+    WRITE_VREG(HEVC_MPRED_L1_REF05_POC,ref_poc_L1[5]);
+    
+    WRITE_VREG(HEVC_MPRED_L0_REF06_POC,ref_poc_L0[6]);
+    WRITE_VREG(HEVC_MPRED_L1_REF06_POC,ref_poc_L1[6]);
+    
+    WRITE_VREG(HEVC_MPRED_L0_REF07_POC,ref_poc_L0[7]);
+    WRITE_VREG(HEVC_MPRED_L1_REF07_POC,ref_poc_L1[7]);
+    
+    WRITE_VREG(HEVC_MPRED_L0_REF08_POC,ref_poc_L0[8]);
+    WRITE_VREG(HEVC_MPRED_L1_REF08_POC,ref_poc_L1[8]);
+    
+    WRITE_VREG(HEVC_MPRED_L0_REF09_POC,ref_poc_L0[9]);
+    WRITE_VREG(HEVC_MPRED_L1_REF09_POC,ref_poc_L1[9]);
+    
+    WRITE_VREG(HEVC_MPRED_L0_REF10_POC,ref_poc_L0[10]);
+    WRITE_VREG(HEVC_MPRED_L1_REF10_POC,ref_poc_L1[10]);
+    
+    WRITE_VREG(HEVC_MPRED_L0_REF11_POC,ref_poc_L0[11]);
+    WRITE_VREG(HEVC_MPRED_L1_REF11_POC,ref_poc_L1[11]);
+    
+    WRITE_VREG(HEVC_MPRED_L0_REF12_POC,ref_poc_L0[12]);
+    WRITE_VREG(HEVC_MPRED_L1_REF12_POC,ref_poc_L1[12]);
+    
+    WRITE_VREG(HEVC_MPRED_L0_REF13_POC,ref_poc_L0[13]);
+    WRITE_VREG(HEVC_MPRED_L1_REF13_POC,ref_poc_L1[13]);
+    
+    WRITE_VREG(HEVC_MPRED_L0_REF14_POC,ref_poc_L0[14]);
+    WRITE_VREG(HEVC_MPRED_L1_REF14_POC,ref_poc_L1[14]);
+    
+    WRITE_VREG(HEVC_MPRED_L0_REF15_POC,ref_poc_L0[15]);
+    WRITE_VREG(HEVC_MPRED_L1_REF15_POC,ref_poc_L1[15]);
+    
+    
+    if(hevc->new_pic)
+    {
+        WRITE_VREG(HEVC_MPRED_ABV_START_ADDR,mpred_above_buf_start);
+        WRITE_VREG(HEVC_MPRED_MV_WPTR,mpred_mv_wr_ptr);
+        //WRITE_VREG(HEVC_MPRED_MV_RPTR,mpred_mv_rd_ptr);
+        WRITE_VREG(HEVC_MPRED_MV_RPTR,mpred_mv_rd_start_addr);
+    }
+    else if(!hevc->isNextSliceSegment)
+    {
+        //WRITE_VREG(HEVC_MPRED_MV_RPTR,mpred_mv_rd_ptr_p1);
+        WRITE_VREG(HEVC_MPRED_MV_RPTR,mpred_mv_rd_ptr);
+    }
+    
+    WRITE_VREG(HEVC_MPRED_MV_RD_END_ADDR,mpred_mv_rd_end_addr);
+}
+
+static void config_sao_hw(hevc_stru_t* hevc, param_t* params)
+{
+    unsigned int data32, data32_2;
+    int misc_flag0 = hevc->misc_flag0; 
+    int slice_deblocking_filter_disabled_flag = 0;
+               
+    int mc_buffer_size_u_v = hevc->lcu_total*hevc->lcu_size*hevc->lcu_size/2;
+    int mc_buffer_size_u_v_h = (mc_buffer_size_u_v + 0xffff)>>16;
+    PIC_t* cur_pic = hevc->cur_pic;
+            
+    data32 = READ_VREG(HEVC_SAO_CTRL0);	
+    data32 &= (~0xf);
+    data32 |= hevc->lcu_size_log2;
+    WRITE_VREG(HEVC_SAO_CTRL0, data32);
+
+    data32  =   (
+            hevc->pic_w|
+            hevc->pic_h<<16   
+            );
+    WRITE_VREG(HEVC_SAO_PIC_SIZE , data32);
+
+    data32  =   (
+            (hevc->lcu_x_num-1)   |
+            (hevc->lcu_y_num-1)<<16
+            );
+    WRITE_VREG(HEVC_SAO_PIC_SIZE_LCU , data32);
+    
+    if(hevc->new_pic) WRITE_VREG(HEVC_SAO_Y_START_ADDR,0xffffffff);
+    data32 = cur_pic->mc_y_adr;
+    WRITE_VREG(HEVC_SAO_Y_START_ADDR,data32);
+    
+    data32 = (mc_buffer_size_u_v_h<<16)<<1;
+    //printk("data32 = %x, mc_buffer_size_u_v_h = %x, lcu_total = %x, lcu_size = %x\n", data32, mc_buffer_size_u_v_h, lcu_total, lcu_size);
+    WRITE_VREG(HEVC_SAO_Y_LENGTH ,data32);
+
+    data32 = cur_pic->mc_u_v_adr;
+    WRITE_VREG(HEVC_SAO_C_START_ADDR,data32);
+
+    data32 = (mc_buffer_size_u_v_h<<16);
+    WRITE_VREG(HEVC_SAO_C_LENGTH  ,data32);
+
+    /* multi tile to do... */
+    data32 = cur_pic->mc_y_adr;
+    WRITE_VREG(HEVC_SAO_Y_WPTR ,data32);
+
+    data32 = cur_pic->mc_u_v_adr;
+    WRITE_VREG(HEVC_SAO_C_WPTR ,data32);
+    
+    // DBLK CONFIG HERE
+    if(hevc->new_pic){
+        data32  =   (
+            hevc->pic_w|
+            hevc->pic_h<<16   
+        );
+        WRITE_VREG( HEVC_DBLK_CFG2, data32);
+        
+        if((misc_flag0>>PCM_ENABLE_FLAG_BIT)&0x1)
+            data32 = ((misc_flag0>>PCM_LOOP_FILTER_DISABLED_FLAG_BIT)&0x1)<<3;
+        else data32 = 0;
+        data32 |= (((params->p.pps_cb_qp_offset&0x1f)<<4)|((params->p.pps_cr_qp_offset&0x1f)<<9));
+        data32 |= (hevc->lcu_size==64)?0:((hevc->lcu_size==32)?1:2);
+        
+        WRITE_VREG( HEVC_DBLK_CFG1, data32);
+    }
+
+#if 0
+    data32 = READ_VREG( HEVC_SAO_CTRL1);
+    data32 &= (~0x3000);
+    data32 |= (MEM_MAP_MODE << 12); // [13:12] axi_aformat, 0-Linear, 1-32x32, 2-64x32
+    WRITE_VREG( HEVC_SAO_CTRL1, data32);
+    
+    data32 = READ_VREG( HEVCD_IPP_AXIIF_CONFIG);
+    data32 &= (~0x30);
+    data32 |= (MEM_MAP_MODE << 4); // [5:4]    -- address_format 00:linear 01:32x32 10:64x32
+    WRITE_VREG( HEVCD_IPP_AXIIF_CONFIG, data32);
+#else
+// m8baby test1902
+   data32 = READ_VREG( HEVC_SAO_CTRL1);
+	data32 &= (~0x3000);
+	data32 |= (MEM_MAP_MODE << 12); // [13:12] axi_aformat, 0-Linear, 1-32x32, 2-64x32
+    data32 &= (~0xff0);
+    //data32 |= 0x670;  // Big-Endian per 64-bit
+    data32 |= 0x880;  // Big-Endian per 64-bit
+    WRITE_VREG( HEVC_SAO_CTRL1, data32);
+
+    data32 = READ_VREG( HEVCD_IPP_AXIIF_CONFIG);
+	data32 &= (~0x30);
+	data32 |= (MEM_MAP_MODE << 4); // [5:4]    -- address_format 00:linear 01:32x32 10:64x32
+	data32 &= (~0xF);
+    data32 |= 0x8;    // Big-Endian per 64-bit
+    WRITE_VREG( HEVCD_IPP_AXIIF_CONFIG, data32);
+#endif    
+    data32 = 0;	
+    data32_2 = READ_VREG( HEVC_SAO_CTRL0);
+    data32_2 &= (~0x300);
+    //slice_deblocking_filter_disabled_flag = 0; //ucode has handle it , so read it from ucode directly
+    //printk("\nconfig dblk HEVC_DBLK_CFG9: misc_flag0 %x tile_enabled %x; data32 is:", misc_flag0, tile_enabled);
+    if(hevc->tile_enabled) {
+        data32 |= ((misc_flag0>>LOOP_FILER_ACROSS_TILES_ENABLED_FLAG_BIT)&0x1)<<0;
+        data32_2 |= ((misc_flag0>>LOOP_FILER_ACROSS_TILES_ENABLED_FLAG_BIT)&0x1)<<8;
+    }
+    slice_deblocking_filter_disabled_flag =	(misc_flag0>>SLICE_DEBLOCKING_FILTER_DISABLED_FLAG_BIT)&0x1;	//ucode has handle it , so read it from ucode directly
+    if((misc_flag0&(1<<DEBLOCKING_FILTER_OVERRIDE_ENABLED_FLAG_BIT))
+        &&(misc_flag0&(1<<DEBLOCKING_FILTER_OVERRIDE_FLAG_BIT))){
+        //slice_deblocking_filter_disabled_flag =	(misc_flag0>>SLICE_DEBLOCKING_FILTER_DISABLED_FLAG_BIT)&0x1;	//ucode has handle it , so read it from ucode directly
+        data32 |= slice_deblocking_filter_disabled_flag<<2;
+        if(debug&H265_DEBUG_BUFMGR) printk("(1,%x)", data32);
+        if(!slice_deblocking_filter_disabled_flag){
+            data32 |= (params->p.slice_beta_offset_div2&0xf)<<3;
+            data32 |= (params->p.slice_tc_offset_div2&0xf)<<7;
+            if(debug&H265_DEBUG_BUFMGR) printk("(2,%x)", data32);
+        }
+    }
+    else{
+        data32 |= ((misc_flag0>>PPS_DEBLOCKING_FILTER_DISABLED_FLAG_BIT)&0x1)<<2;
+        if(debug&H265_DEBUG_BUFMGR) printk("(3,%x)", data32);
+        if(((misc_flag0>>PPS_DEBLOCKING_FILTER_DISABLED_FLAG_BIT)&0x1)==0){
+            data32 |= (params->p.pps_beta_offset_div2&0xf)<<3;
+            data32 |= (params->p.pps_tc_offset_div2&0xf)<<7;
+            if(debug&H265_DEBUG_BUFMGR) printk("(4,%x)", data32);
+        }
+    }
+    if((misc_flag0&(1<<PPS_LOOP_FILTER_ACROSS_SLICES_ENABLED_FLAG_BIT))&&
+       ((misc_flag0&(1<<SLICE_SAO_LUMA_FLAG_BIT))||(misc_flag0&(1<<SLICE_SAO_CHROMA_FLAG_BIT))||(!slice_deblocking_filter_disabled_flag))) {
+        data32 |= ((misc_flag0>>SLICE_LOOP_FILTER_ACROSS_SLICES_ENABLED_FLAG_BIT)&0x1)<<1;
+        data32_2 |= ((misc_flag0>>SLICE_LOOP_FILTER_ACROSS_SLICES_ENABLED_FLAG_BIT)&0x1)<<9;
+        if(debug&H265_DEBUG_BUFMGR) printk("(5,%x)\n", data32);
+    }
+    else{
+        data32 |= ((misc_flag0>>PPS_LOOP_FILTER_ACROSS_SLICES_ENABLED_FLAG_BIT)&0x1)<<1;
+        data32_2 |= ((misc_flag0>>PPS_LOOP_FILTER_ACROSS_SLICES_ENABLED_FLAG_BIT)&0x1)<<9;
+        if(debug&H265_DEBUG_BUFMGR) printk("(6,%x)\n", data32);
+    }
+    WRITE_VREG( HEVC_DBLK_CFG9, data32);
+    WRITE_VREG( HEVC_SAO_CTRL0, data32_2);
+}                
+
+static void clear_used_by_display_flag(void)
+{
+  PIC_t* pic;
+  int i;
+  for (i = 0; i < MAX_REF_PIC_NUM; i++) {
+      pic = &m_PIC[i];
+      pic->used_by_display = 0;
+  }
+}
+
+static PIC_t* get_new_pic(hevc_stru_t* hevc, param_t* rpm_param)
+{
+    PIC_t* new_pic=NULL;
+    PIC_t* pic;
+    /* recycle un-used pic */
+    int i;
+    for(i=0; i<MAX_REF_PIC_NUM; i++){
+        pic = &m_PIC[i];
+        if(pic->index == -1) 
+            continue;
+        if(pic->output_mark == 0 && pic->referenced == 0
+                && pic->output_ready == 0
+                && pic->used_by_display == 0
+            ){
+            if(new_pic){
+                if(pic->POC < new_pic->POC)
+                    new_pic = pic;
+            }
+            else{
+                new_pic = pic;
+            }
+        }
+    }
+
+    if(new_pic == NULL){
+        int ii;
+        for(ii=0; ii<MAX_REF_PIC_NUM; ii++){
+            if(m_PIC[ii].index == -1){
+                break;    
+            }    
+        }
+        if(ii < MAX_REF_PIC_NUM){
+            new_pic = &m_PIC[ii];
+            memset(new_pic, 0, sizeof(PIC_t));
+            new_pic->index = ii;
+            new_pic->BUF_index = -1;
+        }   
+    }
+
+    if(new_pic == NULL){
+        //printk("Error: Buffer management, no free buffer\n");
+        return new_pic;
+    }
+
+    new_pic->referenced = 1;
+    if(new_pic->width != hevc->pic_w || new_pic->height != hevc->pic_h){
+        recycle_buf(hevc);
+        //if(new_pic->BUF_index == -1){
+            if(config_pic(hevc, new_pic)<0){
+                if (debug & H265_DEBUG_BUFMGR_MORE) {
+                    printk("Config_pic %d fail\n", new_pic->index);
+                    dump_pic_list(hevc);
+                }
+                new_pic->index = -1;
+                new_pic = NULL;
+            }
+            else{
+                init_pic_list_hw();
+            }            
+        //}
+        //else{
+        //   printk("++++++++++++++++++++++Error: can not happen!!!\n");
+        //}
+        if(new_pic){
+            new_pic->width = hevc->pic_w;
+            new_pic->height = hevc->pic_h;
+            set_canvas(new_pic);
+        }
+    }
+    if(new_pic){
+        new_pic->decode_idx = hevc->decode_idx;
+        new_pic->slice_idx = 0;
+        new_pic->referenced = 1;
+        new_pic->output_mark = 0;
+        new_pic->recon_mark = 0;
+        new_pic->error_mark = 0;
+        //new_pic->output_ready = 0;
+        new_pic->num_reorder_pic = rpm_param->p.sps_num_reorder_pics_0;
+        new_pic->POC = hevc->curr_POC;
+        new_pic->pic_struct = hevc->curr_pic_struct;
+    }        
+    return new_pic;
+}
+
+static int get_display_pic_num(hevc_stru_t* hevc)
+{
+    int i;
+    PIC_t* pic;
+    int num = 0;      
+    for(i=0; i<MAX_REF_PIC_NUM; i++){
+        pic = &m_PIC[i];
+        if(pic->index == -1) 
+            continue;
+
+        if(pic->output_ready == 1){
+            num++;
+        }
+    }
+    return num;
+}
+
+static void clear_referenced_flag(hevc_stru_t* hevc)
+{
+    int i;
+    for (i = 0; i < MAX_REF_PIC_NUM; i++) {
+      PIC_t *pic = &m_PIC[i];
+      if (pic->index == -1)
+          continue;
+      pic->referenced = 0;
+    }
+
+}
+
+static void flush_output(hevc_stru_t* hevc, PIC_t* pic)
+{
+    PIC_t* pic_display;
+    if(pic){
+        /*PB skip control*/
+        if(pic->error_mark==0 && hevc->PB_skip_mode==1){
+            hevc->ignore_bufmgr_error|=0x1;  //start decoding after first I
+        }
+        if(hevc->ignore_bufmgr_error&1){
+            if(hevc->PB_skip_count_after_decoding>0){
+                hevc->PB_skip_count_after_decoding--;
+            }
+            else{
+                hevc->ignore_bufmgr_error|=0x2; //start displaying
+            }
+        }
+        /**/
+        if (pic->POC != INVALID_POC) {
+            pic->output_mark = 1;
+            pic->recon_mark = 1;
+        }
+        pic->recon_mark = 1;
+    }
+    do {
+        pic_display = output_pic(hevc, 1);
+
+        if(pic_display){
+            pic_display->referenced = 0;
+            if((pic_display->error_mark && ((hevc->ignore_bufmgr_error&0x2)==0))
+                ||(debug&H265_DEBUG_DISPLAY_CUR_FRAME)||(debug&H265_DEBUG_NO_DISPLAY)){
+           			 pic_display->output_ready = 0;
+                 if(debug&H265_DEBUG_BUFMGR) printk("[Buffer Management] Display: POC %d, decoding index %d ==> Debug mode or error, recycle it\n", pic_display->POC, pic_display->decode_idx);
+            }
+            else{
+                if (i_only_flag&0x1 && pic_display->slice_type != 2) {
+                    pic_display->output_ready = 0;
+                }
+                else{
+                    prepare_display_buf(hevc, pic_display);
+                    if (debug&H265_DEBUG_BUFMGR)
+                        printk("[Buffer Management] Display: POC %d, decoding index %d\n", pic_display->POC, pic_display->decode_idx);
+                }
+            }
+        }
+    }while(pic_display);
+    clear_referenced_flag(hevc);
+}
+
+static void check_pic_decoded_lcu_count(hevc_stru_t* hevc)
+{
+  int current_lcu_idx = READ_VREG(HEVC_PARSER_LCU_START)&0xffffff;
+  if (debug & H265_DEBUG_BUFMGR) {
+    printk("cur lcu idx = %d, (total %d)\n", current_lcu_idx, hevc->lcu_total);
+  }
+
+  if ((error_handle_policy & 0x20) == 0 && hevc->cur_pic != NULL
+      && hevc->lcu_total != 0
+      && current_lcu_idx != 0
+      && current_lcu_idx < ((hevc->lcu_x_num*hevc->lcu_y_num) - 1)) {
+      printk("cur lcu idx = %d, (total %d), set error_mark\n", current_lcu_idx, hevc->lcu_total);
+      hevc->cur_pic->error_mark = 1;
+  }
+}
+
+static int hevc_slice_segment_header_process(hevc_stru_t* hevc, param_t* rpm_param, int decode_pic_begin)
+{
+    int i;
+    int     pic_w_64;
+    int     pic_h_32;
+    int     lcu_x_num_64;
+    int     lcu_y_num_32;
+    int     lcu_y_num_32_2;
+    int     lcu_x_num_div_64;
+    int     lcu_y_num_div_32;
+    int     lcu_x_num_div;
+    int     lcu_y_num_div;
+    int     Col_ref         ;
+    if(hevc->wait_buf == 0){
+        hevc->sps_num_reorder_pics_0 =
+          rpm_param->p.sps_num_reorder_pics_0;
+        hevc->m_temporalId = rpm_param->p.m_temporalId;
+        hevc->m_nalUnitType = rpm_param->p.m_nalUnitType;
+        hevc->interlace_flag = (rpm_param->p.profile_etc >> 2) & 0x1;
+        hevc->curr_pic_struct = (rpm_param->p.sei_frame_field_info >> 3) & 0xf;
+        if (interlace_enable == 0)
+          hevc->interlace_flag = 0;
+
+        if (interlace_enable & 0x100)
+          hevc->interlace_flag = interlace_enable & 0x1;
+
+        if (hevc->interlace_flag == 0)
+          hevc->curr_pic_struct = 0;
+
+        //if(hevc->m_nalUnitType == NAL_UNIT_EOS){ 
+        //    hevc->m_pocRandomAccess = MAX_INT; //add to fix RAP_B_Bossen_1
+        //}
+        hevc->misc_flag0 = rpm_param->p.misc_flag0;
+        if(rpm_param->p.first_slice_segment_in_pic_flag==0){
+            hevc->slice_segment_addr = rpm_param->p.slice_segment_address;
+            if(!rpm_param->p.dependent_slice_segment_flag){
+                hevc->slice_addr = hevc->slice_segment_addr;
+            }
+        }
+        else{
+            hevc->slice_segment_addr = 0;
+            hevc->slice_addr = 0;
+        }
+    
+        hevc->iPrevPOC = hevc->curr_POC;
+        hevc->slice_type =      (rpm_param->p.slice_type == I_SLICE ) ? 2 :
+                          (rpm_param->p.slice_type == P_SLICE ) ? 1 :
+                          (rpm_param->p.slice_type == B_SLICE ) ? 0 : 3;
+        //hevc->curr_predFlag_L0=(hevc->slice_type==2) ? 0:1;
+        //hevc->curr_predFlag_L1=(hevc->slice_type==0) ? 1:0;
+        hevc->TMVPFlag	= rpm_param->p.slice_temporal_mvp_enable_flag;
+        hevc->isNextSliceSegment=rpm_param->p.dependent_slice_segment_flag?1:0;
+        if(hevc->pic_w!=rpm_param->p.pic_width_in_luma_samples || 
+            hevc->pic_h!=rpm_param->p.pic_height_in_luma_samples){
+            printk("Picture Width/Height Change (%d,%d)=>(%d,%d) interlace %d\n",
+                hevc->pic_w, hevc->pic_h,
+                rpm_param->p.pic_width_in_luma_samples, rpm_param->p.pic_height_in_luma_samples,
+                hevc->interlace_flag);
+        }
+        
+        hevc->pic_w           =rpm_param->p.pic_width_in_luma_samples;
+        hevc->pic_h           =rpm_param->p.pic_height_in_luma_samples;
+        if(hevc->pic_w == 0 || hevc->pic_h == 0 ){ //it will cause divide 0 error
+            if(debug) printk("Fatal Error, pic_w = %d, pic_h = %d\n", hevc->pic_w, hevc->pic_h);
+            return 3;
+        }
+        hevc->lcu_size        = 1<<(rpm_param->p.log2_min_coding_block_size_minus3+3+rpm_param->p.log2_diff_max_min_coding_block_size);
+        if(hevc->lcu_size == 0){
+            printk("Error, lcu_size = 0 (%d,%d)\n",rpm_param->p.log2_min_coding_block_size_minus3, rpm_param->p.log2_diff_max_min_coding_block_size);
+            return 3;
+        }
+        hevc->lcu_size_log2   =log2i(hevc->lcu_size);
+#if 1
+        pic_w_64 = (hevc->pic_w + 63) & (~0x3f);
+        pic_h_32 = (hevc->pic_h + 31) & (~0x1f);
+
+        lcu_x_num_div   = (hevc->pic_w / hevc->lcu_size);
+        lcu_y_num_div   = (hevc->pic_h / hevc->lcu_size);
+        hevc->lcu_x_num       = ((hevc->pic_w % hevc->lcu_size) == 0) ? lcu_x_num_div : lcu_x_num_div + 1;
+        hevc->lcu_y_num       = ((hevc->pic_h % hevc->lcu_size) == 0) ? lcu_y_num_div : lcu_y_num_div + 1;
+
+        lcu_x_num_div_64   =(pic_w_64/ hevc->lcu_size);
+        lcu_y_num_div_32   =(pic_h_32/ hevc->lcu_size);
+        lcu_x_num_64       =((pic_w_64 % hevc->lcu_size) == 0) ? lcu_x_num_div_64 : lcu_x_num_div_64 + 1;
+        lcu_y_num_32       =((pic_h_32 % hevc->lcu_size) == 0) ? lcu_y_num_div_32 : lcu_y_num_div_32 + 1;
+        //lcu_y_num_32_2     = (lcu_y_num_32 + 1) & (~0x1);
+        lcu_y_num_32_2     = (hevc->lcu_size == 32) ? (lcu_y_num_32 + 1) & (~0x1) : ((hevc->lcu_size == 16) ?  (lcu_y_num_32 + 4) & (~0x3) :
+                            lcu_y_num_32);
+        hevc->lcu_total       = lcu_x_num_64 * lcu_y_num_32_2;
+#else
+        lcu_x_num_div   =(hevc->pic_w/ hevc->lcu_size);
+        lcu_y_num_div   =(hevc->pic_h/ hevc->lcu_size);
+        hevc->lcu_x_num       =((hevc->pic_w% hevc->lcu_size) == 0) ? lcu_x_num_div : lcu_x_num_div+1;
+        hevc->lcu_y_num       =((hevc->pic_h% hevc->lcu_size) == 0) ? lcu_y_num_div : lcu_y_num_div+1;
+        hevc->lcu_total       =hevc->lcu_x_num*hevc->lcu_y_num;
+#endif
+    
+        if(hevc->m_nalUnitType == NAL_UNIT_CODED_SLICE_IDR || hevc->m_nalUnitType == NAL_UNIT_CODED_SLICE_IDR_N_LP){
+            hevc->curr_POC = 0;
+            if((hevc->m_temporalId - 1) == 0){
+                hevc->iPrevTid0POC = hevc->curr_POC;
+            }
+        }
+        else{
+            int iMaxPOClsb = 1<<(rpm_param->p.log2_max_pic_order_cnt_lsb_minus4+4);
+            int iPrevPOClsb;
+            int iPrevPOCmsb;
+            int iPOCmsb;
+            int iPOClsb = rpm_param->p.POClsb;
+            if(iMaxPOClsb==0){
+                printk("error iMaxPOClsb is 0\n");    
+                return 3;
+            }        
+            
+            iPrevPOClsb = hevc->iPrevTid0POC%iMaxPOClsb;
+            iPrevPOCmsb = hevc->iPrevTid0POC-iPrevPOClsb;
+            
+            if( ( iPOClsb  <  iPrevPOClsb ) && ( ( iPrevPOClsb - iPOClsb )  >=  ( iMaxPOClsb / 2 ) ) )
+            {
+                iPOCmsb = iPrevPOCmsb + iMaxPOClsb;
+            }
+            else if( (iPOClsb  >  iPrevPOClsb )  && ( (iPOClsb - iPrevPOClsb )  >  ( iMaxPOClsb / 2 ) ) ) 
+            {
+                iPOCmsb = iPrevPOCmsb - iMaxPOClsb;
+            }
+            else
+            {
+                iPOCmsb = iPrevPOCmsb;
+            }
+            if(debug&H265_DEBUG_BUFMGR){
+                printk("iPrePOC  %d iMaxPOClsb %d iPOCmsb %d iPOClsb %d\n", hevc->iPrevTid0POC, iMaxPOClsb, iPOCmsb, iPOClsb);
+            }
+            if ( hevc->m_nalUnitType == NAL_UNIT_CODED_SLICE_BLA
+                || hevc->m_nalUnitType == NAL_UNIT_CODED_SLICE_BLANT
+                || hevc->m_nalUnitType == NAL_UNIT_CODED_SLICE_BLA_N_LP )
+            {
+                // For BLA picture types, POCmsb is set to 0.
+                iPOCmsb = 0;
+            }
+            hevc->curr_POC  =  (iPOCmsb+iPOClsb);
+            if((hevc->m_temporalId - 1) == 0){
+                hevc->iPrevTid0POC = hevc->curr_POC;
+            }
+            else{
+                if(debug&H265_DEBUG_BUFMGR){
+                    printk("m_temporalID is %d\n", hevc->m_temporalId); 		
+                }
+            }
+        }
+        hevc->RefNum_L0       =(rpm_param->p.num_ref_idx_l0_active>MAX_REF_ACTIVE)?MAX_REF_ACTIVE:rpm_param->p.num_ref_idx_l0_active;
+        hevc->RefNum_L1       =(rpm_param->p.num_ref_idx_l1_active>MAX_REF_ACTIVE)?MAX_REF_ACTIVE:rpm_param->p.num_ref_idx_l1_active;
+        
+        //if(curr_POC==0x10) dump_lmem();
+        
+        /* skip RASL pictures after CRA/BLA pictures */
+        if(hevc->m_pocRandomAccess == MAX_INT){ //first picture
+            if (   hevc->m_nalUnitType == NAL_UNIT_CODED_SLICE_CRA || 
+                hevc->m_nalUnitType == NAL_UNIT_CODED_SLICE_BLA || hevc->m_nalUnitType == NAL_UNIT_CODED_SLICE_BLANT || hevc->m_nalUnitType == NAL_UNIT_CODED_SLICE_BLA_N_LP )
+            {
+                hevc->m_pocRandomAccess = hevc->curr_POC;
+            }
+            else{
+                hevc->m_pocRandomAccess = - MAX_INT;
+            }
+        }
+        else if (hevc->m_nalUnitType == NAL_UNIT_CODED_SLICE_BLA || hevc->m_nalUnitType == NAL_UNIT_CODED_SLICE_BLANT || hevc->m_nalUnitType == NAL_UNIT_CODED_SLICE_BLA_N_LP )
+        {
+            hevc->m_pocRandomAccess = hevc->curr_POC;
+        }
+        else if( hevc->m_nalUnitType == NAL_UNIT_CODED_SLICE_IDR_N_LP || hevc->m_nalUnitType == NAL_UNIT_CODED_SLICE_IDR){
+          //work around zte stream: NAL_UNIT_CODED_SLICE_TFD is sent after NAL_UNIT_CODED_SLICE_IDR
+            hevc->m_pocRandomAccess = - MAX_INT;
+        }
+        else if((hevc->curr_POC<hevc->m_pocRandomAccess)&&(hevc->m_nalUnitType == NAL_UNIT_CODED_SLICE_RASL_N || hevc->m_nalUnitType == NAL_UNIT_CODED_SLICE_TFD)){ //skip
+            if(debug) printk("RASL picture with POC %d < %d (RandomAccess point POC), skip it\n", hevc->curr_POC, hevc->m_pocRandomAccess);
+            return 1;
+        }
+    
+        WRITE_VREG(HEVC_WAIT_FLAG, READ_VREG(HEVC_WAIT_FLAG)|0x2);            
+        hevc->skip_flag = 0;
+        /**/
+        
+        //	if((iPrevPOC != curr_POC)){
+        if(rpm_param->p.slice_segment_address == 0){
+            PIC_t* pic;
+            hevc->new_pic=1;
+            check_pic_decoded_lcu_count(hevc);
+            /**/
+            if(use_cma == 0){
+                if(hevc->pic_list_init_flag == 0){
+                    init_buf_list(hevc);
+                    init_pic_list(hevc);
+                    init_pic_list_hw();
+                    init_buf_spec(hevc);
+                    hevc->pic_list_init_flag = 3;
+                }
+            }
+            
+            if(debug&H265_DEBUG_BUFMGR_MORE) dump_pic_list(hevc);
+            /* prev pic */
+            if(hevc->curr_POC!=0){
+                PIC_t* pic_display;
+                pic = get_pic_by_POC(hevc, hevc->iPrevPOC);
+								if (pic && (pic->POC != INVALID_POC)) {
+                    /*PB skip control*/
+                    if(pic->error_mark==0 && hevc->PB_skip_mode==1){
+                        hevc->ignore_bufmgr_error|=0x1;  //start decoding after first I
+                    }
+                    if(hevc->ignore_bufmgr_error&1){
+                        if(hevc->PB_skip_count_after_decoding>0){
+                            hevc->PB_skip_count_after_decoding--;
+                        }
+                        else{
+                            hevc->ignore_bufmgr_error|=0x2; //start displaying
+                        }
+                    }
+                    /**/
+                    pic->output_mark = 1;
+                    pic->recon_mark = 1;
+                }
+                do {
+                    pic_display = output_pic(hevc, 0);
+
+                    if(pic_display){
+                        if((pic_display->error_mark && ((hevc->ignore_bufmgr_error&0x2)==0))
+                            ||(debug&H265_DEBUG_DISPLAY_CUR_FRAME)||(debug&H265_DEBUG_NO_DISPLAY)){
+                            pic_display->output_ready = 0;
+                            if(debug&H265_DEBUG_BUFMGR) printk("[Buffer Management] Display: POC %d, decoding index %d ==> Debug mode or error, recycle it\n", pic_display->POC, pic_display->decode_idx);
+                        }
+                        else{
+                            if (i_only_flag&0x1 && pic_display->slice_type != 2) {
+                                pic_display->output_ready = 0;
+                            }
+                            else{
+                                prepare_display_buf(hevc, pic_display);
+                                if (debug&H265_DEBUG_BUFMGR)
+                                    printk("[Buffer Management] Display: POC %d, decoding index %d, index %d\n", pic_display->POC,
+                                      pic_display->decode_idx, pic_display->index);
+                            }
+                        }
+                    }
+                }while(pic_display);
+            }
+            else{
+                //if(hevc->iPrevPOC!=0){ /* flush */
+                    if(debug&H265_DEBUG_BUFMGR){
+                        printk("[Buffer Management] current pic is IDR, clear referenced flag of all buffers\n");
+                    }
+                    if(debug&H265_DEBUG_BUFMGR){
+                        dump_pic_list(hevc);
+                    }
+                    pic = get_pic_by_POC(hevc, hevc->iPrevPOC);
+                    flush_output(hevc, pic);
+                //}
+            }
+            
+            apply_ref_pic_set(hevc, hevc->curr_POC, rpm_param); //update referenced of old pictures (cur_pic->referenced is 1 and not updated)
+            /* new pic */
+            hevc->cur_pic = get_new_pic(hevc, rpm_param);
+            if(hevc->cur_pic == NULL){
+                if(debug&H265_DEBUG_BUFMGR){
+                    dump_pic_list(hevc);
+                }
+                hevc->wait_buf = 1;
+                return -1;
+            }            
+            if(debug&H265_DEBUG_DISPLAY_CUR_FRAME){
+                hevc->cur_pic->output_ready = 1;
+                hevc->cur_pic->stream_offset = READ_VREG(HEVC_SHIFT_BYTE_COUNT);
+                prepare_display_buf(hevc, hevc->cur_pic);    
+                hevc->wait_buf = 2;
+                return -1;
+            }        
+        }
+        else{
+            if(hevc->pic_list_init_flag!=3 || hevc->cur_pic==NULL){
+                return 3; //make it decode from the first slice segment    
+            }
+            hevc->cur_pic->slice_idx++;
+            hevc->new_pic =0;
+        }
+    }
+    else{
+        if(hevc->wait_buf == 1){
+            hevc->cur_pic = get_new_pic(hevc, rpm_param);
+            if(hevc->cur_pic == NULL){
+                return -1;
+            }
+            hevc->wait_buf = 0;            
+        }
+        else if(hevc->wait_buf == 2){ // for case: debug&H265_DEBUG_DISPLAY_CUR_FRAME
+            if(get_display_pic_num(hevc)>1){ //start decoding only when video is displaying cur buf
+                return -1;
+            }
+            hevc->wait_buf = 0;    
+        }
+        if(debug&H265_DEBUG_BUFMGR_MORE) dump_pic_list(hevc);
+    }
+        
+    if(hevc->new_pic){
+        int sao_mem_unit = ((hevc->lcu_size/8)*2 + 4 )<<4;
+        int pic_height_cu = (hevc->pic_h+hevc->lcu_size-1)/hevc->lcu_size;
+        int pic_width_cu = (hevc->pic_w+hevc->lcu_size-1)/hevc->lcu_size;
+		    int sao_vb_size = (sao_mem_unit+(2<<4))*pic_height_cu;
+		    //int sao_abv_size = sao_mem_unit*pic_width_cu;
+        if(debug&H265_DEBUG_BUFMGR){
+            printk("=========>%s decode index %d, pic_struct %d interlace_flag %d\n",
+              __func__, hevc->decode_idx, hevc->curr_pic_struct, hevc->interlace_flag);
+        }
+        hevc->decode_idx++;
+        update_tile_info(hevc, pic_width_cu , pic_height_cu , sao_mem_unit, rpm_param);
+
+        config_title_hw(hevc, sao_vb_size, sao_mem_unit);
+    }
+    
+    if(hevc->iPrevPOC != hevc->curr_POC){
+        hevc->new_tile = 1;
+        hevc->tile_x = 0;
+        hevc->tile_y = 0;
+        hevc->tile_y_x = 0;
+        if(debug&H265_DEBUG_BUFMGR){
+            printk("new_tile (new_pic) tile_x=%d, tile_y=%d\n", hevc->tile_x, hevc->tile_y);
+        }
+    }
+    else if(hevc->tile_enabled){
+        if(debug&H265_DEBUG_BUFMGR){
+            printk("slice_segment_address is %d\n", rpm_param->p.slice_segment_address);
+        }
+        hevc->tile_y_x = get_tile_index(hevc, rpm_param->p.slice_segment_address, (hevc->pic_w+hevc->lcu_size-1)/hevc->lcu_size);
+        if(hevc->tile_y_x != (hevc->tile_x|(hevc->tile_y<<8))){
+            hevc->new_tile = 1;
+            hevc->tile_x = hevc->tile_y_x&0xff;
+            hevc->tile_y = (hevc->tile_y_x>>8)&0xff;
+            if(debug&H265_DEBUG_BUFMGR){
+                printk("new_tile segment_adr %d tile_x=%d, tile_y=%d\n", rpm_param->p.slice_segment_address, hevc->tile_x, hevc->tile_y);
+            }
+        }
+        else{
+            hevc->new_tile = 0;
+        }	
+    }
+    else{
+        hevc->new_tile = 0;
+    }
+    
+    if(hevc->new_tile){
+        hevc->tile_start_lcu_x = m_tile[hevc->tile_y][hevc->tile_x].start_cu_x;
+        hevc->tile_start_lcu_y = m_tile[hevc->tile_y][hevc->tile_x].start_cu_y;
+        hevc->tile_width_lcu  = m_tile[hevc->tile_y][hevc->tile_x].width;
+        hevc->tile_height_lcu = m_tile[hevc->tile_y][hevc->tile_x].height;
+    }
+    
+    set_ref_pic_list(hevc->cur_pic, rpm_param);
+    
+    
+    Col_ref=rpm_param->p.collocated_ref_idx;
+    
+    hevc->LDCFlag = 0;        
+    if(rpm_param->p.slice_type != I_SLICE){
+        hevc->LDCFlag = 1;
+        for(i=0; (i<hevc->RefNum_L0) && hevc->LDCFlag; i++){
+            if(hevc->cur_pic->m_aiRefPOCList0[hevc->cur_pic->slice_idx][i]>hevc->curr_POC){
+                hevc->LDCFlag = 0;
+            }
+        }
+        if(rpm_param->p.slice_type == B_SLICE){
+            for(i=0; (i<hevc->RefNum_L1) && hevc->LDCFlag; i++){
+                if(hevc->cur_pic->m_aiRefPOCList1[hevc->cur_pic->slice_idx][i]>hevc->curr_POC){
+                    hevc->LDCFlag = 0;
+                }
+            }
+        }
+    }
+
+    hevc->ColFromL0Flag   =rpm_param->p.collocated_from_l0_flag;
+
+    hevc->plevel          = rpm_param->p.log2_parallel_merge_level; //rpm_param->p.log2_parallel_merge_level>=2?rpm_param->p.log2_parallel_merge_level-2:0;
+    hevc->MaxNumMergeCand = 5 - rpm_param->p.five_minus_max_num_merge_cand;
+
+    hevc->LongTerm_Curr   =0; /* to do ... */
+    hevc->LongTerm_Col    =0; /* to do ... */
+
+    hevc->list_no = 0;
+    if(rpm_param->p.slice_type == B_SLICE ){
+        hevc->list_no = 1-hevc->ColFromL0Flag;
+    }
+    if(hevc->list_no==0){
+        if(Col_ref<hevc->RefNum_L0)
+            hevc->Col_POC = hevc->cur_pic->m_aiRefPOCList0[hevc->cur_pic->slice_idx][Col_ref];
+        else
+            hevc->Col_POC = INVALID_POC;
+    }
+    else{
+        if(Col_ref<hevc->RefNum_L1)
+            hevc->Col_POC = hevc->cur_pic->m_aiRefPOCList1[hevc->cur_pic->slice_idx][Col_ref];
+        else
+            hevc->Col_POC = INVALID_POC;
+    }
+
+    hevc->LongTerm_Ref    = 0; /* to do ... */
+
+    if(hevc->slice_type!=2)
+    {
+        //if(i_only_flag==1){
+        //     return 0xf;
+        //}
+        if (debug & H265_DEBUG_BUFMGR) {
+             printk("col_ref %d ColFromL0Flag %d Col_POC %d\n", Col_ref, hevc->ColFromL0Flag, hevc->Col_POC);
+         }
+        if (debug & H265_DEBUG_BUFMGR_MORE) {
+          int iii;
+          if (hevc->list_no == 0) {
+            printk("m_aiRefPOCList0 slice_idx %d:", hevc->cur_pic->slice_idx);
+            for (iii = 0; iii < hevc->RefNum_L0; iii++) {
+              printk("%d ", hevc->cur_pic->m_aiRefPOCList0[hevc->cur_pic->slice_idx][iii]);
+            }
+            printk("\r\n");
+          }
+          else{
+            printk("m_aiRefPOCList1 slice_idx %d:", hevc->cur_pic->slice_idx);
+            for (iii = 0; iii < hevc->RefNum_L1; iii++) {
+              printk("%d ", hevc->cur_pic->m_aiRefPOCList1[hevc->cur_pic->slice_idx][iii]);
+            }
+            printk("\r\n");
+          }
+        }
+
+        if(hevc->Col_POC != INVALID_POC){
+            hevc->col_pic = get_ref_pic_by_POC(hevc, hevc->Col_POC);
+            if(hevc->col_pic == NULL){
+                hevc->cur_pic->error_mark = 1;
+                if(debug) printk("WRONG, fail to get the picture of Col_POC\n");
+            }
+            else if(hevc->col_pic->error_mark){
+                hevc->cur_pic->error_mark = 1;
+                if(debug) printk("WRONG, Col_POC error_mark is 1\n");
+            }
+
+            if(hevc->cur_pic->error_mark && ((hevc->ignore_bufmgr_error&0x1)==0)){
+                if(debug) printk("Discard this picture\n");
+                return 2;    
+            }
+        }
+        else{
+            hevc->col_pic = hevc->cur_pic;
+        }
+    }//
+    if(hevc->col_pic == NULL) hevc->col_pic = hevc->cur_pic;     
+
+#ifdef BUFFER_MGR_ONLY
+     return 0xf;
+#else
+     if(decode_pic_begin>0 && hevc->decode_idx<=decode_pic_begin)
+          return 0xf;
+#endif
+
+    config_mc_buffer(hevc, hevc->cur_pic);
+
+    if(hevc->cur_pic->error_mark && ((hevc->ignore_bufmgr_error&0x1)==0)){
+        if(debug) printk("Discard this picture\n");
+        return 2;
+    }
+#ifdef MCRCC_ENABLE
+    config_mcrcc_axi_hw(hevc->cur_pic->slice_type);
+#endif
+    config_mpred_hw(hevc);
+
+    config_sao_hw(hevc, rpm_param);
+
+    if ((hevc->slice_type != 2) && (i_only_flag&0x2)) {
+        return 0xf;
+    }
+
+    return 0;
+}
+
+/**************************************************
+
+h265 buffer management end
+
+***************************************************/
+static buff_t mc_buf_spec;
+
+static hevc_stru_t gHevc;
+
+static param_t  rpm_param;
+
+static void hevc_local_uninit(void)
+{
+    if(gHevc.rpm_ptr){
+        iounmap(gHevc.rpm_ptr);
+        gHevc.rpm_ptr = NULL;
+    }
+    if (gHevc.rpm_page) {
+        free_pages(gHevc.rpm_page, get_order(RPM_BUF_SIZE));
+        gHevc.rpm_page = 0;
+    }
+    if(gHevc.lmem_ptr){
+        iounmap(gHevc.lmem_ptr);
+        gHevc.lmem_ptr = NULL;
+    }
+    if(gHevc.debug_ptr){
+        iounmap(gHevc.debug_ptr);
+        gHevc.debug_ptr = NULL;
+    }
+}
+
+static int hevc_local_init(void)
+{
+    int ret = -1;
+    BuffInfo_t* cur_buf_info = NULL;
+  	//int pic_width = buf_alloc_width?buf_alloc_width:frame_width;
+	  //int pic_height = buf_alloc_height?buf_alloc_height:frame_height;
+    memset(&rpm_param, 0, sizeof(rpm_param));
+    
+#ifdef SUPPORT_4K2K
+    cur_buf_info = &amvh265_workbuff_spec[1]; //4k2k work space
+#else
+    cur_buf_info = &amvh265_workbuff_spec[0]; //1080p work space
+#endif    
+ 
+    init_buff_spec(cur_buf_info);
+
+    mc_buf_spec.buf_start = (cur_buf_info->end_adr + 0xffff)&(~0xffff);
+    mc_buf_spec.buf_size  = (mc_buf_spec.buf_end - mc_buf_spec.buf_start);
+    
+    hevc_init_stru(&gHevc, cur_buf_info, &mc_buf_spec);
+    
+    bit_depth_luma = 8;
+    bit_depth_chroma = 8;
+    
+    if((debug&H265_DEBUG_SEND_PARAM_WITH_REG)==0){
+#if 1
+        gHevc.rpm_page = __get_free_pages(GFP_KERNEL, get_order(RPM_BUF_SIZE));
+        if (!gHevc.rpm_page) {
+            printk("%s: failed to alloc rpm buffer\n", __func__);
+            return -1;
+        }
+        gHevc.rpm_phy_adr = virt_to_phys((u8 *)gHevc.rpm_page);
+#else
+        gHevc.rpm_phy_adr = cur_buf_info->rpm.buf_start;
+#endif
+        if(gHevc.rpm_ptr){
+            iounmap(gHevc.rpm_ptr);
+            gHevc.rpm_ptr = NULL;
+        }
+        
+        gHevc.rpm_ptr = (unsigned short*)ioremap_nocache(gHevc.rpm_phy_adr, RPM_BUF_SIZE);
+        if (!gHevc.rpm_ptr) {
+                printk("%s: failed to remap rpm.buf_start\n", __func__);
+                return ret;
+        }
+    }    
+
+    if(debug&H265_DEBUG_UCODE){
+        if(gHevc.lmem_ptr){
+            iounmap(gHevc.lmem_ptr);
+            gHevc.lmem_ptr = NULL;
+        }
+        if(gHevc.debug_ptr){
+            iounmap(gHevc.debug_ptr);
+            gHevc.debug_ptr = NULL;
+        }
+        
+        gHevc.lmem_ptr = (unsigned short*)ioremap_nocache(cur_buf_info->lmem.buf_start, cur_buf_info->lmem.buf_size);
+        if (!gHevc.lmem_ptr) {
+                printk("%s: failed to remap lmem.buf_start\n", __func__);
+                return ret;
+        }
+        
+        gHevc.debug_ptr_size = 0x60; //cur_buf_info->pps.buf_size;
+        gHevc.debug_ptr = (unsigned short*)ioremap_nocache(cur_buf_info->pps.buf_start, cur_buf_info->pps.buf_size);
+        if (!gHevc.debug_ptr) {
+                printk("%s: failed to remap lmem.buf_start\n", __func__);
+                return ret;
+        }
+        
+    }  
+    ret = 0;  
+    return ret;
+}
+
+/********************************************
+ *  Mailbox command
+ ********************************************/
+#define CMD_FINISHED               0
+#define CMD_ALLOC_VIEW             1
+#define CMD_FRAME_DISPLAY          3
+#define CMD_DEBUG                  10
+
+static unsigned reserved_buffer;
+
+
+#define video_domain_addr(adr) (adr&0x7fffffff)
+#define DECODER_WORK_SPACE_SIZE 0x800000
+
+#define spec2canvas(x)  \
+    (((x)->uv_canvas_index << 16) | \
+     ((x)->uv_canvas_index << 8)  | \
+     ((x)->y_canvas_index << 0))
+
+#define VF_POOL_SIZE        64
+
+static DECLARE_KFIFO(newframe_q, vframe_t *, VF_POOL_SIZE);
+static DECLARE_KFIFO(display_q, vframe_t *, VF_POOL_SIZE);
+    /* for pic_struct of 9/10/11/12 */
+static DECLARE_KFIFO(pending_q, vframe_t *, VF_POOL_SIZE);
+
+static vframe_t vfpool[VF_POOL_SIZE];
+
+static void set_canvas(PIC_t* pic)
+{
+    pic->y_canvas_index = 128 + pic->index * 2;
+    pic->uv_canvas_index = 128 + pic->index * 2 + 1;
+    canvas_config(pic->y_canvas_index, pic->mc_y_adr, ALIGN(pic->width, 64), ALIGN(pic->height, 32),
+                  CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_64X32);
+    canvas_config(pic->uv_canvas_index, pic->mc_u_v_adr, ALIGN(pic->width, 64), ALIGN(pic->height>>1, 32),
+                  CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_64X32);
+}
+
+static int init_buf_spec(hevc_stru_t* hevc)
+{
+    int pic_width = hevc->pic_w;
+    int pic_height = hevc->pic_h;
+
+    //printk("%s1: %d %d\n", __func__, hevc->pic_w, hevc->pic_h);
+    printk("%s2 %d %d \n", __func__, pic_width, pic_height);
+    //pic_width = hevc->pic_w;
+    //pic_height = hevc->pic_h;
+
+    if(frame_width == 0 || frame_height == 0){
+        frame_width = pic_width;
+        frame_height = pic_height;   
+        
+    }
+
+    return 0;
+}
+
+static void set_frame_info(vframe_t *vf)
+{
+    unsigned int ar;
+
+    vf->width = frame_width;
+    vf->height = frame_height;
+    vf->duration = frame_dur;
+    vf->duration_pulldown = 0;
+    vf->flag = 0;
+
+    ar = min(frame_ar, (u32)DISP_RATIO_ASPECT_RATIO_MAX);
+    vf->ratio_control = (ar << DISP_RATIO_ASPECT_RATIO_BIT);
+
+    return;
+}
+
+static int vh265_vf_states(vframe_states_t *states, void* op_arg)
+{
+    unsigned long flags;
+    spin_lock_irqsave(&lock, flags);
+
+    states->vf_pool_size = VF_POOL_SIZE;
+    states->buf_free_num = kfifo_len(&newframe_q);
+    states->buf_avail_num = kfifo_len(&display_q);
+
+    if(step == 2){
+        states->buf_avail_num = 0;
+    }
+    spin_unlock_irqrestore(&lock, flags);
+    return 0;
+}
+
+static vframe_t *vh265_vf_peek(void* op_arg)
+{
+    vframe_t *vf;
+    if(step == 2){
+        return NULL;
+    }
+
+    if (kfifo_peek(&display_q, &vf)) {
+        return vf;
+    }
+
+    return NULL;
+}
+
+static vframe_t *vh265_vf_get(void* op_arg)
+{
+    vframe_t *vf;
+
+    if(step == 2){
+        return NULL;
+    }
+    else if(step == 1){
+        step = 2;
+    }
+
+    if (kfifo_get(&display_q, &vf)) {
+        return vf;
+    }
+
+    return NULL;
+}
+
+static void vh265_vf_put(vframe_t *vf, void* op_arg)
+{
+    unsigned char index1 = vf->index & 0xff;
+    unsigned char index2 = (vf->index >> 8) & 0xff;
+
+    kfifo_put(&newframe_q, (const vframe_t **)&vf);
+    if (index1 != 0xff) {
+      if (m_PIC[index1].vf_ref > 0) {
+        m_PIC[index1].vf_ref--;
+
+        if (m_PIC[index1].vf_ref == 0) {
+      clear_used_by_display_flag();
+          m_PIC[index1].output_ready = 0;
+          if (gHevc.wait_buf != 0) {
+              WRITE_VREG(HEVC_ASSIST_MBOX1_IRQ_REG, 0x1);
+          }
+    }
+      }
+    }
+
+    if (index2 != 0xff) {
+      if (m_PIC[index2].vf_ref > 0) {
+        m_PIC[index2].vf_ref--;
+
+        if (m_PIC[index2].vf_ref == 0) {
+          clear_used_by_display_flag();
+          m_PIC[index2].output_ready = 0;
+    if(gHevc.wait_buf!=0){
+        WRITE_VREG(HEVC_ASSIST_MBOX1_IRQ_REG, 0x1); 
+    }
+}
+      }
+    }
+}
+
+static int vh265_event_cb(int type, void *data, void *private_data)
+{
+    if(type & VFRAME_EVENT_RECEIVER_RESET){
+#if 0
+        unsigned long flags;
+        amhevc_stop();
+#ifndef CONFIG_POST_PROCESS_MANAGER
+        vf_light_unreg_provider(&vh265_vf_prov);
+#endif
+        spin_lock_irqsave(&lock, flags);
+        vh265_local_init();
+        vh265_prot_init();
+        spin_unlock_irqrestore(&lock, flags);
+#ifndef CONFIG_POST_PROCESS_MANAGER
+        vf_reg_provider(&vh265_vf_prov);
+#endif
+        amhevc_start();
+#endif        
+    }
+
+    return 0;
+}
+
+#ifdef HEVC_PIC_STRUCT_SUPPORT
+static int process_pending_vframe(hevc_stru_t *hevc, PIC_t* pair_pic, unsigned char pair_frame_top_flag)
+{
+    vframe_t *vf;
+    if (kfifo_len(&pending_q) > 1) { /* do not pending more than 1 frame */
+      if (kfifo_get(&pending_q, &vf) == 0) {
+        printk("fatal error, no available buffer slot.");
+        return -1;
+      }
+      kfifo_put(&display_q, (const vframe_t **)&vf);
+    }
+
+    if (kfifo_peek(&pending_q, &vf)) {
+      if (pair_pic == NULL || pair_pic->vf_ref <= 0) {
+        /* if pair_pic is recycled (pair_pic->vf_ref <= 0), do not use it */
+        if (kfifo_get(&pending_q, &vf) == 0) {
+          printk("fatal error, no available buffer slot.");
+          return -1;
+        }
+        if (vf)
+          kfifo_put(&display_q, (const vframe_t **)&vf);
+      }
+      else if ((!pair_frame_top_flag) && (((vf->index >> 8) & 0xff) == 0xff)) {
+        if (kfifo_get(&pending_q, &vf) == 0) {
+          printk("fatal error, no available buffer slot.");
+          return -1;
+        }
+        if (vf) {
+          vf->type = VIDTYPE_PROGRESSIVE | VIDTYPE_VIU_NV21;
+          vf->index |= (pair_pic->index << 8);
+          vf->canvas1Addr = spec2canvas(pair_pic);
+          pair_pic->vf_ref++;
+          kfifo_put(&display_q, (const vframe_t **)&vf);
+        }
+      }
+      else if (pair_frame_top_flag && ((vf->index & 0xff) == 0xff)) {
+        if (kfifo_get(&pending_q, &vf) == 0) {
+          printk("fatal error, no available buffer slot.");
+          return -1;
+        }
+        if (vf) {
+          vf->type = VIDTYPE_PROGRESSIVE | VIDTYPE_VIU_NV21;
+          vf->index |= pair_pic->index;
+          vf->canvas0Addr = spec2canvas(pair_pic);
+          pair_pic->vf_ref++;
+          kfifo_put(&display_q, (const vframe_t **)&vf);
+        }
+      }
+    }
+    return 0;
+}
+#endif
+
+static int prepare_display_buf(hevc_stru_t* hevc, PIC_t* pic)
+{
+    vframe_t *vf = NULL;
+    int stream_offset = pic->stream_offset;
+    unsigned short slice_type = pic->slice_type;
+
+    if (kfifo_get(&newframe_q, &vf) == 0) {
+        printk("fatal error, no available buffer slot.");
+        return -1;
+    }
+    
+    if (vf) {
+        //if (pts_lookup_offset(PTS_TYPE_VIDEO, stream_offset, &vf->pts, 0) != 0) {
+        if (pts_lookup_offset_us64(PTS_TYPE_VIDEO, stream_offset, &vf->pts, 0, &vf->pts_us64)!= 0){
+#ifdef DEBUG_PTS
+            pts_missed++;
+#endif
+            vf->pts = 0;
+            vf->pts_us64 = 0;
+        }
+#ifdef DEBUG_PTS
+        else {
+            pts_hit++;
+        }
+#endif
+
+        if ((hevc->pts_mode == PTS_NORMAL) && (vf->pts != 0) && get_frame_dur) {
+            int pts_diff = (int)vf->pts - hevc->last_lookup_pts;
+
+            if (pts_diff < 0) {
+               hevc->pts_mode_switching_count++;
+               hevc->pts_mode_recovery_count = 0;
+
+               if (hevc->pts_mode_switching_count >= PTS_MODE_SWITCHING_THRESHOLD) {
+                   hevc->pts_mode = PTS_NONE_REF_USE_DURATION;
+                   printk("HEVC: pts lookup switch to none_ref_use_duration mode.\n");
+               }
+
+            } else {
+               hevc->pts_mode_recovery_count++;
+               if (hevc->pts_mode_recovery_count > PTS_MODE_SWITCHING_RECOVERY_THREASHOLD) {
+                   hevc->pts_mode_switching_count = 0;
+                   hevc->pts_mode_recovery_count = 0;
+               }
+            }
+        }
+
+        if (vf->pts != 0) {
+            hevc->last_lookup_pts = vf->pts;
+        }
+
+        if (((hevc->pts_mode == PTS_NONE_REF_USE_DURATION) && (slice_type != 2)) ||
+            (i_only_flag)) {
+            if (frame_dur == 0) {
+                // add a default duration for 1/30 second if there is no valid frame duration available
+                frame_dur = 96000/30;
+            }
+
+            vf->pts = hevc->last_pts + DUR2PTS(frame_dur);
+        }
+        hevc->last_pts = vf->pts;
+
+        if (vf->pts_us64 != 0) {
+            hevc->last_lookup_pts_us64 = vf->pts_us64;
+        }
+
+        if ((hevc->pts_mode == PTS_NONE_REF_USE_DURATION) && (slice_type != 2)) {
+            vf->pts_us64 = hevc->last_pts_us64 + (DUR2PTS(frame_dur)*100/9);
+        }
+        hevc->last_pts_us64 = vf->pts_us64;
+        if((debug&H265_DEBUG_OUT_PTS)!=0){
+            printk("H265 decoder out pts: vf->pts=%d, vf->pts_us64 = %lld\n", vf->pts, vf->pts_us64);
+        }
+
+        vf->index = 0xff00 | pic->index;
+        vf->type = VIDTYPE_PROGRESSIVE | VIDTYPE_VIU_FIELD;
+        vf->type |= VIDTYPE_VIU_NV21;
+        vf->canvas0Addr = vf->canvas1Addr = spec2canvas(pic);
+        set_frame_info(vf);
+        //if((vf->width!=pic->width)||(vf->height!=pic->height))
+        //    printk("aaa: %d/%d, %d/%d\n", vf->width,vf->height, pic->width, pic->height);
+        vf->width = pic->width;
+        vf->height = pic->height;
+
+#ifdef HEVC_PIC_STRUCT_SUPPORT
+        if (pic->pic_struct == 3 || pic->pic_struct == 4) {
+          vframe_t *vf2;
+          if (kfifo_get(&newframe_q, &vf2) == 0) {
+            printk("fatal error, no available buffer slot.");
+            return -1;
+          }
+          pic->vf_ref = 2;
+          vf->duration = vf->duration>>1;
+          memcpy(vf2, vf, sizeof(vframe_t));
+
+          if (pic->pic_struct == 3) {
+            vf->type = VIDTYPE_INTERLACE_TOP | VIDTYPE_VIU_NV21;
+            vf2->type = VIDTYPE_INTERLACE_BOTTOM | VIDTYPE_VIU_NV21;
+          }
+          else{
+            vf->type = VIDTYPE_INTERLACE_BOTTOM | VIDTYPE_VIU_NV21;
+            vf2->type = VIDTYPE_INTERLACE_TOP | VIDTYPE_VIU_NV21;
+          }
+            kfifo_put(&display_q, (const vframe_t **)&vf);
+            kfifo_put(&display_q, (const vframe_t **)&vf2);
+          }
+        else if (pic->pic_struct == 5 || pic->pic_struct == 6) {
+          vframe_t *vf2, *vf3;
+          if (kfifo_get(&newframe_q, &vf2) == 0) {
+            printk("fatal error, no available buffer slot.");
+            return -1;
+          }
+          if (kfifo_get(&newframe_q, &vf3) == 0) {
+            printk("fatal error, no available buffer slot.");
+            return -1;
+          }
+          pic->vf_ref = 3;
+          vf->duration = vf->duration/3;
+          memcpy(vf2, vf, sizeof(vframe_t));
+          memcpy(vf3, vf, sizeof(vframe_t));
+
+          if (pic->pic_struct == 5) {
+            vf->type = VIDTYPE_INTERLACE_TOP | VIDTYPE_VIU_NV21;
+            vf2->type = VIDTYPE_INTERLACE_BOTTOM | VIDTYPE_VIU_NV21;
+            vf3->type = VIDTYPE_INTERLACE_TOP | VIDTYPE_VIU_NV21;
+          }
+          else{
+            vf->type = VIDTYPE_INTERLACE_BOTTOM | VIDTYPE_VIU_NV21;
+            vf2->type = VIDTYPE_INTERLACE_TOP | VIDTYPE_VIU_NV21;
+            vf3->type = VIDTYPE_INTERLACE_BOTTOM | VIDTYPE_VIU_NV21;
+          }
+          kfifo_put(&display_q, (const vframe_t **)&vf);
+            kfifo_put(&display_q, (const vframe_t **)&vf2);
+          kfifo_put(&display_q, (const vframe_t **)&vf3);
+          }
+        else if (pic->pic_struct == 9 || pic->pic_struct == 10) {
+          /* process previous pending vf*/
+          process_pending_vframe(hevc, pic, (pic->pic_struct == 9));
+
+          /* process current vf */
+          kfifo_put(&pending_q, (const vframe_t **)&vf);
+          vf->height <<= 1;
+          if (pic->pic_struct == 9) {
+            vf->type = VIDTYPE_INTERLACE_TOP | VIDTYPE_VIU_NV21 | VIDTYPE_VIU_FIELD;
+            process_pending_vframe(hevc, pre_bot_pic, 0);
+        }
+        else{
+            vf->type = VIDTYPE_INTERLACE_BOTTOM | VIDTYPE_VIU_NV21 | VIDTYPE_VIU_FIELD;
+            vf->index = (pic->index << 8) | 0xff;
+            process_pending_vframe(hevc, pre_top_pic, 1);
+          }
+
+          /**/
+          if (pic->pic_struct == 9)
+            pre_top_pic = pic;
+          else
+            pre_bot_pic = pic;
+        }
+        else if (pic->pic_struct == 11 || pic->pic_struct == 12) {
+          /* process previous pending vf*/
+          process_pending_vframe(hevc, pic, (pic->pic_struct == 11));
+
+          /* put current into pending q */
+          vf->height <<= 1;
+          if (pic->pic_struct == 11)
+            vf->type = VIDTYPE_INTERLACE_TOP | VIDTYPE_VIU_NV21 | VIDTYPE_VIU_FIELD;
+          else {
+            vf->type = VIDTYPE_INTERLACE_BOTTOM | VIDTYPE_VIU_NV21 | VIDTYPE_VIU_FIELD;
+            vf->index = (pic->index << 8) | 0xff;
+          }
+          kfifo_put(&pending_q, (const vframe_t **)&vf);
+
+          /**/
+          if (pic->pic_struct == 11)
+            pre_top_pic = pic;
+          else
+            pre_bot_pic = pic;
+        }
+        else{
+          pic->vf_ref = 1;
+          switch (pic->pic_struct) {
+            case 7:
+              vf->duration <<= 1;
+              break;
+            case 8:
+              vf->duration = vf->duration * 3;
+              break;
+            case 1:
+              vf->height <<= 1;
+              vf->type = VIDTYPE_INTERLACE_TOP | VIDTYPE_VIU_NV21 | VIDTYPE_VIU_FIELD;
+              process_pending_vframe(hevc, pic, 1);
+              pre_top_pic = pic;
+              break;
+            case 2:
+              vf->height <<= 1;
+            vf->type = VIDTYPE_INTERLACE_BOTTOM | VIDTYPE_VIU_NV21 | VIDTYPE_VIU_FIELD;
+              process_pending_vframe(hevc, pic, 0);
+              pre_bot_pic = pic;
+              break;
+          }
+          kfifo_put(&display_q, (const vframe_t **)&vf);
+        }
+#else
+        pic->vf_ref = 1;
+        kfifo_put(&display_q, (const vframe_t **)&vf);
+#endif
+
+        vf_notify_receiver(PROVIDER_NAME,VFRAME_EVENT_PROVIDER_VFRAME_READY, NULL);
+    }
+
+    return 0;
+}
+
+static int vh265_stop(void);
+static s32 vh265_init(void);
+
+static void hevc_recover(hevc_stru_t* hevc)
+{
+
+        u32 rem;
+        u64 shift_byte_count64;
+        unsigned hevc_shift_byte_count ;
+        unsigned hevc_stream_start_addr;
+        unsigned hevc_stream_end_addr ;
+        unsigned hevc_stream_rd_ptr ;
+        unsigned hevc_stream_wr_ptr ;
+        unsigned hevc_stream_control;
+        unsigned hevc_stream_fifo_ctl;
+        unsigned hevc_stream_buf_size;
+#if 0
+            for(i=0; i<(hevc->debug_ptr_size/2); i+=4){
+                int ii;
+                for(ii=0; ii<4; ii++){
+                    printk("%04x ", hevc->debug_ptr[i+3-ii]);
+                }
+                if(((i+ii)&0xf)==0)
+                    printk("\n");
+            }
+#endif
+#define ES_VID_MAN_RD_PTR            (1<<0)
+
+        amhevc_stop();
+
+        //reset
+        WRITE_MPEG_REG(PARSER_VIDEO_RP, READ_VREG(HEVC_STREAM_RD_PTR));
+        SET_MPEG_REG_MASK(PARSER_ES_CONTROL, ES_VID_MAN_RD_PTR);
+
+        hevc_stream_start_addr = READ_VREG(HEVC_STREAM_START_ADDR);
+        hevc_stream_end_addr = READ_VREG(HEVC_STREAM_END_ADDR);
+        hevc_stream_rd_ptr = READ_VREG(HEVC_STREAM_RD_PTR);
+        hevc_stream_wr_ptr = READ_VREG(HEVC_STREAM_WR_PTR);
+        hevc_stream_control = READ_VREG(HEVC_STREAM_CONTROL);
+        hevc_stream_fifo_ctl = READ_VREG(HEVC_STREAM_FIFO_CTL);
+        hevc_stream_buf_size = hevc_stream_end_addr - hevc_stream_start_addr;
+
+        // HEVC streaming buffer will reset and restart from current hevc_stream_rd_ptr position
+        // calculate HEVC_SHIFT_BYTE_COUNT value with the new position.
+        hevc_shift_byte_count = READ_VREG(HEVC_SHIFT_BYTE_COUNT);
+        if ((hevc->shift_byte_count_lo & (1<<31)) && ((hevc_shift_byte_count & (1<<31)) == 0)) {
+            hevc->shift_byte_count_hi++;
+        }
+        hevc->shift_byte_count_lo = hevc_shift_byte_count;
+
+        shift_byte_count64 = ((u64)(hevc->shift_byte_count_hi) << 32) | hevc->shift_byte_count_lo;
+        div_u64_rem(shift_byte_count64, hevc_stream_buf_size, &rem);
+        shift_byte_count64 -= rem;
+        shift_byte_count64 += hevc_stream_rd_ptr - hevc_stream_start_addr;
+        if (rem > (hevc_stream_rd_ptr - hevc_stream_start_addr)) {
+            shift_byte_count64 += hevc_stream_buf_size;
+        }
+        hevc->shift_byte_count_lo = (u32)shift_byte_count64;
+        hevc->shift_byte_count_hi = (u32)(shift_byte_count64 >> 32);
+
+        WRITE_VREG(DOS_SW_RESET3, 
+            //(1<<2)|
+            (1<<3)|(1<<4)|(1<<8)|(1<<11)|(1<<12)|(1<<14)|(1<<15)|(1<<17)|(1<<18)|(1<<19));
+        WRITE_VREG(DOS_SW_RESET3, 0);
+
+        WRITE_VREG(HEVC_STREAM_START_ADDR, hevc_stream_start_addr);
+        WRITE_VREG(HEVC_STREAM_END_ADDR, hevc_stream_end_addr);
+        WRITE_VREG(HEVC_STREAM_RD_PTR, hevc_stream_rd_ptr);
+        WRITE_VREG(HEVC_STREAM_WR_PTR, hevc_stream_wr_ptr);
+        WRITE_VREG(HEVC_STREAM_CONTROL, hevc_stream_control);
+        WRITE_VREG(HEVC_SHIFT_BYTE_COUNT, hevc->shift_byte_count_lo);
+        WRITE_VREG(HEVC_STREAM_FIFO_CTL, hevc_stream_fifo_ctl);
+
+        hevc_config_work_space_hw(&gHevc);
+        decoder_hw_reset();
+
+        gHevc.have_vps = 0;
+        gHevc.have_sps = 0;
+        gHevc.have_pps = 0;
+
+        gHevc.have_valid_start_slice = 0;
+        WRITE_VREG(HEVC_WAIT_FLAG, 1);
+        /* clear mailbox interrupt */
+        WRITE_VREG(HEVC_ASSIST_MBOX1_CLR_REG, 1);
+        /* enable mailbox interrupt */
+        WRITE_VREG(HEVC_ASSIST_MBOX1_MASK, 1);
+        /* disable PSCALE for hardware sharing */
+        WRITE_VREG(HEVC_PSCALE_CTRL, 0);
+
+        CLEAR_MPEG_REG_MASK(PARSER_ES_CONTROL, ES_VID_MAN_RD_PTR);
+
+    if(debug&H265_DEBUG_UCODE){
+        WRITE_VREG(DEBUG_REG1, 0x1);
+    }
+    else{
+        WRITE_VREG(DEBUG_REG1, 0x0);
+    }
+    
+    if((error_handle_policy&1)==0){
+        if((error_handle_policy&4)==0)
+            WRITE_VREG(NAL_SEARCH_CTL, 0xc); //ucode auto mode, and do not check vps/sps/pps/idr
+        else
+            WRITE_VREG(NAL_SEARCH_CTL, 0x1); //manual parser NAL
+    }
+    else{
+        WRITE_VREG(NAL_SEARCH_CTL, 0x1); //manual parser NAL
+    }
+    
+    if(debug & H265_DEBUG_NO_EOS_SEARCH_DONE){
+        WRITE_VREG(NAL_SEARCH_CTL, READ_VREG(NAL_SEARCH_CTL)|0x10000);
+    }    
+    if (interlace_enable & 0x1)
+        WRITE_VREG(NAL_SEARCH_CTL, READ_VREG(NAL_SEARCH_CTL)|0x20000);
+    WRITE_VREG(DECODE_STOP_POS, decode_stop_pos);
+
+        //if (amhevc_loadmc(vh265_mc) < 0) {
+        //    amhevc_disable();
+        //    return -EBUSY;
+        //}
+#if 0        
+            for(i=0; i<(hevc->debug_ptr_size/2); i+=4){
+                int ii;
+                for(ii=0; ii<4; ii++){
+                    //hevc->debug_ptr[i+3-ii]=ttt++;
+                    printk("%04x ", hevc->debug_ptr[i+3-ii]);
+                }
+                if(((i+ii)&0xf)==0)
+                    printk("\n");
+            }
+#endif            
+        init_pic_list_hw();
+        
+        printk("%s HEVC_SHIFT_BYTE_COUNT=%x\n", __func__, READ_VREG(HEVC_SHIFT_BYTE_COUNT));
+
+        amhevc_start();
+
+        //skip, search next start code
+        WRITE_VREG(HEVC_WAIT_FLAG, READ_VREG(HEVC_WAIT_FLAG)&(~0x2));            
+        hevc->skip_flag = 1;
+#ifdef ERROR_HANDLE_DEBUG
+        if(dbg_nal_skip_count&0x20000){
+            dbg_nal_skip_count &= ~0x20000;
+            return;
+        }
+#endif
+        WRITE_VREG(HEVC_DEC_STATUS_REG, HEVC_ACTION_DONE);
+        // Interrupt Amrisc to excute 
+        WRITE_VREG(HEVC_MCPU_INTR_REQ, AMRISC_MAIN_REQ);
+}
+
+static irqreturn_t vh265_isr(int irq, void *dev_id)
+{
+    int ret;
+    int i;
+    unsigned int dec_status;
+    hevc_stru_t* hevc = &gHevc;
+    dec_status = READ_VREG(HEVC_DEC_STATUS_REG);
+
+    if(init_flag == 0){
+   	    return IRQ_HANDLED;
+    }
+    
+    if(debug&H265_DEBUG_BUFMGR){
+        printk("265 isr dec status = %d\n", dec_status);
+    }
+
+   if(debug&H265_DEBUG_UCODE){
+       if(READ_HREG(DEBUG_REG1)&0x10000){
+#if 0
+            printk("PPS \r\n");
+            for(i=0; i<(hevc->debug_ptr_size/2); i+=4){
+                int ii;
+                for(ii=0; ii<4; ii++){
+                    printk("%04x ", hevc->debug_ptr[i+3-ii]);
+                }
+                if(((i+ii)&0xf)==0)
+                    printk("\n");
+            }
+
+#endif
+            printk("LMEM<tag %x>:\n", READ_HREG(DEBUG_REG1));
+            for(i=0; i<0x400; i+=4){
+                int ii;
+                if((i&0xf)==0)
+                    printk("%03x: ",i);
+                for(ii=0; ii<4; ii++){
+                    printk("%04x ", hevc->lmem_ptr[i+3-ii]);
+                }
+                if(((i+ii)&0xf)==0)
+                    printk("\n");
+            }
+            WRITE_HREG(DEBUG_REG1, 0);
+       }
+       else if(READ_HREG(DEBUG_REG1)!=0){
+            printk("dbg%x: %x\n",  READ_HREG(DEBUG_REG1), READ_HREG(DEBUG_REG2));
+            WRITE_HREG(DEBUG_REG1, 0);
+            	return IRQ_HANDLED;
+       }
+       
+   }
+
+    if(hevc->pic_list_init_flag == 1){
+        return IRQ_HANDLED;
+    }
+    
+    if(hevc->error_flag==1){
+        if ((error_handle_policy & 0x10) == 0) {
+          if (hevc->cur_pic) {
+            int current_lcu_idx = READ_VREG(HEVC_PARSER_LCU_START)&0xffffff;
+            if (current_lcu_idx < ((hevc->lcu_x_num*hevc->lcu_y_num) - 1)) {
+                hevc->cur_pic->error_mark = 1;
+            }
+          }
+        }
+        if((error_handle_policy&1)==0){
+            hevc->error_skip_nal_count = 1;
+            WRITE_VREG(NAL_SEARCH_CTL, (error_skip_nal_count<<4)|0x1); //manual search nal, skip  error_skip_nal_count of nal and trigger the HEVC_NAL_SEARCH_DONE irq
+        }
+        else{
+            hevc->error_skip_nal_count = error_skip_nal_count;
+            WRITE_VREG(NAL_SEARCH_CTL, 0x1); //manual parser NAL
+        }
+        if(debug & H265_DEBUG_NO_EOS_SEARCH_DONE){
+            WRITE_VREG(NAL_SEARCH_CTL, READ_VREG(NAL_SEARCH_CTL)|0x10000);
+        }
+        if (interlace_enable & 0x1)
+          WRITE_VREG(NAL_SEARCH_CTL, READ_VREG(NAL_SEARCH_CTL)|0x20000);
+
+        WRITE_VREG(HEVC_DEC_STATUS_REG, HEVC_ACTION_DONE); //search new nal
+        // Interrupt Amrisc to excute
+        WRITE_VREG(HEVC_MCPU_INTR_REQ, AMRISC_MAIN_REQ);
+
+        //printk("%s: error handle\n", __func__);
+        hevc->error_flag = 2;
+        return IRQ_HANDLED;
+    }
+    else if(hevc->error_flag==3){
+        printk("error_flag=3, hevc_recover");
+        hevc_recover(hevc);
+        hevc->error_flag = 0;
+
+        if ((error_handle_policy & 0x10) == 0) {
+          if (hevc->cur_pic) {
+            int current_lcu_idx = READ_VREG(HEVC_PARSER_LCU_START)&0xffffff;
+            if (current_lcu_idx < ((hevc->lcu_x_num*hevc->lcu_y_num) - 1)) {
+                hevc->cur_pic->error_mark = 1;
+            }
+          }
+        }
+
+        if ((error_handle_policy&1) == 0) {
+            //need skip some data when error_flag of 3 is triggered,
+            // to avoid hevc_recover() being called for many times at the same bitstream position
+            hevc->error_skip_nal_count = 1;
+            WRITE_VREG(NAL_SEARCH_CTL, (error_skip_nal_count<<4)|0x1); //manual search nal, skip  error_skip_nal_count of nal and trigger the HEVC_NAL_SEARCH_DONE irq
+        }
+
+        if((error_handle_policy&0x2)==0){
+            hevc->have_vps = 1;
+            hevc->have_sps = 1;
+            hevc->have_pps = 1;
+        }
+        return IRQ_HANDLED;
+    }
+
+    i = READ_VREG(HEVC_SHIFT_BYTE_COUNT);
+    if ((hevc->shift_byte_count_lo & (1<<31)) && ((i & (1<<31)) == 0)) {
+        hevc->shift_byte_count_hi++;
+    }
+    hevc->shift_byte_count_lo = i;
+
+    if(dec_status == HEVC_NAL_SEARCH_DONE){
+        int naltype = READ_HREG(CUR_NAL_UNIT_TYPE);
+        int parse_type = HEVC_DISCARD_NAL;
+        error_watchdog_count = 0;
+        error_skip_nal_watchdog_count = 0;
+        if(slice_parse_begin>0 && debug&H265_DEBUG_DISCARD_NAL){
+            printk("nal type %d, discard %d\n", naltype, slice_parse_begin);
+            if(naltype<= NAL_UNIT_CODED_SLICE_CRA){
+                slice_parse_begin--;
+            }
+        }
+        if(naltype == NAL_UNIT_EOS){
+            PIC_t* pic;
+            printk("get NAL_UNIT_EOS, flush output"); 
+            pic = get_pic_by_POC(hevc, hevc->curr_POC);
+            hevc->curr_POC = INVALID_POC;
+            hevc->m_pocRandomAccess = MAX_INT; //add to fix RAP_B_Bossen_1
+            flush_output(hevc, pic);
+            return IRQ_HANDLED;
+        }
+        
+        if(hevc->error_skip_nal_count > 0){
+            printk("nal type %d, discard %d\n", naltype, hevc->error_skip_nal_count);
+            hevc->error_skip_nal_count--;
+            if(hevc->error_skip_nal_count==0){
+                hevc_recover(hevc);
+                hevc->error_flag = 0;
+                if((error_handle_policy&0x2)==0){
+                    hevc->have_vps = 1;
+                    hevc->have_sps = 1;
+                    hevc->have_pps = 1;
+                }
+                return IRQ_HANDLED;
+            }
+        }
+        else if(naltype == NAL_UNIT_VPS){
+            parse_type = HEVC_NAL_UNIT_VPS;
+            hevc->have_vps = 1;
+#ifdef ERROR_HANDLE_DEBUG
+            if(dbg_nal_skip_flag&1){
+                parse_type = HEVC_DISCARD_NAL;
+            }
+#endif
+        }
+        else if(hevc->have_vps){
+            if(naltype == NAL_UNIT_SPS){
+                parse_type = HEVC_NAL_UNIT_SPS;
+                hevc->have_sps = 1;
+#ifdef ERROR_HANDLE_DEBUG
+                if(dbg_nal_skip_flag&2){
+                    parse_type = HEVC_DISCARD_NAL;
+                }
+#endif
+            }
+            else if(naltype == NAL_UNIT_PPS){
+                parse_type = HEVC_NAL_UNIT_PPS;
+                hevc->have_pps = 1;
+#ifdef ERROR_HANDLE_DEBUG
+                if(dbg_nal_skip_flag&4){
+                    parse_type = HEVC_DISCARD_NAL;
+                }
+#endif
+            }
+            else if(hevc->have_sps && hevc->have_pps){
+                if(
+                    (naltype == NAL_UNIT_CODED_SLICE_IDR) ||
+                    (naltype == NAL_UNIT_CODED_SLICE_IDR_N_LP)||
+                    ( naltype == NAL_UNIT_CODED_SLICE_CRA) ||
+                    ( naltype == NAL_UNIT_CODED_SLICE_BLA) ||
+                    ( naltype == NAL_UNIT_CODED_SLICE_BLANT) ||
+                    (naltype == NAL_UNIT_CODED_SLICE_BLA_N_LP )
+                 ){
+                    if(slice_parse_begin>0){
+                        printk("discard %d, for debugging\n", slice_parse_begin);
+                        slice_parse_begin--;
+                    }
+                    else{
+                        parse_type = HEVC_NAL_UNIT_CODED_SLICE_SEGMENT;
+                    }
+                    hevc->have_valid_start_slice = 1;
+                }
+                else if(naltype<= NAL_UNIT_CODED_SLICE_CRA){
+                    if(hevc->have_valid_start_slice || (hevc->PB_skip_mode!=3)){
+                        if(slice_parse_begin>0){
+                            printk("discard %d, for debugging\n", slice_parse_begin);
+                            slice_parse_begin--;
+                        }
+                        else{
+                            parse_type = HEVC_NAL_UNIT_CODED_SLICE_SEGMENT;
+                        }
+                    }
+                }
+            }
+        }
+        if(hevc->have_vps && hevc->have_sps && hevc->have_pps && hevc->have_valid_start_slice
+            && hevc->error_flag==0 ){
+            if((debug&H265_DEBUG_MAN_SEARCH_NAL)==0)
+                WRITE_VREG(NAL_SEARCH_CTL, 0x2); //auot parser NAL; do not check vps/sps/pps/idr
+
+            if(debug & H265_DEBUG_NO_EOS_SEARCH_DONE){
+                WRITE_VREG(NAL_SEARCH_CTL, READ_VREG(NAL_SEARCH_CTL)|0x10000);
+            }    
+            if (interlace_enable & 0x1)
+              WRITE_VREG(NAL_SEARCH_CTL, READ_VREG(NAL_SEARCH_CTL)|0x20000);
+
+        }
+        
+        if(debug&H265_DEBUG_BUFMGR){
+            printk("naltype = %d  parse_type %d\n %d %d %d %d \n", naltype, parse_type,
+                hevc->have_vps ,hevc->have_sps, hevc->have_pps ,hevc->have_valid_start_slice);
+        }
+
+        WRITE_VREG(HEVC_DEC_STATUS_REG, parse_type);
+        // Interrupt Amrisc to excute 
+        WRITE_VREG(HEVC_MCPU_INTR_REQ, AMRISC_MAIN_REQ);
+            
+    
+    }
+    else if(dec_status == HEVC_SLICE_SEGMENT_DONE){
+        error_watchdog_count = 0;
+        if(hevc->pic_list_init_flag == 2){
+            hevc->pic_list_init_flag = 3;
+            printk("set pic_list_init_flag to 3\n");
+        }
+        else if(hevc->wait_buf == 0){
+            u32 vui_time_scale;
+            u32 vui_num_units_in_tick;
+
+            if(debug&H265_DEBUG_SEND_PARAM_WITH_REG){
+                get_rpm_param(&rpm_param);
+            }
+            else{
+                for(i=0; i<(RPM_END-RPM_BEGIN); i+=4){
+                    int ii;
+                    for(ii=0; ii<4; ii++){
+                        rpm_param.l.data[i+ii]=hevc->rpm_ptr[i+3-ii];
+                    }
+                }
+            }
+            if(debug&H265_DEBUG_BUFMGR){
+                printk("rpm_param: (%d)\n", hevc->slice_idx);
+                hevc->slice_idx++;
+                for(i=0; i<(RPM_END-RPM_BEGIN); i++){
+                    printk("%04x ", rpm_param.l.data[i]);
+                    if(((i+1)&0xf)==0)
+                        printk("\n");
+                } 
+                
+                printk("vui_timing_info: %x, %x, %x, %x\n",         rpm_param.p.vui_num_units_in_tick_hi,
+                            rpm_param.p.vui_num_units_in_tick_lo,
+                            rpm_param.p.vui_time_scale_hi,
+                            rpm_param.p.vui_time_scale_lo);
+            }
+
+            vui_time_scale = (u32)(rpm_param.p.vui_time_scale_hi << 16) | rpm_param.p.vui_time_scale_lo;
+            vui_num_units_in_tick = (u32)(rpm_param.p.vui_num_units_in_tick_hi << 16) | rpm_param.p.vui_num_units_in_tick_lo;
+            if(bit_depth_luma!=((rpm_param.p.bit_depth&0xf)+8)){
+                printk("Bit depth luma = %d\n", (rpm_param.p.bit_depth&0xf)+8);    
+            }
+            if(bit_depth_chroma!=(((rpm_param.p.bit_depth>>4)&0xf)+8)){
+                printk("Bit depth chroma = %d\n",  ((rpm_param.p.bit_depth>>4)&0xf) + 8);    
+            }
+            bit_depth_luma = (rpm_param.p.bit_depth&0xf) + 8;
+            bit_depth_chroma = ((rpm_param.p.bit_depth>>4)&0xf) + 8;
+            if ((vui_time_scale != 0) && (vui_num_units_in_tick != 0)) {
+                frame_dur = div_u64(96000ULL * vui_num_units_in_tick, vui_time_scale);
+                get_frame_dur = true;
+            }
+
+            if(use_cma&&(rpm_param.p.slice_segment_address == 0)&&(hevc->pic_list_init_flag == 0)){
+                hevc->pic_w = rpm_param.p.pic_width_in_luma_samples;
+                hevc->pic_h = rpm_param.p.pic_height_in_luma_samples;
+                hevc->lcu_size        = 1<<(rpm_param.p.log2_min_coding_block_size_minus3+3+rpm_param.p.log2_diff_max_min_coding_block_size);
+                hevc->lcu_size_log2   =log2i(hevc->lcu_size);
+	              if(hevc->pic_w==0 || hevc->pic_h==0 || hevc->lcu_size ==0){
+                    //skip, search next start code
+                    WRITE_VREG(HEVC_WAIT_FLAG, READ_VREG(HEVC_WAIT_FLAG)&(~0x2));            
+                    hevc->skip_flag = 1;
+                    WRITE_VREG(HEVC_DEC_STATUS_REG, HEVC_ACTION_DONE);
+                    // Interrupt Amrisc to excute 
+                    WRITE_VREG(HEVC_MCPU_INTR_REQ, AMRISC_MAIN_REQ);
+	                
+	              }
+                else{                
+                    hevc->sps_num_reorder_pics_0 =
+                      rpm_param.p.sps_num_reorder_pics_0;
+                    hevc->pic_list_init_flag = 1;
+                    up(&h265_sema);
+                    printk("set pic_list_init_flag to 1\n");
+                }
+                return IRQ_HANDLED;
+            }
+
+        }    
+        ret = hevc_slice_segment_header_process(hevc, &rpm_param, decode_pic_begin);
+        if(ret<0){
+
+        }
+        else if(ret == 0){
+            if ((hevc->new_pic) && (hevc->cur_pic)) {
+                hevc->cur_pic->stream_offset = READ_VREG(HEVC_SHIFT_BYTE_COUNT);
+            }
+
+            WRITE_VREG(HEVC_DEC_STATUS_REG, HEVC_CODED_SLICE_SEGMENT_DAT);
+            // Interrupt Amrisc to excute 
+            WRITE_VREG(HEVC_MCPU_INTR_REQ, AMRISC_MAIN_REQ);
+        }
+        else{
+            //skip, search next start code
+            WRITE_VREG(HEVC_WAIT_FLAG, READ_VREG(HEVC_WAIT_FLAG)&(~0x2));            
+            hevc->skip_flag = 1;
+            WRITE_VREG(HEVC_DEC_STATUS_REG, HEVC_ACTION_DONE);
+            // Interrupt Amrisc to excute 
+            WRITE_VREG(HEVC_MCPU_INTR_REQ, AMRISC_MAIN_REQ);
+        }
+        
+    }
+
+    return IRQ_HANDLED;
+}
+
+static void vh265_put_timer_func(unsigned long arg)
+{
+    struct timer_list *timer = (struct timer_list *)arg;
+    unsigned char empty_flag;
     unsigned int buf_level;	
-
-    receviver_start_e state = RECEIVER_INACTIVE;
-    
-    if(init_flag == 0){
-        return;
-    }
-    
-    if (vf_get_receiver(PROVIDER_NAME)) {
-        state = vf_notify_receiver(PROVIDER_NAME, VFRAME_EVENT_PROVIDER_QUREY_STATE, NULL);
-        if ((state == RECEIVER_STATE_NULL)||(state == RECEIVER_STATE_NONE)){
-            state = RECEIVER_INACTIVE;
-        }
-    } else {
-        state = RECEIVER_INACTIVE;
-    }
-
-    empty_flag = (READ_VREG(HEVC_PARSER_INT_STATUS)>>6)&0x1;
-    // error watchdog
-    if (empty_flag == 0){
-        // decoder has input
-        if((debug&H265_DEBUG_DIS_LOC_ERROR_PROC)==0){
+
+    receviver_start_e state = RECEIVER_INACTIVE;
+    
+    if(init_flag == 0){
+        return;
+    }
+    
+    if (vf_get_receiver(PROVIDER_NAME)) {
+        state = vf_notify_receiver(PROVIDER_NAME, VFRAME_EVENT_PROVIDER_QUREY_STATE, NULL);
+        if ((state == RECEIVER_STATE_NULL)||(state == RECEIVER_STATE_NONE)){
+            state = RECEIVER_INACTIVE;
+        }
+    } else {
+        state = RECEIVER_INACTIVE;
+    }
+
+    empty_flag = (READ_VREG(HEVC_PARSER_INT_STATUS)>>6)&0x1;
+    // error watchdog
+    if ((empty_flag == 0)&&(gHevc.pic_list_init_flag == 0 || gHevc.pic_list_init_flag == 3)){
+        // decoder has input
+        if((debug&H265_DEBUG_DIS_LOC_ERROR_PROC)==0){
 
 	buf_level = READ_VREG(HEVC_STREAM_LEVEL);
-            if((state == RECEIVER_INACTIVE) &&                       // receiver has no buffer to recycle
+            if((state == RECEIVER_INACTIVE) &&                       // receiver has no buffer to recycle
                 (kfifo_is_empty(&display_q)&& buf_level>0x200)                        // no buffer in display queue  .not to do error recover when buf_level is low
-                ){
-                if(gHevc.error_flag==0){
-                    error_watchdog_count++;
-                    if (error_watchdog_count == error_handle_threshold) {    
-                        printk("H265 decoder error local reset.\n");
-                        gHevc.error_flag = 1;
-                        error_watchdog_count = 0;
-                        error_skip_nal_watchdog_count = 0;
-                        error_system_watchdog_count++;
-                        WRITE_VREG(HEVC_ASSIST_MBOX1_IRQ_REG, 0x1); 
-                    }
-                }
-                else if(gHevc.error_flag == 2){
-                    error_skip_nal_watchdog_count++;
-                    if(error_skip_nal_watchdog_count==error_handle_nal_skip_threshold){
-                        gHevc.error_flag = 3;
-                        error_watchdog_count = 0;
-                        error_skip_nal_watchdog_count = 0;
-                        WRITE_VREG(HEVC_ASSIST_MBOX1_IRQ_REG, 0x1); 
-                    }
-                }
-            }
-        }
-
-        if((debug&H265_DEBUG_DIS_SYS_ERROR_PROC)==0){
-            if((state == RECEIVER_INACTIVE) &&                       // receiver has no buffer to recycle
-                (kfifo_is_empty(&display_q))                        // no buffer in display queue
-               ){                        // no buffer to recycle
-                if((debug&H265_DEBUG_DIS_LOC_ERROR_PROC)!=0){
-                    error_system_watchdog_count++;
-                }
-                if (error_system_watchdog_count == error_handle_system_threshold) {    // and it lasts for a while
-                    printk("H265 decoder fatal error watchdog.\n");
-                    error_system_watchdog_count = 0;
-                    fatal_error = DECODER_FATAL_ERROR_UNKNOW;
-                }
-            }
-        }
-    }
-    else{
-        error_watchdog_count = 0;
-        error_system_watchdog_count = 0;
-    }
-
-    timer->expires = jiffies + PUT_INTERVAL;
-
-    if(decode_stop_pos != decode_stop_pos_pre){
-        WRITE_VREG(DECODE_STOP_POS, decode_stop_pos);
-        decode_stop_pos_pre = decode_stop_pos;
-    }
-    
-    if(debug&H265_DEBUG_DUMP_PIC_LIST){
-        dump_pic_list(&gHevc);
-        debug &= ~H265_DEBUG_DUMP_PIC_LIST;
-    }
-    if(debug&H265_DEBUG_TRIG_SLICE_SEGMENT_PROC){
-        WRITE_VREG(HEVC_ASSIST_MBOX1_IRQ_REG, 0x1); 
-        debug &= ~H265_DEBUG_TRIG_SLICE_SEGMENT_PROC;
-    }
-    if(debug&H265_DEBUG_HW_RESET){
-        gHevc.error_skip_nal_count = error_skip_nal_count;
-        WRITE_VREG(HEVC_DEC_STATUS_REG, HEVC_ACTION_DONE);
-
-        debug &= ~H265_DEBUG_HW_RESET;
-    }
-    if(debug&H265_DEBUG_ERROR_TRIG){
-        WRITE_VREG(DECODE_STOP_POS, 1);
-        debug &= ~H265_DEBUG_ERROR_TRIG;
-    }
-
-#ifdef ERROR_HANDLE_DEBUG
-    if((dbg_nal_skip_count > 0)&&((dbg_nal_skip_count&0x10000)!=0)){
-        gHevc.error_skip_nal_count = dbg_nal_skip_count&0xffff;
-        dbg_nal_skip_count &= ~0x10000;
-        WRITE_VREG(HEVC_DEC_STATUS_REG, HEVC_ACTION_DONE);
-    }
-#endif
-    
-    add_timer(timer);
-}
-
-static int h265_task_handle(void *data)
-{
-		int ret = 0;
-    while (1)
-    {
-        if(use_cma==0){
-            printk("ERROR: use_cma can not be changed dynamically\n");    
-        }
-        ret = down_interruptible(&h265_sema);
-        if((init_flag!=0) && (gHevc.pic_list_init_flag == 1)){
-            init_pic_list(&gHevc);
-            init_buf_spec(&gHevc);
-            gHevc.pic_list_init_flag = 2;
-            printk("set pic_list_init_flag to 2\n");
-            
-            WRITE_VREG(HEVC_ASSIST_MBOX1_IRQ_REG, 0x1); 
-        }
-        
-        if(uninit_list){    
-            uninit_pic_list(&gHevc);
-            printk("uninit list\n");
-            uninit_list = 0;
-        }
-
-    }
-
-    return 0;
-
-}
-
-int vh265_dec_status(struct vdec_status *vstatus)
-{
-    vstatus->width = frame_width;
-    vstatus->height = frame_height;
-    if (frame_dur != 0) {
-        vstatus->fps = 96000 / frame_dur;
-    } else {
-        vstatus->fps = -1;
-    }
-    vstatus->error_count = 0;
-    vstatus->status = stat | fatal_error;
-    return 0;
-}
-
-#if 0
-static void H265_DECODE_INIT(void)
-{
-    //enable hevc clocks
-    WRITE_VREG(DOS_GCLK_EN3, 0xffffffff);
-    //****************************************************************************
-    //                 Power ON HEVC
-    //****************************************************************************
-    // Powerup HEVC
-    WRITE_VREG(P_AO_RTI_GEN_PWR_SLEEP0, READ_VREG(P_AO_RTI_GEN_PWR_SLEEP0) & (~(0x3<<6))); // [7:6] HEVC
-    WRITE_VREG( DOS_MEM_PD_HEVC, 0x0);
-    WRITE_VREG(DOS_SW_RESET3, READ_VREG(DOS_SW_RESET3)|(0x3ffff<<2));
-    WRITE_VREG(DOS_SW_RESET3, READ_VREG(DOS_SW_RESET3)&(~(0x3ffff<<2)));
-    // remove isolations
-    WRITE_VREG(AO_RTI_GEN_PWR_ISO0, READ_VREG(AO_RTI_GEN_PWR_ISO0) & (~(0x3<<10))); // [11:10] HEVC
-
-}
-#endif
-
-static void vh265_prot_init(void)
-{
-//    H265_DECODE_INIT();
-    
-    hevc_config_work_space_hw(&gHevc);
-    
-    hevc_init_decoder_hw(0, 0xffffffff);
-
-    WRITE_VREG(HEVC_WAIT_FLAG, 1);
-
-    //WRITE_VREG(P_HEVC_MPSR, 1);
-
-    /* clear mailbox interrupt */
-    WRITE_VREG(HEVC_ASSIST_MBOX1_CLR_REG, 1);
-
-    /* enable mailbox interrupt */
-    WRITE_VREG(HEVC_ASSIST_MBOX1_MASK, 1);
-
-    /* disable PSCALE for hardware sharing */
-    WRITE_VREG(HEVC_PSCALE_CTRL, 0);
-    
-    if(debug&H265_DEBUG_UCODE){
-        WRITE_VREG(DEBUG_REG1, 0x1);
-    }
-    else{
-        WRITE_VREG(DEBUG_REG1, 0x0);
-    }
-    
-    if(debug&(H265_DEBUG_MAN_SKIP_NAL|H265_DEBUG_MAN_SEARCH_NAL)){
-        WRITE_VREG(NAL_SEARCH_CTL, 0x1); //manual parser NAL
-    }
-    else{
-        unsigned ctl_val = 0x8; //check vps/sps/pps/i-slice in ucode
-        if(gHevc.PB_skip_mode==0){
-            ctl_val = 0x4;  // check vps/sps/pps only in ucode
-        }
-        else if(gHevc.PB_skip_mode==3){
-            ctl_val = 0x0;  // check vps/sps/pps/idr in ucode
-        }
-        WRITE_VREG(NAL_SEARCH_CTL, ctl_val);
-    }
-        
-    WRITE_VREG(DECODE_STOP_POS, decode_stop_pos);
-
-}
-
-static int vh265_local_init(void)
-{
-    int i;
-    int ret;
-
-#ifdef DEBUG_PTS
-    pts_missed = 0;
-    pts_hit = 0;
-#endif
-    get_frame_dur = false;
-    frame_width = vh265_amstream_dec_info.width;
-    frame_height = vh265_amstream_dec_info.height;
-    frame_dur = (vh265_amstream_dec_info.rate == 0) ? 3600 : vh265_amstream_dec_info.rate;
-    if (frame_width && frame_height) {
-        frame_ar = frame_height * 0x100 / frame_width;
-    }
-    error_watchdog_count = 0;
-
-    printk("h265: decinfo: %dx%d rate=%d\n", frame_width, frame_height, frame_dur);
-
-    if(frame_dur == 0){
-        frame_dur = 96000/24;
-    }
-
-    INIT_KFIFO(display_q);
-    INIT_KFIFO(newframe_q);
-
-    for (i=0; i<DECODE_BUFFER_NUM_MAX; i++) {
-        vfbuf_use[i] = 0;
-    }
-
-    for (i=0; i<VF_POOL_SIZE; i++) {
-        const vframe_t *vf = &vfpool[i];
-        vfpool[i].index = -1;
-        kfifo_put(&newframe_q, &vf);
-    }
-
-    reserved_buffer = 0;
-
-    ret = hevc_local_init();
-    
-    return ret;
-}
-
-extern unsigned char ucode_buf[4*1024*8];
-static s32 vh265_init(void)
-{
-    init_timer(&recycle_timer);
-
-    stat |= STAT_TIMER_INIT;
-
-    if(vh265_local_init()<0)
-       return -EBUSY; 
-
-    amhevc_enable();
-#if 0
-    if(debug &H265_DEBUG_LOAD_UCODE_FROM_FILE){
-        printk("load ucode from file\r\n");
-        if (amhevc_loadmc(ucode_buf) < 0) {
-            amhevc_disable();
-            return -EBUSY;
-        }
-    }
-    else 
-#endif
-    if(debug&H265_DEBUG_SEND_PARAM_WITH_REG){
-        if (amhevc_loadmc(vh265_mc_send_param_with_reg_mc) < 0) {
-            amhevc_disable();
-            return -EBUSY;
-        }
-    }
-    else{
-        if (amhevc_loadmc(vh265_mc) < 0) {
-            amhevc_disable();
-            return -EBUSY;
-        }
-    }
-    stat |= STAT_MC_LOAD;
-
-    /* enable AMRISC side protocol */
-    vh265_prot_init();
-
-    if (request_irq(INT_VDEC, vh265_isr,
-                    IRQF_SHARED, "vh265-irq", (void *)vh265_dec_id)) {
-        printk("vh265 irq register error.\n");
-        amhevc_disable();
-        return -ENOENT;
-    }
-
-    stat |= STAT_ISR_REG;
-
-    vf_provider_init(&vh265_vf_prov, PROVIDER_NAME, &vh265_vf_provider, NULL);
-    vf_reg_provider(&vh265_vf_prov);
-    vf_notify_receiver(PROVIDER_NAME,VFRAME_EVENT_PROVIDER_START,NULL);
-
-    vf_notify_receiver(PROVIDER_NAME, VFRAME_EVENT_PROVIDER_FR_HINT, (void *)frame_dur);
-
-    stat |= STAT_VF_HOOK;
-
-    recycle_timer.data = (ulong) & recycle_timer;
-    recycle_timer.function = vh265_put_timer_func;
-    recycle_timer.expires = jiffies + PUT_INTERVAL;
-
-    add_timer(&recycle_timer);
-
-    stat |= STAT_TIMER_ARM;
-
-    if(use_cma){
-        if(h265_task==NULL){
-            sema_init(&h265_sema,1);
-            h265_task = kthread_run(h265_task_handle, NULL, "kthread_h265");
-        }
-    }
-    //stat |= STAT_KTHREAD;
-
-    if(debug&H265_DEBUG_FORCE_CLK){
-        printk("%s force clk\n", __func__);
-        WRITE_VREG(HEVC_IQIT_CLK_RST_CTRL, READ_VREG(HEVC_IQIT_CLK_RST_CTRL)|((1<<2)|(1<<1)));
-        WRITE_VREG(HEVC_DBLK_CFG0, READ_VREG(HEVC_DBLK_CFG0)|((1<<2)|(1<<1)|0x3fff0000)); //2,29:16
-        WRITE_VREG(HEVC_SAO_CTRL1 , READ_VREG(HEVC_SAO_CTRL1 )|(1<<2)); //2
-        WRITE_VREG( HEVC_MPRED_CTRL1, READ_VREG( HEVC_MPRED_CTRL1)|(1<<24)); //24
-        WRITE_VREG(HEVC_STREAM_CONTROL, READ_VREG(HEVC_STREAM_CONTROL)|(1<<15)); //15
-        WRITE_VREG(HEVC_CABAC_CONTROL, READ_VREG(HEVC_CABAC_CONTROL)|(1<<13)); //13
-        WRITE_VREG(HEVC_PARSER_CORE_CONTROL, READ_VREG(HEVC_PARSER_CORE_CONTROL)|(1<<15)); //15
-        WRITE_VREG(HEVC_PARSER_INT_CONTROL, READ_VREG(HEVC_PARSER_INT_CONTROL)|(1<<15)); //15
-        WRITE_VREG(HEVC_PARSER_IF_CONTROL, READ_VREG(HEVC_PARSER_IF_CONTROL)|((1<<6)|(1<<3)|(1<<1))); //6, 3, 1
-        WRITE_VREG(HEVCD_IPP_DYNCLKGATE_CONFIG, READ_VREG(HEVCD_IPP_DYNCLKGATE_CONFIG)|0xffffffff); //31:0
-        WRITE_VREG(HEVCD_MCRCC_CTL1, READ_VREG(HEVCD_MCRCC_CTL1)|(1<<3)); //3
-    }
-
-    amhevc_start();
-
-    stat |= STAT_VDEC_RUN;
-
-    set_vdec_func(&vh265_dec_status);
-
-    init_flag = 1;
-
-    //printk("%d, vh265_init, RP=0x%x\n", __LINE__, READ_VREG(HEVC_STREAM_RD_PTR));
-
-    return 0;
-}
-
-static int vh265_stop(void)
-{
-    init_flag = 0;
-    
-    if (stat & STAT_VDEC_RUN) {
-        amhevc_stop();
-        stat &= ~STAT_VDEC_RUN;
-    }
-
-    if (stat & STAT_ISR_REG) {
-        WRITE_VREG(HEVC_ASSIST_MBOX1_MASK, 0);
-        free_irq(INT_VDEC, (void *)vh265_dec_id);
-        stat &= ~STAT_ISR_REG;
-    }
-
-    if (stat & STAT_TIMER_ARM) {
-        del_timer_sync(&recycle_timer);
-        stat &= ~STAT_TIMER_ARM;
-    }
-
-    if (stat & STAT_VF_HOOK) {
-        vf_notify_receiver(PROVIDER_NAME, VFRAME_EVENT_PROVIDER_FR_END_HINT, NULL);
-
-        vf_unreg_provider(&vh265_vf_prov);
-        stat &= ~STAT_VF_HOOK;
-    }
-
-    //hevc_local_uninit();
-    
-    if(use_cma){
-        uninit_list = 1;
-        up(&h265_sema);
-        while(uninit_list){ //wait uninit complete
-            msleep(10);
-        }
-    }
-#if 0    
-    if(h265_task)
-        kthread_stop(h265_task);
-    h265_task = NULL;
-#endif
-    amhevc_disable();
-
-    return 0;
-}
-
-static int amvdec_h265_probe(struct platform_device *pdev)
-{
-    struct vdec_dev_reg_s *pdata = (struct vdec_dev_reg_s *)pdev->dev.platform_data;
-    int i;
-
-    mutex_lock(&vh265_mutex);
-    
-    fatal_error = 0;
-
-    if (pdata == NULL) {
-        printk("\namvdec_h265 memory resource undefined.\n");
-        mutex_unlock(&vh265_mutex);
-        return -EFAULT;
-    }
-
-    mc_buf_spec.buf_end = pdata->mem_end + 1;
-    for(i=0;i<WORK_BUF_SPEC_NUM;i++){
-        amvh265_workbuff_spec[i].start_adr = pdata->mem_start;
-    }
-
-    if(debug) printk("===H.265 decoder mem resource 0x%lx -- 0x%lx\n", pdata->mem_start, pdata->mem_end + 1);
-
-    if (pdata->sys_info) {
-        vh265_amstream_dec_info = *pdata->sys_info;
-    } else {
-        vh265_amstream_dec_info.width = 0;
-        vh265_amstream_dec_info.height = 0;
-        vh265_amstream_dec_info.rate = 30;
-    }
-
-    cma_dev = pdata->cma_dev;
-
-    if (vh265_init() < 0) {
-        printk("\namvdec_h265 init failed.\n");
-        hevc_local_uninit();
-        mutex_unlock(&vh265_mutex);
-        return -ENODEV;
-    }
-
-    mutex_unlock(&vh265_mutex);
-    return 0;
-}
-
-static int amvdec_h265_remove(struct platform_device *pdev)
-{
-    if(debug) printk("amvdec_h265_remove\n");
-
-    mutex_lock(&vh265_mutex);
-
-    vh265_stop();
-
-#ifdef DEBUG_PTS
-    printk("pts missed %ld, pts hit %ld, duration %d\n",
-           pts_missed, pts_hit, frame_dur);
-#endif
-
-    mutex_unlock(&vh265_mutex);
-    
-    return 0;
-}
-
-/****************************************/
-
-static struct platform_driver amvdec_h265_driver = {
-    .probe   = amvdec_h265_probe,
-    .remove  = amvdec_h265_remove,
-#ifdef CONFIG_PM
-    .suspend = amvdec_suspend,
-    .resume  = amvdec_resume,
-#endif
-    .driver  = {
-        .name = DRIVER_NAME,
-    }
-};
-
-static struct codec_profile_t amvdec_h265_profile = {
-    .name = "hevc",
-    .profile = ""
-};
-
-static int __init amvdec_h265_driver_init_module(void)
-{
-    printk("amvdec_h265 module init\n");
-
-    if (platform_driver_register(&amvdec_h265_driver)) {
-        printk("failed to register amvdec_h265 driver\n");
-        return -ENODEV;
-    }
-
-    #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
-    if (IS_MESON_M8_CPU) {
-        amvdec_h265_profile.name = "hevc_unsupport"; //not support hevc
-    }else if(IS_MESON_M8M2_CPU){
-        amvdec_h265_profile.profile = "4k"; //m8m2 support 4k
-    }
-    #endif
-
-    vcodec_profile_register(&amvdec_h265_profile);
-
-    return 0;
-}
-
-static void __exit amvdec_h265_driver_remove_module(void)
-{
-    printk("amvdec_h265 module remove.\n");
-
-    platform_driver_unregister(&amvdec_h265_driver);
-}
-
-/****************************************/
-
-module_param(stat, uint, 0664);
-MODULE_PARM_DESC(stat, "\n amvdec_h265 stat \n");
-
-module_param(use_cma, uint, 0664);
-MODULE_PARM_DESC(use_cma, "\n amvdec_h265 use_cma \n");
-
-module_param(bit_depth_luma, uint, 0664);
-MODULE_PARM_DESC(bit_depth_luma, "\n amvdec_h265 bit_depth_luma \n");
-
-module_param(bit_depth_chroma, uint, 0664);
-MODULE_PARM_DESC(bit_depth_chroma, "\n amvdec_h265 bit_depth_chroma \n");
-
-module_param(debug, uint, 0664);
-MODULE_PARM_DESC(debug, "\n amvdec_h265 debug \n");
-
-#ifdef ERROR_HANDLE_DEBUG
-module_param(dbg_nal_skip_flag, uint, 0664);
-MODULE_PARM_DESC(dbg_nal_skip_flag, "\n amvdec_h265 dbg_nal_skip_flag \n");
-
-module_param(dbg_nal_skip_count, uint, 0664);
-MODULE_PARM_DESC(dbg_nal_skip_count, "\n amvdec_h265 dbg_nal_skip_count \n");
-#endif
-
-module_param(step, uint, 0664);
-MODULE_PARM_DESC(step, "\n amvdec_h265 step \n");
-
-module_param(decode_stop_pos, uint, 0664);
-MODULE_PARM_DESC(decode_stop_pos, "\n amvdec_h265 decode_stop_pos \n");
-
-module_param(decode_pic_begin, uint, 0664);
-MODULE_PARM_DESC(decode_pic_begin, "\n amvdec_h265 decode_pic_begin \n");
-
-module_param(slice_parse_begin, uint, 0664);
-MODULE_PARM_DESC(slice_parse_begin, "\n amvdec_h265 slice_parse_begin \n");
-
-module_param(nal_skip_policy, uint, 0664);
-MODULE_PARM_DESC(nal_skip_policy, "\n amvdec_h265 nal_skip_policy \n");
-
-module_param(error_handle_policy, uint, 0664);
-MODULE_PARM_DESC(error_handle_policy, "\n amvdec_h265 error_handle_policy \n");
-
-module_param(error_handle_threshold, uint, 0664);
-MODULE_PARM_DESC(error_handle_threshold, "\n amvdec_h265 error_handle_threshold \n");
-
-module_param(error_handle_nal_skip_threshold, uint, 0664);
-MODULE_PARM_DESC(error_handle_nal_skip_threshold, "\n amvdec_h265 error_handle_nal_skip_threshold \n");
-
-module_param(error_handle_system_threshold, uint, 0664);
-MODULE_PARM_DESC(error_handle_system_threshold, "\n amvdec_h265 error_handle_system_threshold \n");
-
-module_param(error_skip_nal_count, uint, 0664);
-MODULE_PARM_DESC(error_skip_nal_count, "\n amvdec_h265 error_skip_nal_count \n");
-
-module_init(amvdec_h265_driver_init_module);
-module_exit(amvdec_h265_driver_remove_module);
-
-MODULE_DESCRIPTION("AMLOGIC h265 Video Decoder Driver");
-MODULE_LICENSE("GPL");
-MODULE_AUTHOR("Tim Yao <tim.yao@amlogic.com>");
-
-
+                ){
+                if(gHevc.error_flag==0){
+                    error_watchdog_count++;
+                    if (debug & H265_DEBUG_BUFMGR)
+                      printk("watchdog_count %d buf_level %x cur_lcu %x decode_stat %x pccount %x\n",
+                      error_watchdog_count, buf_level, READ_VREG(HEVC_PARSER_LCU_START)&0xffffff,
+                      READ_VREG(HEVC_DEC_STATUS_REG), READ_VREG(0x3308));
+                    if (error_watchdog_count == error_handle_threshold) {    
+                        printk("H265 decoder error local reset.\n");
+                        gHevc.error_flag = 1;
+                        error_watchdog_count = 0;
+                        error_skip_nal_watchdog_count = 0;
+                        error_system_watchdog_count++;
+                        WRITE_VREG(HEVC_ASSIST_MBOX1_IRQ_REG, 0x1); 
+                    }
+                }
+                else if(gHevc.error_flag == 2){
+                    error_skip_nal_watchdog_count++;
+                    if(error_skip_nal_watchdog_count==error_handle_nal_skip_threshold){
+                        gHevc.error_flag = 3;
+                        error_watchdog_count = 0;
+                        error_skip_nal_watchdog_count = 0;
+                        WRITE_VREG(HEVC_ASSIST_MBOX1_IRQ_REG, 0x1); 
+                    }
+                }
+            }
+        }
+
+        if((debug&H265_DEBUG_DIS_SYS_ERROR_PROC)==0){
+            if((state == RECEIVER_INACTIVE) &&                       // receiver has no buffer to recycle
+                (kfifo_is_empty(&display_q))                        // no buffer in display queue
+               ){                        // no buffer to recycle
+                if((debug&H265_DEBUG_DIS_LOC_ERROR_PROC)!=0){
+                    error_system_watchdog_count++;
+                }
+                if (error_system_watchdog_count == error_handle_system_threshold) {    // and it lasts for a while
+                    printk("H265 decoder fatal error watchdog.\n");
+                    error_system_watchdog_count = 0;
+                    fatal_error = DECODER_FATAL_ERROR_UNKNOW;
+                }
+            }
+        }
+    }
+    else{
+        error_watchdog_count = 0;
+        error_system_watchdog_count = 0;
+    }
+
+    timer->expires = jiffies + PUT_INTERVAL;
+
+    if(decode_stop_pos != decode_stop_pos_pre){
+        WRITE_VREG(DECODE_STOP_POS, decode_stop_pos);
+        decode_stop_pos_pre = decode_stop_pos;
+    }
+    
+    if(debug&H265_DEBUG_DUMP_PIC_LIST){
+        dump_pic_list(&gHevc);
+        debug &= ~H265_DEBUG_DUMP_PIC_LIST;
+    }
+    if(debug&H265_DEBUG_TRIG_SLICE_SEGMENT_PROC){
+        WRITE_VREG(HEVC_ASSIST_MBOX1_IRQ_REG, 0x1); 
+        debug &= ~H265_DEBUG_TRIG_SLICE_SEGMENT_PROC;
+    }
+    if(debug&H265_DEBUG_HW_RESET){
+        gHevc.error_skip_nal_count = error_skip_nal_count;
+        WRITE_VREG(HEVC_DEC_STATUS_REG, HEVC_ACTION_DONE);
+
+        debug &= ~H265_DEBUG_HW_RESET;
+    }
+    if(debug&H265_DEBUG_ERROR_TRIG){
+        WRITE_VREG(DECODE_STOP_POS, 1);
+        debug &= ~H265_DEBUG_ERROR_TRIG;
+    }
+
+#ifdef ERROR_HANDLE_DEBUG
+    if((dbg_nal_skip_count > 0)&&((dbg_nal_skip_count&0x10000)!=0)){
+        gHevc.error_skip_nal_count = dbg_nal_skip_count&0xffff;
+        dbg_nal_skip_count &= ~0x10000;
+        WRITE_VREG(HEVC_DEC_STATUS_REG, HEVC_ACTION_DONE);
+    }
+#endif
+    
+    add_timer(timer);
+}
+
+static int h265_task_handle(void *data)
+{
+		int ret = 0;
+    while (1)
+    {
+        if(use_cma==0){
+            printk("ERROR: use_cma can not be changed dynamically\n");    
+        }
+        ret = down_interruptible(&h265_sema);
+        if((init_flag!=0) && (gHevc.pic_list_init_flag == 1)){
+            init_buf_list(&gHevc);
+            init_pic_list(&gHevc);
+            init_pic_list_hw();
+            init_buf_spec(&gHevc);
+            gHevc.pic_list_init_flag = 2;
+            printk("set pic_list_init_flag to 2\n");
+            
+            WRITE_VREG(HEVC_ASSIST_MBOX1_IRQ_REG, 0x1); 
+        }
+        
+        if(uninit_list){    
+            uninit_buf_list(&gHevc);
+            printk("uninit list\n");
+            uninit_list = 0;
+        }
+
+    }
+
+    return 0;
+
+}
+
+int vh265_dec_status(struct vdec_status *vstatus)
+{
+    vstatus->width = frame_width;
+    vstatus->height = frame_height;
+    if (frame_dur != 0) {
+        vstatus->fps = 96000 / frame_dur;
+    } else {
+        vstatus->fps = -1;
+    }
+    vstatus->error_count = 0;
+    vstatus->status = stat | fatal_error;
+    return 0;
+}
+
+#if 0
+static void H265_DECODE_INIT(void)
+{
+    //enable hevc clocks
+    WRITE_VREG(DOS_GCLK_EN3, 0xffffffff);
+    //****************************************************************************
+    //                 Power ON HEVC
+    //****************************************************************************
+    // Powerup HEVC
+    WRITE_VREG(P_AO_RTI_GEN_PWR_SLEEP0, READ_VREG(P_AO_RTI_GEN_PWR_SLEEP0) & (~(0x3<<6))); // [7:6] HEVC
+    WRITE_VREG( DOS_MEM_PD_HEVC, 0x0);
+    WRITE_VREG(DOS_SW_RESET3, READ_VREG(DOS_SW_RESET3)|(0x3ffff<<2));
+    WRITE_VREG(DOS_SW_RESET3, READ_VREG(DOS_SW_RESET3)&(~(0x3ffff<<2)));
+    // remove isolations
+    WRITE_VREG(AO_RTI_GEN_PWR_ISO0, READ_VREG(AO_RTI_GEN_PWR_ISO0) & (~(0x3<<10))); // [11:10] HEVC
+
+}
+#endif
+
+static void vh265_prot_init(void)
+{
+//    H265_DECODE_INIT();
+    
+    hevc_config_work_space_hw(&gHevc);
+    
+    hevc_init_decoder_hw(0, 0xffffffff);
+
+    WRITE_VREG(HEVC_WAIT_FLAG, 1);
+
+    //WRITE_VREG(P_HEVC_MPSR, 1);
+
+    /* clear mailbox interrupt */
+    WRITE_VREG(HEVC_ASSIST_MBOX1_CLR_REG, 1);
+
+    /* enable mailbox interrupt */
+    WRITE_VREG(HEVC_ASSIST_MBOX1_MASK, 1);
+
+    /* disable PSCALE for hardware sharing */
+    WRITE_VREG(HEVC_PSCALE_CTRL, 0);
+    
+    if(debug&H265_DEBUG_UCODE){
+        WRITE_VREG(DEBUG_REG1, 0x1);
+    }
+    else{
+        WRITE_VREG(DEBUG_REG1, 0x0);
+    }
+    
+    if(debug&(H265_DEBUG_MAN_SKIP_NAL|H265_DEBUG_MAN_SEARCH_NAL)){
+        WRITE_VREG(NAL_SEARCH_CTL, 0x1); //manual parser NAL
+    }
+    else{
+        unsigned ctl_val = 0x8; //check vps/sps/pps/i-slice in ucode
+        if(gHevc.PB_skip_mode==0){
+            ctl_val = 0x4;  // check vps/sps/pps only in ucode
+        }
+        else if(gHevc.PB_skip_mode==3){
+            ctl_val = 0x0;  // check vps/sps/pps/idr in ucode
+        }
+        WRITE_VREG(NAL_SEARCH_CTL, ctl_val);
+    }
+    if(debug & H265_DEBUG_NO_EOS_SEARCH_DONE){
+        WRITE_VREG(NAL_SEARCH_CTL, READ_VREG(NAL_SEARCH_CTL)|0x10000);
+    }    
+    if (interlace_enable & 0x1)
+        WRITE_VREG(NAL_SEARCH_CTL, READ_VREG(NAL_SEARCH_CTL)|0x20000);
+        
+    WRITE_VREG(DECODE_STOP_POS, decode_stop_pos);
+
+}
+
+static int vh265_local_init(void)
+{
+    int i;
+    int ret;
+
+#ifdef DEBUG_PTS
+    pts_missed = 0;
+    pts_hit = 0;
+#endif
+    get_frame_dur = false;
+    frame_width = vh265_amstream_dec_info.width;
+    frame_height = vh265_amstream_dec_info.height;
+    frame_dur = (vh265_amstream_dec_info.rate == 0) ? 3600 : vh265_amstream_dec_info.rate;
+    if (frame_width && frame_height) {
+        frame_ar = frame_height * 0x100 / frame_width;
+    }
+    error_watchdog_count = 0;
+
+    printk("h265: ver (%d,%d) decinfo: %dx%d rate=%d\n",  h265_version, h265_ucode_v, frame_width, frame_height, frame_dur);
+
+    if(frame_dur == 0){
+        frame_dur = 96000/24;
+    }
+
+    INIT_KFIFO(display_q);
+    INIT_KFIFO(newframe_q);
+    INIT_KFIFO(pending_q);
+
+    for (i=0; i<VF_POOL_SIZE; i++) {
+        const vframe_t *vf = &vfpool[i];
+        vfpool[i].index = -1;
+        kfifo_put(&newframe_q, &vf);
+    }
+
+    reserved_buffer = 0;
+
+    ret = hevc_local_init();
+    
+    return ret;
+}
+
+static s32 vh265_init(void)
+{
+    init_timer(&recycle_timer);
+
+    stat |= STAT_TIMER_INIT;
+
+    if(vh265_local_init()<0)
+       return -EBUSY; 
+
+    amhevc_enable();
+    if(debug &H265_DEBUG_LOAD_UCODE_FROM_FILE){
+		    int size;
+        char *mbuf;
+        printk("load ucode from file of vh265_mc\n");
+        mbuf=kmalloc(4096 * 8, GFP_KERNEL);
+        if (!mbuf) {
+            printk("vh265_init: Cannot malloc mbuf  memory1\n");
+            return -EBUSY;
+        }
+        memset(mbuf,0,4096 * 8);
+        size=request_video_firmware("vh265_mc",mbuf,4096 * 8);
+        if(size<=0){
+            printk("vh265_init: not valied ucode for vh265");
+            kfree(mbuf);
+            return -EBUSY;
+        }
+        if (amhevc_loadmc((const u32 *)mbuf) < 0) {
+            amhevc_disable();
+            kfree(mbuf);
+            return -EBUSY;
+        }
+        kfree(mbuf);
+    }
+    else if (amhevc_loadmc(vh265_mc) < 0) {
+        amhevc_disable();
+        return -EBUSY;
+    }
+    stat |= STAT_MC_LOAD;
+
+    /* enable AMRISC side protocol */
+    vh265_prot_init();
+
+    if (request_irq(INT_VDEC, vh265_isr,
+                    IRQF_SHARED, "vh265-irq", (void *)vh265_dec_id)) {
+        printk("vh265 irq register error.\n");
+        amhevc_disable();
+        return -ENOENT;
+    }
+
+    stat |= STAT_ISR_REG;
+
+    vf_provider_init(&vh265_vf_prov, PROVIDER_NAME, &vh265_vf_provider, NULL);
+    vf_reg_provider(&vh265_vf_prov);
+    vf_notify_receiver(PROVIDER_NAME,VFRAME_EVENT_PROVIDER_START,NULL);
+
+    vf_notify_receiver(PROVIDER_NAME, VFRAME_EVENT_PROVIDER_FR_HINT, (void *)frame_dur);
+
+    stat |= STAT_VF_HOOK;
+
+    recycle_timer.data = (ulong) & recycle_timer;
+    recycle_timer.function = vh265_put_timer_func;
+    recycle_timer.expires = jiffies + PUT_INTERVAL;
+
+    add_timer(&recycle_timer);
+
+    stat |= STAT_TIMER_ARM;
+
+    if(use_cma){
+        if(h265_task==NULL){
+            sema_init(&h265_sema,1);
+            h265_task = kthread_run(h265_task_handle, NULL, "kthread_h265");
+        }
+    }
+    //stat |= STAT_KTHREAD;
+
+    if(debug&H265_DEBUG_FORCE_CLK){
+        printk("%s force clk\n", __func__);
+        WRITE_VREG(HEVC_IQIT_CLK_RST_CTRL, READ_VREG(HEVC_IQIT_CLK_RST_CTRL)|((1<<2)|(1<<1)));
+        WRITE_VREG(HEVC_DBLK_CFG0, READ_VREG(HEVC_DBLK_CFG0)|((1<<2)|(1<<1)|0x3fff0000)); //2,29:16
+        WRITE_VREG(HEVC_SAO_CTRL1 , READ_VREG(HEVC_SAO_CTRL1 )|(1<<2)); //2
+        WRITE_VREG( HEVC_MPRED_CTRL1, READ_VREG( HEVC_MPRED_CTRL1)|(1<<24)); //24
+        WRITE_VREG(HEVC_STREAM_CONTROL, READ_VREG(HEVC_STREAM_CONTROL)|(1<<15)); //15
+        WRITE_VREG(HEVC_CABAC_CONTROL, READ_VREG(HEVC_CABAC_CONTROL)|(1<<13)); //13
+        WRITE_VREG(HEVC_PARSER_CORE_CONTROL, READ_VREG(HEVC_PARSER_CORE_CONTROL)|(1<<15)); //15
+        WRITE_VREG(HEVC_PARSER_INT_CONTROL, READ_VREG(HEVC_PARSER_INT_CONTROL)|(1<<15)); //15
+        WRITE_VREG(HEVC_PARSER_IF_CONTROL, READ_VREG(HEVC_PARSER_IF_CONTROL)|((1<<6)|(1<<3)|(1<<1))); //6, 3, 1
+        WRITE_VREG(HEVCD_IPP_DYNCLKGATE_CONFIG, READ_VREG(HEVCD_IPP_DYNCLKGATE_CONFIG)|0xffffffff); //31:0
+        WRITE_VREG(HEVCD_MCRCC_CTL1, READ_VREG(HEVCD_MCRCC_CTL1)|(1<<3)); //3
+    }
+
+    amhevc_start();
+
+    stat |= STAT_VDEC_RUN;
+
+    set_vdec_func(&vh265_dec_status);
+
+    init_flag = 1;
+
+    //printk("%d, vh265_init, RP=0x%x\n", __LINE__, READ_VREG(HEVC_STREAM_RD_PTR));
+
+    return 0;
+}
+
+static int vh265_stop(void)
+{
+    init_flag = 0;
+    
+    if (stat & STAT_VDEC_RUN) {
+        amhevc_stop();
+        stat &= ~STAT_VDEC_RUN;
+    }
+
+    if (stat & STAT_ISR_REG) {
+        WRITE_VREG(HEVC_ASSIST_MBOX1_MASK, 0);
+        free_irq(INT_VDEC, (void *)vh265_dec_id);
+        stat &= ~STAT_ISR_REG;
+    }
+
+    if (stat & STAT_TIMER_ARM) {
+        del_timer_sync(&recycle_timer);
+        stat &= ~STAT_TIMER_ARM;
+    }
+
+    if (stat & STAT_VF_HOOK) {
+        vf_notify_receiver(PROVIDER_NAME, VFRAME_EVENT_PROVIDER_FR_END_HINT, NULL);
+
+        vf_unreg_provider(&vh265_vf_prov);
+        stat &= ~STAT_VF_HOOK;
+    }
+
+    hevc_local_uninit();
+    
+    if(use_cma){
+        uninit_list = 1;
+        up(&h265_sema);
+        while(uninit_list){ //wait uninit complete
+            msleep(10);
+        }
+    }
+#if 0    
+    if(h265_task)
+        kthread_stop(h265_task);
+    h265_task = NULL;
+#endif
+    amhevc_disable();
+
+    return 0;
+}
+
+static int amvdec_h265_probe(struct platform_device *pdev)
+{
+    struct vdec_dev_reg_s *pdata = (struct vdec_dev_reg_s *)pdev->dev.platform_data;
+    int i;
+
+    mutex_lock(&vh265_mutex);
+    
+    fatal_error = 0;
+
+    if (pdata == NULL) {
+        printk("\namvdec_h265 memory resource undefined.\n");
+        mutex_unlock(&vh265_mutex);
+        return -EFAULT;
+    }
+
+    mc_buf_spec.buf_end = pdata->mem_end + 1;
+    for(i=0;i<WORK_BUF_SPEC_NUM;i++){
+        amvh265_workbuff_spec[i].start_adr = pdata->mem_start;
+    }
+
+    if(debug) printk("===H.265 decoder mem resource 0x%lx -- 0x%lx\n", pdata->mem_start, pdata->mem_end + 1);
+
+    if (pdata->sys_info) {
+        vh265_amstream_dec_info = *pdata->sys_info;
+    } else {
+        vh265_amstream_dec_info.width = 0;
+        vh265_amstream_dec_info.height = 0;
+        vh265_amstream_dec_info.rate = 30;
+    }
+
+    cma_dev = pdata->cma_dev;
+
+    if (vh265_init() < 0) {
+        printk("\namvdec_h265 init failed.\n");
+        hevc_local_uninit();
+        mutex_unlock(&vh265_mutex);
+        return -ENODEV;
+    }
+
+    mutex_unlock(&vh265_mutex);
+    return 0;
+}
+
+static int amvdec_h265_remove(struct platform_device *pdev)
+{
+    if(debug) printk("amvdec_h265_remove\n");
+
+    mutex_lock(&vh265_mutex);
+
+    vh265_stop();
+
+#ifdef DEBUG_PTS
+    printk("pts missed %ld, pts hit %ld, duration %d\n",
+           pts_missed, pts_hit, frame_dur);
+#endif
+
+    mutex_unlock(&vh265_mutex);
+    
+    return 0;
+}
+
+/****************************************/
+
+static struct platform_driver amvdec_h265_driver = {
+    .probe   = amvdec_h265_probe,
+    .remove  = amvdec_h265_remove,
+#ifdef CONFIG_PM
+    .suspend = amhevc_suspend,
+    .resume  = amhevc_resume,
+#endif
+    .driver  = {
+        .name = DRIVER_NAME,
+    }
+};
+
+static struct codec_profile_t amvdec_h265_profile = {
+    .name = "hevc",
+    .profile = ""
+};
+
+static int __init amvdec_h265_driver_init_module(void)
+{
+    printk("amvdec_h265 module init\n");
+
+    if (platform_driver_register(&amvdec_h265_driver)) {
+        printk("failed to register amvdec_h265 driver\n");
+        return -ENODEV;
+    }
+
+    #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
+    if (IS_MESON_M8_CPU) {
+        amvdec_h265_profile.name = "hevc_unsupport"; //not support hevc
+    }else if(IS_MESON_M8M2_CPU){
+        amvdec_h265_profile.profile = "4k"; //m8m2 support 4k
+    }else if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESONG9TV)
+	 amvdec_h265_profile.profile = "4k";
+    #endif
+
+    vcodec_profile_register(&amvdec_h265_profile);
+
+    return 0;
+}
+
+static void __exit amvdec_h265_driver_remove_module(void)
+{
+    printk("amvdec_h265 module remove.\n");
+
+    platform_driver_unregister(&amvdec_h265_driver);
+}
+
+/****************************************/
+
+module_param(stat, uint, 0664);
+MODULE_PARM_DESC(stat, "\n amvdec_h265 stat \n");
+
+module_param(use_cma, uint, 0664);
+MODULE_PARM_DESC(use_cma, "\n amvdec_h265 use_cma \n");
+
+module_param(bit_depth_luma, uint, 0664);
+MODULE_PARM_DESC(bit_depth_luma, "\n amvdec_h265 bit_depth_luma \n");
+
+module_param(bit_depth_chroma, uint, 0664);
+MODULE_PARM_DESC(bit_depth_chroma, "\n amvdec_h265 bit_depth_chroma \n");
+
+module_param(debug, uint, 0664);
+MODULE_PARM_DESC(debug, "\n amvdec_h265 debug \n");
+
+#ifdef ERROR_HANDLE_DEBUG
+module_param(dbg_nal_skip_flag, uint, 0664);
+MODULE_PARM_DESC(dbg_nal_skip_flag, "\n amvdec_h265 dbg_nal_skip_flag \n");
+
+module_param(dbg_nal_skip_count, uint, 0664);
+MODULE_PARM_DESC(dbg_nal_skip_count, "\n amvdec_h265 dbg_nal_skip_count \n");
+#endif
+
+module_param(step, uint, 0664);
+MODULE_PARM_DESC(step, "\n amvdec_h265 step \n");
+
+module_param(decode_stop_pos, uint, 0664);
+MODULE_PARM_DESC(decode_stop_pos, "\n amvdec_h265 decode_stop_pos \n");
+
+module_param(decode_pic_begin, uint, 0664);
+MODULE_PARM_DESC(decode_pic_begin, "\n amvdec_h265 decode_pic_begin \n");
+
+module_param(slice_parse_begin, uint, 0664);
+MODULE_PARM_DESC(slice_parse_begin, "\n amvdec_h265 slice_parse_begin \n");
+
+module_param(nal_skip_policy, uint, 0664);
+MODULE_PARM_DESC(nal_skip_policy, "\n amvdec_h265 nal_skip_policy \n");
+
+module_param(i_only_flag, uint, 0664);
+MODULE_PARM_DESC(i_only_flag, "\n amvdec_h265 i_only_flag \n");
+
+module_param(error_handle_policy, uint, 0664);
+MODULE_PARM_DESC(error_handle_policy, "\n amvdec_h265 error_handle_policy \n");
+
+module_param(error_handle_threshold, uint, 0664);
+MODULE_PARM_DESC(error_handle_threshold, "\n amvdec_h265 error_handle_threshold \n");
+
+module_param(error_handle_nal_skip_threshold, uint, 0664);
+MODULE_PARM_DESC(error_handle_nal_skip_threshold, "\n amvdec_h265 error_handle_nal_skip_threshold \n");
+
+module_param(error_handle_system_threshold, uint, 0664);
+MODULE_PARM_DESC(error_handle_system_threshold, "\n amvdec_h265 error_handle_system_threshold \n");
+
+module_param(error_skip_nal_count, uint, 0664);
+MODULE_PARM_DESC(error_skip_nal_count, "\n amvdec_h265 error_skip_nal_count \n");
+
+module_param(buf_alloc_width, uint, 0664);
+MODULE_PARM_DESC(buf_alloc_width, "\n buf_alloc_width \n");
+
+module_param(buf_alloc_height, uint, 0664);
+MODULE_PARM_DESC(buf_alloc_height, "\n buf_alloc_height \n");
+
+module_param(buf_alloc_size, uint, 0664);
+MODULE_PARM_DESC(buf_alloc_size, "\n buf_alloc_size \n");
+
+module_param(buffer_mode, uint, 0664);
+MODULE_PARM_DESC(buffer_mode, "\n buffer_mode \n");
+
+module_param(max_buf_num, uint, 0664);
+MODULE_PARM_DESC(max_buf_num, "\n max_buf_num \n");
+
+module_param(dynamic_buf_num_margin, uint, 0664);
+MODULE_PARM_DESC(dynamic_buf_num_margin, "\n dynamic_buf_num_margin\n");
+
+module_param(interlace_enable, uint, 0664);
+MODULE_PARM_DESC(interlace_enable, "\n interlace_enable \n");
+
+module_init(amvdec_h265_driver_init_module);
+module_exit(amvdec_h265_driver_remove_module);
+
+MODULE_DESCRIPTION("AMLOGIC h265 Video Decoder Driver");
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Tim Yao <tim.yao@amlogic.com>");
+
+
